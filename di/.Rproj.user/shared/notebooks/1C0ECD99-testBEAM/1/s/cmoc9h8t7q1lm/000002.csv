"0","```r
buildBranchCellDataSet <- 
  function(cds,
           progenitor_method = c('sequential_split', 'duplicate'),
           branch_states = NULL,
           branch_point = 1,
           branch_labels = NULL,
           stretch = TRUE)
  {
    # TODO: check that branches are on the same paths
    if(is.null(pData(cds)$State) | is.null(pData(cds)$Pseudotime))
      stop('Please first order the cells in pseudotime using orderCells()')
    if(is.null(branch_point) & is.null(branch_states))
      stop('Please either specify the branch_point or branch_states to select subset of cells')
    #if(ncol(cds@reducedDimS) != ncol(cds))
    #  stop('You probably used clusterCells function which should be used together with buildBranchCellDataSet, try re-run reduceDimension without clustering cells again')
    
    if (!is.null(branch_labels) & !is.null(branch_states)) {
      if(length(branch_labels) != length(branch_states))
        stop(\"length of branch_labels doesn't match with that of branch_states\")
      branch_map <- setNames(branch_labels, as.character(branch_states))
    }
    
    if(cds@dim_reduce_type == \"DDRTree\") {
      pr_graph_cell_proj_mst <- minSpanningTree(cds)
    }
    else {
      pr_graph_cell_proj_mst <- cds@auxOrderingData[[cds@dim_reduce_type]]$cell_ordering_tree
    }
    
    root_cell <- cds@auxOrderingData[[cds@dim_reduce_type]]$root_cell
    root_state <- pData(cds)[root_cell,]$State
    #root_state <- V(pr_graph_cell_proj_mst)[root_cell,]$State
    
    pr_graph_root <- subset(pData(cds), State == root_state)
    
    if (cds@dim_reduce_type == \"DDRTree\"){
      closest_vertex <- cds@auxOrderingData[[\"DDRTree\"]]$pr_graph_cell_proj_closest_vertex
      root_cell_point_in_Y <- closest_vertex[row.names(pr_graph_root),]
    }else{
      root_cell_point_in_Y <- row.names(pr_graph_root)
    }
    
    root_cell <- names(which(degree(pr_graph_cell_proj_mst, v = root_cell_point_in_Y, mode = \"all\")==1, useNames = T))[1]
    
    paths_to_root <- list()
    if (is.null(branch_states) == FALSE){
      
      # If the user didn't specify a branch point,
      # let's walk back from the branch states
      for (leaf_state in branch_states){
        
        curr_cell <- subset(pData(cds), State == leaf_state)
        #Get all the nearest cells in Y for curr_cells:
        
        if (cds@dim_reduce_type == \"DDRTree\"){
          closest_vertex <- cds@auxOrderingData[[\"DDRTree\"]]$pr_graph_cell_proj_closest_vertex
          curr_cell_point_in_Y <- closest_vertex[row.names(curr_cell),]
        }else{
          curr_cell_point_in_Y <- row.names(curr_cell)
        }
        
        # Narrow down to a single tip cell in Y:
        curr_cell <- names(which(degree(pr_graph_cell_proj_mst, v = curr_cell_point_in_Y, mode = \"all\")==1, useNames = T))[1]
        
        path_to_ancestor <- shortest_paths(pr_graph_cell_proj_mst,curr_cell, root_cell)
        path_to_ancestor <- names(unlist(path_to_ancestor$vpath))
        
        if (cds@dim_reduce_type == \"DDRTree\"){
          closest_vertex <- cds@auxOrderingData[[\"DDRTree\"]]$pr_graph_cell_proj_closest_vertex
          ancestor_cells_for_branch <- row.names(closest_vertex)[which(V(pr_graph_cell_proj_mst)[closest_vertex]$name %in% path_to_ancestor)]
        }else if (cds@dim_reduce_type == \"ICA\"){
          ancestor_cells_for_branch <- path_to_ancestor
        }
        ancestor_cells_for_branch <- intersect(ancestor_cells_for_branch, colnames(cds))
        paths_to_root[[as.character(leaf_state)]] <- ancestor_cells_for_branch
      }
    }else{
      if(cds@dim_reduce_type == \"DDRTree\")
        pr_graph_cell_proj_mst <- minSpanningTree(cds)
      else
        pr_graph_cell_proj_mst <- cds@auxOrderingData$ICA$cell_ordering_tree
      
      mst_branch_nodes <- cds@auxOrderingData[[cds@dim_reduce_type]]$branch_points
      branch_cell <- mst_branch_nodes[branch_point]
      mst_no_branch_point <- pr_graph_cell_proj_mst - V(pr_graph_cell_proj_mst)[branch_cell]
      
      path_to_ancestor <- shortest_paths(pr_graph_cell_proj_mst, branch_cell, root_cell)
      path_to_ancestor <- names(unlist(path_to_ancestor$vpath))
      
      #post_branch_cells <- c()
      for (backbone_nei in V(pr_graph_cell_proj_mst)[suppressWarnings(nei(branch_cell))]$name){
        descendents <- bfs(mst_no_branch_point, V(mst_no_branch_point)[backbone_nei], unreachable=FALSE)
        descendents <- descendents$order[!is.na(descendents$order)]
        descendents <- V(mst_no_branch_point)[descendents]$name
        if (root_cell %in% descendents == FALSE){
          path_to_root <- unique(c(path_to_ancestor, branch_cell, descendents))
          
          if (cds@dim_reduce_type == \"DDRTree\"){
            closest_vertex <- cds@auxOrderingData[[\"DDRTree\"]]$pr_graph_cell_proj_closest_vertex
            path_to_root <- row.names(closest_vertex)[which(V(pr_graph_cell_proj_mst)[closest_vertex]$name %in% path_to_root)]
          }else{
            path_to_root <- path_to_root
          }
          
          closest_vertex <- cds@auxOrderingData[[\"DDRTree\"]]$pr_graph_cell_proj_closest_vertex
          #branch_state <- unique(pData(cds)[backbone_nei, ]$State)[1]
          
          path_to_root <- intersect(path_to_root, colnames(cds))
          paths_to_root[[backbone_nei]] <- path_to_root
          #post_branch_cells <- c(post_branch_cells, backbone_nei)
        }
      }
    }
    all_cells_in_subset <- c()
    
    if (is.null(branch_labels) == FALSE){
      if (length(branch_labels) != 2)
        stop(\"Error: branch_labels must have exactly two entries\")
      names(paths_to_root) <- branch_labels
    }
    
    for (path_to_ancestor in paths_to_root){
      if (length(path_to_ancestor) == 0){
        stop(\"Error: common ancestors between selected State values on path to root State\")
      }
      all_cells_in_subset <- c(all_cells_in_subset, path_to_ancestor)
    }
    all_cells_in_subset <- unique(all_cells_in_subset)
    
    common_ancestor_cells <- intersect(paths_to_root[[1]], paths_to_root[[2]])
    # if (length(paths_to_root) > 2){
    #   for (i in seq(3,length(paths_to_root))){
    #     common_ancestor_cells <- intersect(intersect(paths_to_root[i], paths_to_root[i-1]), common_ancestor_cells)
    #   }
    # }
    
    #when n-center used, this creates problems
    cds <- cds[, row.names(pData(cds[,all_cells_in_subset]))] #or just union(ancestor_cells, branch_cells)
    
    #State <- pData(cds)$State
    Pseudotime <- pData(cds)$Pseudotime
    
    pData <- pData(cds)
    
    if(stretch) {
      max_pseudotime <- -1
      for (path_to_ancestor in paths_to_root){
        max_pseudotime_on_path <- max(pData[path_to_ancestor,]$Pseudotime)
        if (max_pseudotime < max_pseudotime_on_path){
          max_pseudotime <- max_pseudotime_on_path
        }
      }
      
      branch_pseudotime <- max(pData[common_ancestor_cells,]$Pseudotime)
      #ancestor_scaling_factor <- branch_pseudotime / max_pseudotime
      
      for (path_to_ancestor in paths_to_root){
        max_pseudotime_on_path <- max(pData[path_to_ancestor,]$Pseudotime)
        path_scaling_factor <-(max_pseudotime - branch_pseudotime) / (max_pseudotime_on_path - branch_pseudotime)
        if (is.finite(path_scaling_factor)){
          branch_cells <- setdiff(path_to_ancestor, common_ancestor_cells)
          pData[branch_cells,]$Pseudotime <- ((pData[branch_cells,]$Pseudotime - branch_pseudotime) * path_scaling_factor + branch_pseudotime)
        }
      }
      #pData[common_ancestor_cells,]$Pseudotime <- pData[common_ancestor_cells,]$Pseudotime / max_pseudotime
      
      pData$Pseudotime <- 100 * pData$Pseudotime / max_pseudotime
    }
    pData$original_cell_id <- row.names(pData)
    
    pData$original_cell_id <- row.names(pData)
    
    if(length(paths_to_root) != 2)
      stop('more than 2 branch states are used!')
    
    pData[common_ancestor_cells, \"Branch\"] <- names(paths_to_root)[1] #set progenitors to the branch 1
    
    progenitor_pseudotime_order <- order(pData[common_ancestor_cells, 'Pseudotime'])
    
    if (progenitor_method == 'duplicate') {
      ancestor_exprs <- exprs(cds)[,common_ancestor_cells]
      expr_blocks <- list()
      
      # Duplicate the expression data
      for (i in 1:length(paths_to_root)) { #duplicate progenitors for multiple branches
        if (nrow(ancestor_exprs) == 1)
          exprs_data <- t(as.matrix(ancestor_exprs))
        else exprs_data <- ancestor_exprs
        
        colnames(exprs_data) <- paste('duplicate', i, 1:length(common_ancestor_cells), sep = '_')
        expr_lineage_data <- exprs(cds)[,setdiff(paths_to_root[[i]], common_ancestor_cells)]
        exprs_data <- cbind(exprs_data, expr_lineage_data)
        expr_blocks[[i]] <- exprs_data
      }
      
      # Make a bunch of copies of the pData entries from the common ancestors
      ancestor_pData_block <- pData[common_ancestor_cells,]
      
      pData_blocks <- list()
      
      weight_vec <- c()
      for (i in 1:length(paths_to_root)) {
        weight_vec <- c(weight_vec, rep(1, length(common_ancestor_cells)))
        weight_vec_block <- rep(1, length(common_ancestor_cells))
        
        #pData <- rbind(pData, pData[common_ancestor_cells, ])
        new_pData_block <- ancestor_pData_block
        # new_pData_block$Lineage <- lineage_states[i]
        # new_pData_block$State <- lineage_states[i]
        
        row.names(new_pData_block) <- paste('duplicate', i, 1:length(common_ancestor_cells), sep = '_')
        
        pData_lineage_cells <- pData[setdiff(paths_to_root[[i]], common_ancestor_cells),]
        # pData_lineage_cells$Lineage <- lineage_states[i]
        # pData_lineage_cells$State <- lineage_states[i]
        
        weight_vec_block <- c(weight_vec_block, rep(1, nrow(pData_lineage_cells)))
        
        weight_vec <- c(weight_vec, weight_vec_block)
        
        new_pData_block <- rbind(new_pData_block, pData_lineage_cells)
        new_pData_block$Branch <- names(paths_to_root)[i]
        pData_blocks[[i]] <- new_pData_block
      }
      pData <- do.call(rbind, pData_blocks)
      exprs_data <- do.call(cbind, expr_blocks)
    }
    else if(progenitor_method == 'sequential_split') {
      pData$Branch <- names(paths_to_root)[1]
      
      branchA <- progenitor_pseudotime_order[seq(1, length(common_ancestor_cells), by = 2)]
      pData[common_ancestor_cells[branchA], 'Branch'] <- names(paths_to_root)[1]
      branchB <- progenitor_pseudotime_order[seq(2, length(common_ancestor_cells), by = 2)]
      pData[common_ancestor_cells[branchB], 'Branch'] <- names(paths_to_root)[2]
      
      # Duplicate the root cell to make sure both regression start at pseudotime zero:
      zero_pseudotime_root_cell <- common_ancestor_cells[progenitor_pseudotime_order[1]]
      exprs_data <- cBind(exprs(cds), 'duplicate_root' = exprs(cds)[, zero_pseudotime_root_cell])
      pData <- rbind(pData, pData[zero_pseudotime_root_cell, ])
      row.names(pData)[nrow(pData)] <- 'duplicate_root'
      pData[nrow(pData), 'Branch'] <- names(paths_to_root)[2]
      
      weight_vec <- rep(1, nrow(pData))
      
      for (i in 1:length(paths_to_root)){
        path_to_ancestor <- paths_to_root[[i]]
        branch_cells <- setdiff(path_to_ancestor, common_ancestor_cells)
        pData[branch_cells,]$Branch <- names(paths_to_root)[i]
      }
    }
    
    pData$Branch <- as.factor(pData$Branch)
    
    pData$State <- factor(pData$State)
    Size_Factor <- pData$Size_Factor
    
    fData <- fData(cds)
    
    colnames(exprs_data) <- row.names(pData) #check this
    cds_subset <- newCellDataSet(as.matrix(exprs_data),
                                 phenoData = new(\"AnnotatedDataFrame\", data = pData),
                                 featureData = new(\"AnnotatedDataFrame\", data = fData),
                                 expressionFamily=cds@expressionFamily,
                                 lowerDetectionLimit=cds@lowerDetectionLimit)
    pData(cds_subset)$State <- as.factor(pData(cds_subset)$State)
    pData(cds_subset)$Size_Factor <- Size_Factor
    
    cds_subset@dispFitInfo <- cds@dispFitInfo
    
    return (cds_subset)
  }
calILRs <- function (cds, 
          trend_formula = \"~sm.ns(Pseudotime, df = 3)*Branch\",
          branch_point = 1,
          trajectory_states = NULL, 
          relative_expr = TRUE, 
          stretch = TRUE, 
          cores = 1, 
          ILRs_limit = 3, 
          label_by_short_name = TRUE,
          useVST = FALSE, 
          round_exprs = FALSE, 
          output_type = \"all\", 
          branch_labels = NULL, 
          file = NULL, 
          return_all = F, 
          verbose = FALSE, 
          ...){
  if(!is.null(trajectory_states)){
    if (length(trajectory_states) != 2)
      stop(\"Sorry, this function only supports the calculation of ILRs between TWO branch trajectories\")
  }
  
  cds_subset <- buildBranchCellDataSet(cds = cds, branch_states = trajectory_states,
                                       branch_point = branch_point,
                                       progenitor_method = 'duplicate',
                                       branch_labels = branch_labels, stretch = stretch, ...)
  overlap_rng <- c(0, max(pData(cds_subset)$Pseudotime))
  
  
  # if (length(trajectory_states) != 2)
  #   stop(\"calILRs can only work for two Branches\")
  # if(!all(pData(cds_subset)[pData(cds_subset)$State %in% trajectory_states, \"Branch\"] %in% pData(cds_subset)[, \"Branch\"]))
  #     stop(\"state(s) in trajectory_states are not included in 'Branch'\")
  
  # if(verbose)
  #   message(paste(\"the pseudotime range for the calculation of ILRs:\", overlap_rng[1], overlap_rng[2], sep = ' '))
  if(is.null(trajectory_states))
    trajectory_states <- unique(pData(cds_subset)[, \"Branch\"])
  
  if(!is.null(branch_labels)){
    trajectory_states <- branch_labels
  }
  else if(is.null(trajectory_states)){
    trajectory_states_tmp <- as.character(trajectory_states)
    branch_stats <- table(pData(cds_subset)[row.names(subset(pData(cds), as.character(State) == trajectory_states_tmp[1])), 'Branch'])
    trajectory_states[1] <- names(which.max(branch_stats))
    branch_stats <- table(pData(cds_subset)[row.names(subset(pData(cds), as.character(State) == trajectory_states_tmp[2])), 'Branch'])
    trajectory_states[2] <- names(which.max(branch_stats))
  }
  
  cds_branchA <- cds_subset[, pData(cds_subset)[, \"Branch\"] ==
                              trajectory_states[1]]
  cds_branchB <- cds_subset[, pData(cds_subset)[, \"Branch\"] ==
                              trajectory_states[2]]
  
  formula_all_variables <- all.vars(as.formula(trend_formula))
  
  if(!all(formula_all_variables %in% colnames(pData(cds_subset))))
    stop('All the variables in the model formula has to be included in the pData columns (excepting Branch)')
  
  t_rng <- range(pData(cds_branchA)$Pseudotime)
  str_new_cds_branchA <- data.frame(Pseudotime = seq(overlap_rng[1], overlap_rng[2],
                                                     length.out = 100), Branch = as.factor(as.character(trajectory_states[1])))
  if (verbose)
    message(paste(\"Check the whether or not Pseudotime scaled from 0 to 100: \",
                  sort(pData(cds_branchA)$Pseudotime)))
  colnames(str_new_cds_branchA)[2] <- formula_all_variables[2] #interaction term can be terms rather than Branch
  
  str_new_cds_branchB <- data.frame(Pseudotime = seq(overlap_rng[1], overlap_rng[2],
                                                     length.out = 100), Branch = as.factor(as.character(trajectory_states[2])))
  if (verbose)
    message(paste(\"Check the whether or not Pseudotime scaled from 0 to 100: \",
                  sort(pData(cds_branchB)$Pseudotime)))
  
  colnames(str_new_cds_branchB)[2] <- formula_all_variables[2] #interaction term can be terms rather than Branch
  
  str_branchAB_expression_curve_matrix <- genSmoothCurves(cds_subset, cores=cores, trend_formula = trend_formula,
                                                          relative_expr = relative_expr, new_data = rbind(str_new_cds_branchA, str_new_cds_branchB))
  
  str_branchA_expression_curve_matrix <- str_branchAB_expression_curve_matrix[, 1:nrow(str_new_cds_branchA)]
  str_branchB_expression_curve_matrix <- str_branchAB_expression_curve_matrix[, 
                                                                              (nrow(str_new_cds_branchA) + 1):(nrow(str_new_cds_branchA) + nrow(str_new_cds_branchB))]
  
  if (useVST) {
    str_branchA_expression_curve_matrix <- vstExprs(cds,
                                                    expr_matrix = str_branchA_expression_curve_matrix,
                                                    round_vals = round_exprs)
    str_branchB_expression_curve_matrix <- vstExprs(cds,
                                                    expr_matrix = str_branchB_expression_curve_matrix,
                                                    round_vals = round_exprs)
    str_logfc_df <- str_branchA_expression_curve_matrix -
      str_branchB_expression_curve_matrix
  }
  else {
    str_logfc_df <- log2((str_branchA_expression_curve_matrix +
                            1)/(str_branchB_expression_curve_matrix + 1))
  }
  if (label_by_short_name) {
    row.names(str_logfc_df) <- fData(cds[, ])$gene_short_name
  }
  str_logfc_df[which(str_logfc_df <= -ILRs_limit, arr.ind = T)] <- -ILRs_limit
  str_logfc_df[which(str_logfc_df >= ILRs_limit, arr.ind = T)] <- ILRs_limit
  if (output_type == \"after_bifurcation\") {
    t_bifurcation_ori <- min(pData(cds[, c(which(pData(cds)$State ==
                                                   trajectory_states[1]), which(pData(cds)$State == trajectory_states[2]))])$Pseudotime)
    t_bifurcation <- pData(cds_subset[, pData(cds)$Pseudotime ==
                                        t_bifurcation_ori])$Pseudotime
    
    if (stretch)
      bif_index <- as.integer(pData(cds_subset[, pData(cds)$Pseudotime ==
                                                 t_bifurcation])$Pseudotime)
    else {
      bif_index <- as.integer(min(t_bifurcation/(max(pData(cds_branchA)$Pseudotime)/100),
                                  t_bifurcation/(max(pData(cds_branchB)$Pseudotime)/100)))
    }
    str_logfc_df[, bif_index:100] <- str_logfc_df
  }
  if (!is.null(file))
    save(str_logfc_df, str_branchA_expression_curve_matrix, str_branchB_expression_curve_matrix, file = file)
  
  if(return_all) {
    rMax <- function(df) {apply(df, 1, function(x) if(all(is.na(x))) NA else max(abs(x), na.rm = T))} #calculate row max
    
    str_raw_div_df <- str_branchA_expression_curve_matrix - str_branchB_expression_curve_matrix
    str_norm_div_df <- str_raw_div_df / rMax(str_raw_div_df) #calculate normalized divergence
    
    log_str_raw_div_df <- log2((str_branchA_expression_curve_matrix + .1)/(str_branchB_expression_curve_matrix + .1))
    norm_str_logfc_df <- str_logfc_df / rMax(log_str_raw_div_df) #calculate normalized divergence
    
    return(list(str_logfc_df = str_logfc_df, norm_str_logfc_df = norm_str_logfc_df,
                str_norm_div_df = str_norm_div_df, str_raw_div_df = str_raw_div_df, str_branchA_expression_curve_matrix = str_branchA_expression_curve_matrix, 
                str_branchB_expression_curve_matrix = str_branchB_expression_curve_matrix))
  }
  else
    return(str_logfc_df)
}

detectBifurcationPoint <- 
function(str_log_df = NULL, 
         ILRs_threshold = 0.1, 
         detect_all = T,
         cds = cds,
         Branch = 'Branch',
         branch_point=NULL,
         branch_states = c(2, 3),
         stretch = T,
         cores = 1,
         trend_formula = \"~sm.ns(Pseudotime, df = 3)\",
         ILRs_limit = 3,
         relative_expr = TRUE,
         label_by_short_name = TRUE,
         useVST = FALSE,
         round_exprs = FALSE,
         output_type = 'all', #'after_bifurcation
         return_cross_point = T, 
         file = \"bifurcation_heatmap\", verbose = FALSE, ...) {
  if(is.null(str_log_df)) {
    if(Branch == 'Branch') output_type = 'after_bifurcation'
    
    str_log_df <- calILRs(cds = cds,
                          Branch,
                          branch_states,
                          branch_point=branch_point,
                          stretch,
                          cores,
                          trend_formula,
                          ILRs_limit,
                          relative_expr,
                          label_by_short_name,
                          useVST,
                          round_exprs,
                          output_type = output_type,
                          file, verbose, ...)
  }
  # rMax <- function(df) {apply(df, 1, function(x) if(all(is.na(x))) NA else max(abs(x), na.rm = T))}
  
  else {
    bifurcation_time <- apply(str_log_df, 1, function(x) {
      # deriv <- diff(x) the ILRs are smooth, so use min is fine
      index <- Inf
      
      #new algorithm to bifurcation time point:
      if(all(is.na(x))) {
        return(NA)
      }
      
      max_ind <- which(abs(x) == max(abs(x)))
      
      # return(max(max_ind))
      if(length(max_ind) > 1) {
        max_ind <- min(max_ind)
        warning('multiple maximal time points detected ', max_ind)
      }
      
      #detect the cross point
      inflection_point_tmp <- which(x[1:(length(x) - 1)] * x[2:length(x)] <= 0)
      
      if(all(max_ind <= inflection_point_tmp)) return(NA) #remove all zero values and genes monotonically goes down
      
      inflection_point <- max(inflection_point_tmp[inflection_point_tmp < max_ind])
      
      if(return_cross_point == T) {
        return(inflection_point * sign(sum(x)))
      }
      
      else if (return_cross_point == F & !is.null(ILRs_threshold) ) { 
        rev_x <- rev(x[(inflection_point):max_ind])
        if(any(which(abs(rev_x) >= ILRs_threshold))){
          index_tmp <- max(which(abs(rev_x) > ILRs_threshold))
          index <- (max_ind - index_tmp + 1 ) * sign(sum(rev_x))
        }
        else if(detect_all & all(!is.na(rev_x))) {
          index_tmp <-  max(which(abs(rev_x) == max(abs(rev_x)))) #the earliest time point when the bifurcation is largest 
          index <- (max_ind - index_tmp + 1 ) * sign(sum(rev_x)) 
        }
      }
      index
    })
  }
  
  # print(bifurcation_time)
  # str_norm_div_df
  
  names(bifurcation_time) <- row.names(str_log_df)
  
  return(bifurcation_time)
}

```"
