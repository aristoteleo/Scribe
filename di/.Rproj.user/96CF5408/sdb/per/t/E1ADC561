{
    "collab_server" : "",
    "contents" : "#' @param x test\n#' @param modelFormulaStr a formula string specifying the model to fit for the genes.\n#' @param expressionFamily specifies the VGAM family function used for expression responses\n#' @param relative_expr Whether to transform expression into relative values\n#' @param disp_func test\n#' @param verbose Whether to show VGAM errors and warnings. Only valid for cores = 1.\n#' @param ... test\n#' @title Helper function for parallel VGAM fitting\n#' @name fit_model_helper\n#' @description test\nfit_model_helper <- function(x, \n                             modelFormulaStr, \n                             expressionFamily, \n                             relative_expr, \n                             disp_func=NULL, \n                             verbose=FALSE,\n                             ...){\n\n    modelFormulaStr <- paste(\"f_expression\", modelFormulaStr,\n    sep = \"\")\n    orig_x <- x\n    # FIXME: should we be using this here?\n    # x <- x + pseudocount\n    if (expressionFamily@vfamily %in% c(\"negbinomial\", \"negbinomial.size\")) {\n        if (relative_expr) {\n            x <- x/Size_Factor\n        }\n        f_expression <- round(x)\n        if (is.null(disp_func) == FALSE) {\n            disp_guess <- calulate_NB_dispersion_hint(disp_func,\n                round(orig_x))\n            if (is.null(disp_guess) == FALSE && disp_guess >\n                0 && is.na(disp_guess) == FALSE) {\n                size_guess <- 1/disp_guess\n                if (expressionFamily@vfamily == \"negbinomial\")\n                  expressionFamily <- negbinomial(isize=1/disp_guess, ...)\n                else\n                  expressionFamily <- negbinomial.size(size=1/disp_guess, ...)\n            }\n        }\n    }\n    else if (expressionFamily@vfamily %in% c(\"gaussianff\", \"uninormal\", \"binomialff\")) {\n        f_expression <- x\n    }\n    else {\n        f_expression <- log10(x)\n    }\n    tryCatch({\n        if (verbose) {\n            FM_fit <- VGAM::vglm(as.formula(modelFormulaStr),\n                family = expressionFamily, epsilon=1e-1)\n        }\n        else {\n            FM_fit <- suppressWarnings(VGAM::vglm(as.formula(modelFormulaStr),\n                family = expressionFamily, epsilon=1e-1))\n        }\n        FM_fit\n    }, error = function(e) {\n        print (e);\n        # If we threw an exception, re-try with a simpler model.  Which one depends on\n        # what the user has specified for expression family\n        #print(disp_guess)\n        backup_expression_family <- NULL\n        if (expressionFamily@vfamily %in% c(\"negbinomial\", \"negbinomial.size\")){\n            disp_guess <- calulate_NB_dispersion_hint(disp_func, round(orig_x), expr_selection_func = max)\n            backup_expression_family <- negbinomial()\n        }else if (expressionFamily@vfamily %in% c(\"gaussianff\", \"uninormal\")){\n          backup_expression_family <- NULL\n        }else if (expressionFamily@vfamily %in% c(\"binomialff\")){\n          backup_expression_family <- NULL\n        }else{\n          backup_expression_family <- NULL\n        }\n        if (is.null(backup_expression_family) == FALSE){\n\n          #FM_fit <- VGAM::vglm(as.formula(modelFormulaStr), family=backup_expression_family, trace=T, epsilon=1e-1, checkwz=F)\n          test_res <- tryCatch({\n          if (verbose){\n            FM_fit <- VGAM::vglm(as.formula(modelFormulaStr), family=backup_expression_family, epsilon = 1e-1, checkwz= TRUE)\n          }else{\n            FM_fit <- suppressWarnings(VGAM::vglm(as.formula(modelFormulaStr), family=backup_expression_family, epsilon = 1e-1, checkwz = TRUE))\n          }\n            FM_fit\n          }, \n          #warning = function(w) { FM_fit },\n          error = function(e) { \n            #print (e);\n            NULL\n          })\n          #print(test_res)\n          test_res\n        } else {\n          #print(e); \n          NULL\n        }\n  })\n}\n\n#' Fits a model for each gene in a CellDataSet object.\n#' @param cds the CellDataSet upon which to perform this operation\n#' @param modelFormulaStr a formula string specifying the model to fit for the genes.\n#' @param relative_expr Whether to fit a model to relative or absolute expression. Only meaningful for count-based expression data. If TRUE, counts are normalized by Size_Factor prior to fitting.\n#' @param cores the number of processor cores to be used during fitting.\n#' @return a list of VGAM model objects\n#' @importFrom qlcMatrix rowMax\n#' @export\n#' @details\n#' \n#' This function fits a vector generalized additive model (VGAM) from the VGAM package for each gene in a CellDataSet. \n#' By default, expression levels are modeled as smooth functions of the Pseudotime value of each \n#' cell. That is, expression is a function of progress through the biological process.  More complicated formulae can be provided to account for\n#' additional covariates (e.g. day collected, genotype of cells, media conditions, etc).\nfitModel <- function(cds,\n                     modelFormulaStr=\"~sm.ns(Pseudotime, df=3)\",\n                     relative_expr=TRUE,\n                     cores=1){\n  if (cores > 1){\n    f<-mcesApply(cds, 1, fit_model_helper, required_packages=c(\"BiocGenerics\", \"Biobase\", \"VGAM\", \"plyr\", \"Matrix\"), cores=cores, \n                 modelFormulaStr=modelFormulaStr, \n                 expressionFamily=cds@expressionFamily,\n                 relative_expr=relative_expr,\n                 disp_func=cds@dispFitInfo[[\"blind\"]]$disp_func)\n    f\n  }else{\n    f<-smartEsApply(cds,1,fit_model_helper, \n                    convert_to_dense=TRUE,\n               modelFormulaStr=modelFormulaStr, \n               expressionFamily=cds@expressionFamily,\n               relative_expr=relative_expr,\n               disp_func=cds@dispFitInfo[[\"blind\"]]$disp_func)\n    f\n  }\n}\n\n#' Response values\n#' \n#' Generates a matrix of response values for a set of fitted models\n#' @param models a list of models, e.g. as returned by fitModels()\n#' @param newdata a dataframe used to generate new data for interpolation of time points\n#' @param response_type the response desired, as accepted by VGAM's predict function\n#' @param cores number of cores used for calculation\n#' @importFrom parallel detectCores mclapply\n#' @return a matrix where each row is a vector of response values for a particular feature's model, and columns are cells.\n#' @export\nresponseMatrix <- function(models, newdata = NULL, response_type=\"response\", cores = 1) {\n    res_list <- mclapply(models, function(x) {\n      if (is.null(x)) { NA } else {\n          if (x@family@vfamily %in% c(\"negbinomial\", \"negbinomial.size\")) {\n              predict(x, newdata = newdata, type = response_type)\n          } else if (x@family@vfamily %in% c(\"gaussianff\")) {\n              predict(x, newdata = newdata, type = response_type)\n          }\n          else {\n              10^predict(x, newdata = newdata, type = response_type)\n          }\n      }\n    }, mc.cores = cores)\n\n    res_list_lengths <- lapply(res_list[is.na(res_list) == FALSE],\n        length)\n    stopifnot(length(unique(res_list_lengths)) == 1)\n    num_na_fits <- length(res_list[is.na(res_list)])\n    if (num_na_fits > 0) {\n        na_matrix <- matrix(rep(rep(NA, res_list_lengths[[1]]),\n            num_na_fits), nrow = num_na_fits)\n        row.names(na_matrix) <- names(res_list[is.na(res_list)])\n        non_na_matrix <- Matrix::t(do.call(cbind, lapply(res_list[is.na(res_list) ==\n            FALSE], unlist)))\n        row.names(non_na_matrix) <- names(res_list[is.na(res_list) ==\n            FALSE])\n        res_matrix <- rbind(non_na_matrix, na_matrix)\n        res_matrix <- res_matrix[names(res_list), ]\n    }\n    else {\n        res_matrix <- Matrix::t(do.call(cbind, lapply(res_list, unlist)))\n        row.names(res_matrix) <- names(res_list[is.na(res_list) ==\n            FALSE])\n    }\n    res_matrix\n}\n\n#' Response values\n#' \n#' Generates a matrix of response values for a set of fitted models\n#' @param models a list of models, e.g. as returned by fitModels()\n#' @param residual_type the response desired, as accepted by VGAM's predict function\n#' @param cores number of cores used for calculation\n#' @return a matrix where each row is a vector of response values for a particular feature's model, and columns are cells.\n#' @importFrom parallel detectCores mclapply\nresidualMatrix <- function(models,  residual_type=\"response\", cores = 1) {\n  res_list <- mclapply(models, function(x) {\n    if (is.null(x)) { NA } else {\n        resid(x, type = residual_type)\n    }\n  }, mc.cores = cores)\n  \n  res_list_lengths <- lapply(res_list[is.na(res_list) == FALSE],\n                             length)\n  stopifnot(length(unique(res_list_lengths)) == 1)\n  num_na_fits <- length(res_list[is.na(res_list)])\n  if (num_na_fits > 0) {\n    na_matrix <- matrix(rep(rep(NA, res_list_lengths[[1]]),\n                            num_na_fits), nrow = num_na_fits)\n    row.names(na_matrix) <- names(res_list[is.na(res_list)])\n    non_na_matrix <- Matrix::t(do.call(cbind, lapply(res_list[is.na(res_list) ==\n                                                                FALSE], unlist)))\n    row.names(non_na_matrix) <- names(res_list[is.na(res_list) ==\n                                                 FALSE])\n    res_matrix <- rbind(non_na_matrix, na_matrix)\n    res_matrix <- res_matrix[names(res_list), ]\n  }\n  else {\n    res_matrix <- Matrix::t(do.call(cbind, lapply(res_list, unlist)))\n    row.names(res_matrix) <- names(res_list[is.na(res_list) ==\n                                              FALSE])\n  }\n  res_matrix\n}\n\n\n#' Fit smooth spline curves and return the response matrix\n#'\n#' This function will fit smooth spline curves for the gene expression dynamics along pseudotime in a gene-wise manner and return\n#' the corresponding response matrix. This function is build on other functions (fit_models and responseMatrix) and used in calILRs and calABCs functions\n#'\n#' @param cds a CellDataSet object upon which to perform this operation\n#' @param new_data a data.frame object including columns (for example, Pseudotime) with names specified in the model formula. The values in the data.frame should be consist with the corresponding values from cds object.\n#' @param trend_formula a formula string specifying the model formula used in fitting the spline curve for each gene/feature.\n#' @param relative_expr a logic flag to determine whether or not the relative gene expression should be used\n#' @param response_type the response desired, as accepted by VGAM's predict function\n#' @param cores the number of cores to be used while testing each gene for differential expression\n#' @importFrom Biobase fData\n#' @return a data frame containing the data for the fitted spline curves.\n#' @export\n#'\ngenSmoothCurves <- function(cds,  new_data, trend_formula = \"~sm.ns(Pseudotime, df = 3)\",\n                        relative_expr = T, response_type=\"response\", cores = 1) { \n  \n  expressionFamily <- cds@expressionFamily\n  \n    if(cores > 1) {\n      expression_curve_matrix <- mcesApply(cds, 1, function(x, trend_formula, expressionFamily, relative_expr, new_data, fit_model_helper, responseMatrix, \n                                                              calulate_NB_dispersion_hint, calulate_QP_dispersion_hint){\n            environment(fit_model_helper) <- environment()\n            environment(responseMatrix) <- environment()\n            model_fits <- fit_model_helper(x, modelFormulaStr = trend_formula, expressionFamily = expressionFamily, \n                                       relative_expr = relative_expr, disp_func = cds@dispFitInfo[['blind']]$disp_func)\n            if(is.null(model_fits))\n                expression_curve <- as.data.frame(matrix(rep(NA, nrow(new_data)), nrow = 1))\n            else\n                expression_curve <- as.data.frame(responseMatrix(list(model_fits), newdata = new_data, response_type=response_type))\n            colnames(expression_curve) <- row.names(new_data)\n            expression_curve\n            #return(expression_curve)\n            }, required_packages=c(\"BiocGenerics\", \"Biobase\", \"VGAM\", \"plyr\"), cores=cores, \n            trend_formula = trend_formula, expressionFamily = expressionFamily, relative_expr = relative_expr, new_data = new_data, \n            fit_model_helper = fit_model_helper, responseMatrix = responseMatrix, calulate_NB_dispersion_hint = calulate_NB_dispersion_hint,\n            calulate_QP_dispersion_hint = calulate_QP_dispersion_hint\n            )\n        expression_curve_matrix <- as.matrix(do.call(rbind, expression_curve_matrix))\n        return(expression_curve_matrix)\n    }\n    else {\n        expression_curve_matrix <- smartEsApply(cds, 1, function(x, trend_formula, expressionFamily, relative_expr, new_data){\n            environment(fit_model_helper) <- environment()\n            environment(responseMatrix) <- environment()\n            model_fits <- fit_model_helper(x, modelFormulaStr = trend_formula, expressionFamily = expressionFamily,\n                                       relative_expr = relative_expr, disp_func = cds@dispFitInfo[['blind']]$disp_func)\n            if(is.null(model_fits))\n                expression_curve <- as.data.frame(matrix(rep(NA, nrow(new_data)), nrow = 1))\n            else\n                expression_curve <- as.data.frame(responseMatrix(list(model_fits), new_data, response_type=response_type))\n            colnames(expression_curve) <- row.names(new_data)\n            expression_curve\n            }, \n            convert_to_dense=TRUE,\n            trend_formula = trend_formula, expressionFamily = expressionFamily, relative_expr = relative_expr, new_data = new_data\n            )\n        expression_curve_matrix <- as.matrix(do.call(rbind, expression_curve_matrix))\n        row.names(expression_curve_matrix) <- row.names(fData(cds))\n        return(expression_curve_matrix)\n      }\n\n}\n#' Fit smooth spline curves and return the residuals matrix\n#'\n#' This function will fit smooth spline curves for the gene expression dynamics along pseudotime in a gene-wise manner and return\n#' the corresponding residuals matrix. This function is build on other functions (fit_models and residualsMatrix)\n#'\n#' @param cds a CellDataSet object upon which to perform this operation\n#' @param trend_formula a formula string specifying the model formula used in fitting the spline curve for each gene/feature.\n#' @param relative_expr a logic flag to determine whether or not the relative gene expression should be used\n#' @param residual_type the response desired, as accepted by VGAM's predict function\n#' @param cores the number of cores to be used while testing each gene for differential expression\n#' @importFrom Biobase pData fData\n#' @return a data frame containing the data for the fitted spline curves.\n#'\ngenSmoothCurveResiduals <- function(cds, trend_formula = \"~sm.ns(Pseudotime, df = 3)\",\n                            relative_expr = T,  residual_type=\"response\", cores = 1) { \n  \n  expressionFamily <- cds@expressionFamily\n  \n  if(cores > 1) {\n    expression_curve_matrix <- mcesApply(cds, 1, function(x, trend_formula, expressionFamily, relative_expr, fit_model_helper, residualMatrix, \n                                                    calulate_NB_dispersion_hint, calulate_QP_dispersion_hint){\n      environment(fit_model_helper) <- environment()\n      environment(responseMatrix) <- environment()\n      model_fits <- fit_model_helper(x, modelFormulaStr = trend_formula, expressionFamily = expressionFamily,\n                                     relative_expr = relative_expr, disp_func = cds@dispFitInfo[['blind']]$disp_func)\n      if(is.null(model_fits))\n        expression_curve <- as.data.frame(matrix(rep(NA, nrow(pData(cds))), nrow = 1))\n      else\n        expression_curve <- as.data.frame(residualMatrix(list(model_fits), residual_type=residual_type))\n      #colnames(expression_curve) <- row.names(pData(cds))\n      expression_curve\n      #return(expression_curve)\n    }, required_packages=c(\"BiocGenerics\", \"Biobase\", \"VGAM\", \"plyr\"), cores=cores, \n    trend_formula = trend_formula, expressionFamily = expressionFamily, relative_expr = relative_expr,\n    fit_model_helper = fit_model_helper, residualMatrix = residualMatrix, calulate_NB_dispersion_hint = calulate_NB_dispersion_hint,\n    calulate_QP_dispersion_hint = calulate_QP_dispersion_hint\n    )\n    expression_curve_matrix <- do.call(rbind, expression_curve_matrix)\n    return(expression_curve_matrix)\n  }\n  else {\n    expression_curve_matrix <- smartEsApply(cds, 1, function(x, trend_formula, expressionFamily, relative_expr){\n      environment(fit_model_helper) <- environment()\n      environment(residualMatrix) <- environment()\n      model_fits <- fit_model_helper(x, modelFormulaStr = trend_formula, expressionFamily = expressionFamily, \n                                     relative_expr = relative_expr, disp_func = cds@dispFitInfo[['blind']]$disp_func)\n      if(is.null(model_fits))\n        expression_curve <-  as.data.frame(matrix(rep(NA, nrow(pData(cds))), nrow = 1))\n      else\n        expression_curve <-  as.data.frame(residualMatrix(list(model_fits), residual_type=residual_type))\n      #colnames(expression_curve) <- row.names(pData(cds))\n      expression_curve\n    }, \n    convert_to_dense=TRUE,\n    trend_formula = trend_formula, expressionFamily = expressionFamily, relative_expr = relative_expr\n    )\n    expression_curve_matrix <- do.call(rbind, expression_curve_matrix)\n    row.names(expression_curve_matrix) <- row.names(fData(cds))\n    return(expression_curve_matrix)\n  }\n  \n}\n\n\n## This function was swiped from DESeq (Anders and Huber) and modified for our purposes\n#' @importFrom stats glm Gamma\nparametricDispersionFit <- function( disp_table, initial_coefs=c(1e-6, 1) )\n{\n  coefs <- initial_coefs\n  iter <- 0\n  while(TRUE) {\n    residuals <- disp_table$disp / ( coefs[1] + coefs[2] / disp_table$mu )\n    good <- disp_table[which( (residuals > initial_coefs[1]) & (residuals < 10000) ),]\n    #good <- disp_table\n    fit <- glm( disp ~ I(1/mu), data=good,\n                family=Gamma(link=\"identity\"), start=coefs )\n    oldcoefs <- coefs\n    coefs <- coefficients(fit)\n    if (coefs[1] < initial_coefs[1]){\n      coefs[1] <- initial_coefs[1]\n    }\n    if (coefs[2] < 0){\n      stop( \"Parametric dispersion fit failed. Try a local fit and/or a pooled estimation. (See '?estimateDispersions')\" )\n    }\n    #     if( !all( coefs > 0 ) ){\n    #       #print(data.frame(means,disps))\n    #       stop( \"Parametric dispersion fit failed. Try a local fit and/or a pooled estimation. (See '?estimateDispersions')\" )\n    #     }\n    if( sum( log( coefs / oldcoefs )^2 ) < initial_coefs[1] )\n      break\n    iter <- iter + 1\n    #print(coefs)\n    if( iter > 10 ) {\n      warning( \"Dispersion fit did not converge.\" )\n      break \n    }\n  }\n  \n  if( !all( coefs > 0 ) ){\n    #print(data.frame(means,disps))\n    stop( \"Parametric dispersion fit failed. Try a local fit and/or a pooled estimation. (See '?estimateDispersions')\" )\n  }\n  \n  #names( coefs ) <- c( \"asymptDisp\", \"extraPois\" )\n  #ans <- function( q )\n  #  coefs[1] + coefs[2] / q\n  #ans\n  #coefs\n  list(fit, coefs)\n}\n\n# parametricDispersionFit <- function( means, disps )\n# {\n#   coefs <- c( 1e-6, 1 )\n#   iter <- 0\n#  \n#     residuals <- disps / ( coefs[1] + coefs[2] / means )\n#     good <- which( (residuals > 1e-4) & (residuals < 10000) )\n#     fit <- vglm( log(disps[good]) ~ log(means[good]), family=gaussianff())\n#     oldcoefs <- coefs\n#     coefs <- coefficients(fit)\n# \n#     iter <- iter + 1\n#     print(coefs)\n#   names( coefs ) <- c( \"asymptDisp\", \"extraPois\" )\n#   ans <- function( q )\n#     exp(coefs[1] + coefs[2] * log(q))\n#   #ans\n#   coefs\n# }\n\n\n#' Return a variance-stabilized matrix of expression values\n#'\n#' This function was taken from the DESeq package (Anders and Huber) and modified \n#' to suit Monocle's needs\n#'\n#' @param cds A CellDataSet to use for variance stabilization.\n#' @param dispModelName The name of the dispersion function to use for VST.\n#' @param expr_matrix An matrix of values to transform. Must be normalized (e.g. by size factors) already. This function doesn't do this for you.\n#' @param round_vals Whether to round expression values to the nearest integer before applying the transformation.\n#' @importFrom BiocGenerics sizeFactors \n#' @export\nvstExprs <- function(cds, dispModelName=\"blind\", expr_matrix=NULL, round_vals=TRUE ) {\n  fitInfo <- cds@dispFitInfo[[dispModelName]]\n  if (is.null(fitInfo)){\n    stop(paste(\"Error: No dispersion model named '\",dispModelName,\"'. You must call estimateSizeFactors(...,dispModelName='\",dispModelName,\n               \"') before calling this function.\", sep=\"\"))\n  }\n  \n  coefs <- attr( fitInfo$disp_func, \"coefficients\" )\n  if (is.null(expr_matrix)){\n    ncounts <- exprs(cds)\n    ncounts <- Matrix::t(Matrix::t(ncounts) / sizeFactors(cds))\n    if (round_vals)\n      ncounts <- round(ncounts)\n  }else{\n    ncounts <- expr_matrix\n  }\n  vst <- function( q )\n    log( (1 + coefs[\"extraPois\"] + 2 * coefs[\"asymptDisp\"] * q +\n            2 * sqrt( coefs[\"asymptDisp\"] * q * ( 1 + coefs[\"extraPois\"] + coefs[\"asymptDisp\"] * q ) ) )\n         / ( 4 * coefs[\"asymptDisp\"] ) ) / log(2)\n  ## NOTE: this converts to a dense matrix\n  vst( ncounts )\n}\n\n\n#' @importFrom Biobase exprs pData fData\ndisp_calc_helper_NB <- function(cds, expressionFamily, min_cells_detected){\n  \n  rounded <- round(exprs(cds))\n  nzGenes <- Matrix::rowSums(rounded > cds@lowerDetectionLimit)\n  nzGenes <- names(nzGenes[nzGenes > min_cells_detected])\n  \n  x <- t(t(rounded[nzGenes,]) / pData(cds[nzGenes,])$Size_Factor)\n  \n  xim <- mean(1/ pData(cds[nzGenes,])$Size_Factor)\n\n  if (isSparseMatrix(exprs(cds))){\n    f_expression_mean <- as(Matrix::rowMeans(x), \"sparseVector\")\n  }else{\n    f_expression_mean <- Matrix::rowMeans(x)\n  }\n  \n  \n    # For NB: Var(Y)=mu*(1+mu/k)\n  f_expression_var <- Matrix::rowMeans((x - f_expression_mean)^2)\n\n  disp_guess_meth_moments <- f_expression_var - xim * f_expression_mean\n    \n  disp_guess_meth_moments <- disp_guess_meth_moments / (f_expression_mean^2) #fix the calculation of k\n  \n\n  res <- data.frame(mu=as.vector(f_expression_mean), disp=as.vector(disp_guess_meth_moments))\n  res[res$mu == 0]$mu = NA\n  res[res$mu == 0]$disp = NA  \n  res$disp[res$disp < 0] <- 0\n\n  res <- cbind(gene_id=row.names(fData(cds[nzGenes,])), res)\n  res\n}\n\n#' Helper function to estimate dispersions\n#' @importFrom Biobase pData\n#' @importFrom stats cooks.distance\n#' @importFrom stringr str_split str_trim\n#' @param cds a CellDataSet that contains all cells user wants evaluated\n#' @param modelFormulaStr a formula string specifying the model to fit for the genes.\n#' @param relative_expr Whether to transform expression into relative values\n#' @param min_cells_detected Only include genes detected above lowerDetectionLimit in at least this many cells in the dispersion calculation\n#' @param removeOutliers a boolean it determines whether or not outliers from the data should be removed\n#' @param cores the number of cores to be used while testing each gene for differential expression.\nestimateDispersionsForCellDataSet <- function(cds, modelFormulaStr, relative_expr, min_cells_detected, removeOutliers, cores)\n{\n  \n  # if (cores > 1){\n  #     disp_table<-mcesApply(cds, 1, disp_calc_helper, c(\"BiocGenerics\", \"Biobase\", \"VGAM\", \"dplyr\", \"Matrix\"), cores=cores, \n  #                         modelFormulaStr=modelFormulaStr, \n  #                         expressionFamily=cds@expressionFamily)\n  # }else{\n  #     disp_table<-smartEsApply(cds,1,disp_calc_helper, \n  #                              convert_to_dense=TRUE,\n  #                              modelFormulaStr=modelFormulaStr, \n  #                              expressionFamily=cds@expressionFamily)\n  # }\n  mu <- NA\n  model_terms <- unlist(lapply(str_split(modelFormulaStr, \"~|\\\\+|\\\\*\"), str_trim))\n  model_terms <- model_terms[model_terms != \"\"]\n  progress_opts <- options()$dplyr.show_progress\n  options(dplyr.show_progress = T)\n  \n  # FIXME: this needs refactoring, badly.\n  if (cds@expressionFamily@vfamily %in% c(\"negbinomial\", \"negbinomial.size\")){\n    if (length(model_terms) > 1 || (length(model_terms) == 1 && model_terms[1] != \"1\")){\n      cds_pdata <- dplyr::group_by_(dplyr::select_(add_rownames(pData(cds)), \"rowname\", .dots=model_terms), .dots=model_terms) \n      disp_table <- as.data.frame(cds_pdata %>% do(disp_calc_helper_NB(cds[,.$rowname], cds@expressionFamily, min_cells_detected)))\n    }else{\n      cds_pdata <- dplyr::group_by_(dplyr::select_(add_rownames(pData(cds)), \"rowname\")) \n      disp_table <- as.data.frame(cds_pdata %>% do(disp_calc_helper_NB(cds[,.$rowname], cds@expressionFamily, min_cells_detected)))\n      #disp_table <- data.frame(rowname = names(type_res), CellType = type_res)\n    }\n    \n    #message(\"fitting disersion curves\")\n    #print (disp_table)\n    if(!is.list(disp_table))\n      stop(\"Parametric dispersion fitting failed, please set a different lowerDetectionLimit\")\n    #disp_table <- do.call(rbind.data.frame, disp_table)\n    disp_table <- subset(disp_table, is.na(mu) == FALSE)\n    res <- parametricDispersionFit(disp_table)\n    fit <- res[[1]]\n    coefs <- res[[2]]\n    #removeOutliers = TRUE\n    if (removeOutliers){\n      CD <- cooks.distance(fit)\n      #cooksCutoff <- qf(.99, 2, ncol(cds) - 2)\n      cooksCutoff <- 4/nrow(disp_table)\n      #print (head(CD[CD > cooksCutoff]))\n      #print (head(names(CD[CD > cooksCutoff])))\n      message (paste(\"Removing\", length(CD[CD > cooksCutoff]), \"outliers\"))\n      outliers <- union(names(CD[CD > cooksCutoff]), setdiff(row.names(disp_table), names(CD))) \n      res <- parametricDispersionFit(disp_table[row.names(disp_table) %in% outliers == FALSE,])\n      fit <- res[[1]]\n      coefs <- res[[2]]\n    }\n    names( coefs ) <- c( \"asymptDisp\", \"extraPois\" )\n    ans <- function( q )\n      coefs[1] + coefs[2] / q\n    attr( ans, \"coefficients\" ) <- coefs\n    \n  }\n  \n  res <- list(disp_table = disp_table, disp_func = ans)\n  return(res)\n}\n\n#' @importFrom stats var\ncalulate_NB_dispersion_hint <- function(disp_func, f_expression, expr_selection_func=mean)\n{\n  expr_hint <- expr_selection_func(f_expression)\n  if (expr_hint > 0 && is.null(expr_hint) == FALSE) {\n    disp_guess_fit <- disp_func(expr_hint)\n    \n    # For NB: Var(Y)=mu*(1+mu/k)\n    f_expression_var <- var(f_expression)\n    f_expression_mean <- mean(f_expression)\n    \n    disp_guess_meth_moments <- f_expression_var - f_expression_mean \n    disp_guess_meth_moments <- disp_guess_meth_moments / (f_expression_mean^2) #fix the calculation of k \n    \n    #return (max(disp_guess_fit, disp_guess_meth_moments))\n    return (disp_guess_fit)\n  }\n  return (NULL)\n}\n\n# note that quasipoisson expects a slightly different format for the \n# dispersion parameter, hence the differences in return value between\n# this function and calulate_NB_dispersion_hint\n#' @importFrom stats var\ncalulate_QP_dispersion_hint <- function(disp_func, f_expression, expr_selection_func=mean)\n{\n  expr_hint <- expr_selection_func(f_expression)\n  if (expr_hint > 0 && is.null(expr_hint) == FALSE) {\n    disp_guess_fit <- disp_func(expr_hint)\n    \n    # For NB: Var(Y)=mu*(1+mu/k)\n    f_expression_var <- var(f_expression)\n    f_expression_mean <- mean(f_expression)\n    \n    disp_guess_meth_moments <- f_expression_var - f_expression_mean \n    disp_guess_meth_moments <- disp_guess_meth_moments / (f_expression_mean^2) #fix the calculation of k \n    \n    return (1 + f_expression_mean * max(disp_guess_fit, disp_guess_meth_moments))\n  }\n  return (NULL)\n}\n",
    "created" : 1489687011204.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "226210469",
    "id" : "E1ADC561",
    "lastKnownWriteTime" : 1489641475,
    "last_content_update" : 1489641475,
    "path" : "~/Dropbox (Personal)/Projects/monocle-dev/R/expr_models.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}