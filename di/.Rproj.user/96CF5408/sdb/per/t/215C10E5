{
    "collab_server" : "",
    "contents" : "#' RDI and the spearman correlation of expression\n#'\n#' This function estimates the RDI and the spearman correlation of expression (expr1, expr2) for two genes,\n#' id1, di2 along the pseudo-time-series\n#' @param id1 ensemble id for gene 1\n#' @param id2 ensemble id for gene 2\n#' @param expr1 number for nearest neighbors used in entropy calculation\n#' @param expr2 number for nearest neighbors used in entropy calculation\n#' @param delays number for nearest neighbors used in entropy calculation\n#' @param N_operations number for nearest neighbors used in entropy calculation\n#' @return a vector of entropy values\n#' @export\ncalculate_rdi_corr <- function(id1, id2, expr1, expr2, delays, N_operations, verbose = F) {\n\tdmi <- c()\n\n\tfor(d in 1:length(delays)){\n\t\tif(class(expr1) != 'list') dmi[d] <- rdi_single_run(expr1, expr2, d = delays[d])\n\t\telse{ #multiple branches\n\t\t\texpr1_t <- c(); expr2_t <- c(); expr2_past <- c()\n\t\t\tfor(run_id in 1:nrow(expr1)){\n                expr1_t <- cbind(expr1_t, expr1[run_id, 1:(ncol(expr1)-d)])\n                expr2_t <- cbind(expr2_t, expr2[run_id, -c(1:d)])\n                expr2_past <- cbind(expr2_past, expr2[run_id, d:(ncol(expr2) - 1)])\n\t\t\t}\n\t\t\tdmi[d] <- cmi(expr1_t, expr2_t, expr2_past)\n\t\t}\n\t}\n\n\tif(class(expr1) != 'list') correlation <- cor(matrix(expr1, ncol = 1), matrix(expr2, ncol = 1), method = 'spearman')\n\telse{\n        expr1_concatenated <- c(); expr2_concatenated <- c()\n        for(run_id in 1:nrow(expr1)) {\n            expr1_concatenated <- cbind(expr1_concatenated, expr1[run_id, ])\n            expr2_concatenated <- cbind(expr2_concatenated, expr2[run_id, ])\n        }\n        correlation = cor(matrix(expr1_concatenated, ncol = 1), matrix(expr2_concatenated, ncol = 1), method = 'spearman')\n\t}\n\n\tif(verbose)\n\t  print(c(paste(id1, id2, sep = '\\t'), dmi, correlation))\n\n\tres <- as.data.frame(t(c(id1, id2, dmi, correlation)), stringsAsFactors = F)\n\trow.names(res) = paste(id1, id2, sep = '_')\n\tcolnames(res) <- c('id_1', 'id_2', paste('delays ', delays, sep = ''), 'spearman_cor')\n\tres[-c(1:2)] <- as.numeric(res[-c(1:2)])\n\treturn(res)\n}\n\n#' Calculate all pairwise RDI and spearman rank correlation\n#'\n#' This function estimates the RDI and the spearman correlation of expression (expr1, expr2) for any two genes, id1, di2 in the pseudo-time-series data\n#' @param genes_data pseudo-time/time series for the gene expression data\n#' @param delays a vector of delays to scanning the data\n#' @param supergraph a dataframe storing the list of possible edges\n#' @param cores number of cores used for performing the calculation\n#' @param verbose a logic argument to determine whether or not the details of calculation should be reported\n#' @return a dataframe storing the RDI results. The first two columns correspond to the ensemble id while the last column corresponds to the spearman\n#' rank correlation. The rest columns corresponds to the RDI values under different delays\n#' @export\ncalculate_and_write_pairwise_dmi <- function(genes_data, delays = c(1,2,5,10,15,20,25), supergraph = NULL, cores = 1, verbose = F){\n\tif(verbose) print(\"Calculating the Directed Mutual Information for each pair of genes...\")\n\n\tcnt <- 0\n\tN_operations <- nrow(genes_data) * (nrow(genes_data) - 1)\n\n\tpairwise_dmi_results <- c()\n\tpairwise_corr_results <- c()\n\n\ttmp <- expand.grid(colnames(genes_data), colnames(genes_data), stringsAsFactors = F)\n\tall_pairwise_gene <- tmp[as.character(tmp[, 1]) != as.character(tmp[, 2]), ] #don't calculate RDI on self-loop\n\n    if(!is.null(supergraph)) { #consider the supergraph\n        all_pairwise_gene_paste <- paste(all_pairwise_gene[, 1], all_pairwise_gene[, 2])\n        supergraph_paste <- paste(supergraph[, 1], supergraph[, 2])\n        all_pairwise_gene <- all_pairwise_gene[all_pairwise_gene_paste %in% supergraph_paste, ]\n    }\n\n\tall_pairwise_gene_list <- split(all_pairwise_gene, row.names(all_pairwise_gene))\n\n\t#we may need to convert genes_data into sparseMatrix before passing to mclapply\n\tres <- mclapply(all_pairwise_gene_list, function(x, genes_data, delays, N_operations) {\n\t\tcalculate_rdi_corr(x[[1]], x[[2]], genes_data[, x[[1]]], genes_data[, x[[2]]], delays, N_operations)\n\t\t}, genes_data = genes_data, delays = delays, N_operations = N_operations, mc.cores = cores)\n\n\tres <- do.call(rbind.data.frame, res)\n\trow.names(res) <- paste(res$id_1, res$id_2, sep = '_')\n\treturn(res)\n}\n\n#' Calculate conditionally RDI value\n#'\n#' This function estimates the RDI value for gene-pair combination (id1, id2) in the pseudotime/time series data, conditioned on the top K incoming edges.\n#' Delay for the gene-pair under test corresponds to the delay with highest RDI value while delay for the conditioned k\n#' incoming edges are based on their corresponding delay value.\n#' @param id1 ensemble id for gene 1\n#' @param id2 ensemble id for gene 2\n#' @param genes_data pseudo-time/time series for the gene expression data\n#' @param d delay for current gene interaction under test corresponding to the largest RDI value\n#' @param top_k_genes_delay a vector of top k incoming node's delay corresponding to the maximal RDI value\n#' @param N_operations number of total edges for calculating RDI values (not used for now)\n#' @return a dataframe storing conditional RDI results. First two columns are the id names for the genes.\n#' Third column is the conditional RDI value.\n#' @export\ncalculate_conditioned_rdi <- function(id1, id2, genes_data, d, top_k_genes_delay, N_operations, verbose = F){\n\tif(class(genes_data) != 'list'){\n\t  top_k_genes_data <- data.frame()\n\t\tfor(id in names(top_k_genes_delay)) {\n\t\t\ttop_k_genes_data <- rbind(top_k_genes_data, id =  genes_data[, id])\n\t\t}\n\t\tconditioned_rdi <- rdi_single_run_conditioned(genes_data[, id1], genes_data[, id2], d = d, z = matrix(as.matrix(top_k_genes_data), nrow = nrow(genes_data)), z_delays = top_k_genes_delay\n\t\t                                                )\n\t}\n\telse{\n        expr1_t = c(); expr2_t = c(); past = c()\n        for(run_id in 1:length(genes_data)) {\n            tau <- max(c(top_k_genes_delay, d))\n            tot_len <- nrow(genes_data[run_id]) - tau\n            expr1_t <- genes_data[run_id][id1, (tau - d + 1):(tau - d + tot_len)]\n            expr2_t <- genes_data[run_id][id2, (tau + 1):(tau+tot_len)]\n            past_tmp <- genes_data[run_id][id2, (tau):(tau-1+tot_len)]\n\n            for(id in top_k_genes_delay){\n                past_tmp <- cbind(past_tmp, genes_data[run_id][id, (tau - top_k_genes_delay[id] + 1):(tau - top_k_genes_delay[id]+tot_len)])\n            }\n            past <- cbind(past, past_tmp)\n        }\n\n        conditioned_rdi <- cmi(matrix(expr1_t, nrow = 1), matrix(expr2_t, nrow = 1), matrix(past, nrow = 1))\n\t}\n\n  if(verbose == T)\n\t  print(c(paste(id, id2, sep = '\\t'), conditioned_rdi))\n\n\tres <- as.data.frame(t(c(id1, id2, conditioned_rdi)))\n\trow.names(res) = paste(id1, id2, sep = '_')\n\tcolnames(res) <- c('id_1', 'id_2', 'conditioned_rdi')\n\treturn(res)\n}\n\n#' Calculate all pairwise conditional RDI values\n#'\n#' This function estimates the RDI value for every gene-pair combination conditioned on the top K incoming edges.\n#' Delay for the gene-pair under test corresponds to the delay with highest RDI value while delay for the conditioned K\n#' incoming edges are based on their corresponding delay value.\n#' @param genes_data expression matrix for all the genes included in the RDI calculation\n#' @param rdi_res calculated RDI results, including ids under test, RDI values under different delays and spearman rank corelation\n#' @param k number of top k-incoming nodes for calculating RDI values. Default is 1. Higher k requres to have more samples or longer time / \"pseudotime\" series\n#' @param supergraph a data frame stores the list of feasible edges for RDI analysis. Possible edges outside of this graph will be ignored\n#' @param cores number of cores used in the calculation\n#' @param verbose a logical argument to determine wheter or not to print the detailed running information.\n#' @return a dataframe storing conditional RDI results. First two columns are the id names for the genes.\n#' Third column is the conditional RDI value and last column is the time delay corresponding to the largest RDI.\n#' @export\ncalculate_and_write_pairwise_dmi_conditioned <- function(genes_data, rdi_res, k = 1, supergraph = NULL, cores = 1, verbose = F){\n\tk <- min(k, nrow(genes_data) - 2) # not conditioned on itself and the already included incoming node(s)\n\n    # delay for each gene pair gives max RDI value:\n    rdi_res$max_rdi <- apply(rdi_res[, 3:(ncol(rdi_res) - 1)], 1, max)\n    max_rdi <- apply(rdi_res[, 3:(ncol(rdi_res) - 2)], 1, which.max)\n    delays_max <- as.numeric(do.call(rbind.data.frame, strsplit(colnames(rdi_res)[3:(ncol(rdi_res) - 2)], ' '))[[2]])[max_rdi]\n    rdi_res$max_val_delay <- delays_max\n    names(delays_max) <- row.names(rdi_res)\n\n    # find the top k incoming genes with highest RDI values:\n    target_gene_list <- unique(rdi_res[, 'id_2'])\n    top_k_plus_1_incoming_id_list <- lapply(target_gene_list, function(x) {\n        rdi_res_subset <- rdi_res[rdi_res$id_2 == x, ]\n        nodes <- rdi_res_subset[order(rdi_res_subset$max_rdi, decreasing = T)[1:(k + 1)], 'id_1'] #incoming edge\n        delay <- rdi_res_subset[order(rdi_res_subset$max_rdi, decreasing = T)[1:(k + 1)], 'max_val_delay'] #incoming edge\n        names(delay) <- nodes\n        return(delay)\n        })\n\n    names(top_k_plus_1_incoming_id_list) <- target_gene_list\n\n    tmp <- expand.grid(colnames(genes_data), colnames(genes_data), stringsAsFactors = F)\n    all_pairwise_gene <- tmp[as.character(tmp[, 1]) != as.character(tmp[, 2]), ] #don't calculate RDI on self-loop\n\n    if(!is.null(supergraph)) { #consider the supergraph\n        all_pairwise_gene_paste <- paste(all_pairwise_gene[, 1], all_pairwise_gene[, 2])\n        supergraph_paste <- paste(supergraph[, 1], supergraph[, 2])\n        all_pairwise_gene <- all_pairwise_gene[all_pairwise_gene_paste %in% supergraph_paste, ]\n    }\n\n    all_pairwise_gene_list <- split(all_pairwise_gene, row.names(all_pairwise_gene))\n\n    # print(top_k_plus_1_incoming_id_list)\n\n        #we may need to convert genes_data into sparseMatrix before passing to mclapply\n\tres <- mclapply(all_pairwise_gene_list, function(gene_pair, genes_data, delays, N_operations) {\n        index_name <- paste(gene_pair[1], gene_pair[2], sep = '_')\n        # if(index_name == \"ENSMUSG00000020044.7_ENSMUSG00000013089.9\"){\n        #   browser()\n        # }\n        # if(index_name == 'ENSMUSG00000015452.8_ENSMUSG00000020044.7') browser()\n\n    top_k_plus_1 <- top_k_plus_1_incoming_id_list[[gene_pair[[2]]]] #avoid taking the incoming node for current test as the conditional incoming node\n    valid_top_k <- top_k_plus_1[!(names(top_k_plus_1) %in% gene_pair[[1]])][1:(length(top_k_plus_1) - 1)]\n\n\t\tcalculate_conditioned_rdi(gene_pair[[1]], gene_pair[[2]], genes_data, delays_max[index_name], valid_top_k, N_operations)\n\t\t}, genes_data = genes_data, mc.cores = cores)\n\n    res <- do.call(rbind.data.frame, res)\n    row.names(res) <- paste(res$id_1, res$id_2, sep = '_')\n    res$delay_max <- delays_max[row.names(res)]\n\n    return(res)\n}\n\n#' This function smoothes the data using moving average\n#'\n#' @param exprs a dataframe or matrix to be smoothed, row corresponds variables while column correspond to sample\n#' @param window_size size of sliding window\n#' @return moving average smoothed dataset\n#' @export\nsmooth_genes <- function(exprs, window_size = 40) {\n  win_range <- nrow(exprs) - window_size\n  exprs_smooth <- exprs[-c(1:window_size), ]\n\n  res <- apply(exprs, 2, function(x) {\n    tmp <- rep(0, win_range)\n    for(i in 0:(win_range)){\n      tmp[i + 1] <- mean(x[i + c(1:window_size)])\n    }\n    return(tmp)\n  })\n\n  return(res)\n}\n\n",
    "created" : 1489087294730.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1169563913",
    "id" : "215C10E5",
    "lastKnownWriteTime" : 1489539950,
    "last_content_update" : 1489539950513,
    "path" : "~/Dropbox (Personal)/Projects/Genes_Inference_in_Cell_Differentiation_Process/R_package/di/R/accessary_code.R",
    "project_path" : "R/accessary_code.R",
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}