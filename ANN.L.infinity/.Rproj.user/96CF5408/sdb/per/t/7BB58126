{
    "collab_server" : "",
    "contents" : "# ===============================\n# NEAR NEIGHBOUR FINDER\n# ===============================\n\n\n\n#'Nearest Neighbour Search\n#'\n#'Uses a kd-tree to find the p number of near neighbours for each point in an\n#'input/output dataset. The advantage of the kd-tree is that it runs in O(M log\n#'M) time.\n#'\n#'The \\code{RANN.L1} package utilizes the Approximate Near Neighbor (ANN) C++\n#'library, which can give the exact near neighbours or (as the name suggests)\n#'approximate near neighbours to within a specified error bound.  For more\n#'information on the ANN library please visit\n#'\\url{http://www.cs.umd.edu/~mount/ANN/}.\n#'\n#'Search types: \\code{priority} visits cells in increasing order of distance\n#'from the query point, and hence, should converge more rapidly on the true\n#'nearest neighbour, but standard is usually faster for exact searches.\n#'\\code{radius} only searches for neighbours within a specified radius of the\n#'point.  If there are no neighbours then nn.idx will contain 0 and nn.dists\n#'will contain 1.340781e+154 for that point.\n#'\n#'@param data An \\bold{M} x \\bold{d} data.frame or matrix, where each of the\n#'  \\bold{M} rows is a point or a (column) vector (where \\bold{d=1}).\n#'@param query A set of \\bold{N} x \\bold{d} points that will be queried against\n#'  \\code{data}. \\bold{d}, the number of columns, must be the same as\n#'  \\code{data}. If missing, defaults to \\code{data}.\n#'@param k The maximum number of nearest neighbours to compute. The default\n#'  value is set to the smaller of the number of columsn in data\n#'@param treetype Character vector specifying the standard \\code{'kd'} tree or a\n#'  \\code{'bd'} (box-decomposition, AMNSW98) tree which may perform better for\n#'  larger point sets\n#'@param searchtype See details\n#'@param radius Radius of search for searchtype='radius'\n#'@param eps Error bound: default of 0.0 implies exact nearest neighbour search\n#'@return A \\code{list} of length 2 with elements:\n#'\n#'  \\item{nn.idx}{A \\bold{N} x \\bold{k} integer \\code{matrix} returning the near\n#'  neighbour indices.}\n#'\n#'  \\item{nn.dists}{A \\bold{N} x \\bold{k} \\code{matrix} returning the near\n#'  neighbour Manhattan distances.}\n#'@author Gregory Jefferis based on earlier code by Samuel E. Kemp (knnFinder\n#'  package)\n#'@references Bentley J. L. (1975), Multidimensional binary search trees used\n#'  for associative search. Communication ACM, 18:309-517.\n#'\n#'  Arya S. and Mount D. M. (1993), Approximate nearest neighbor searching,\n#'  Proc. 4th Ann. ACM-SIAM Symposium on Discrete Algorithms (SODA'93), 271-280.\n#'\n#'  Arya S., Mount D. M., Netanyahu N. S., Silverman R. and Wu A. Y (1998), An\n#'  optimal algorithm for approximate nearest neighbor searching, Journal of the\n#'  ACM, 45, 891-923.\n#'@keywords nonparametric\n#'@examples\n#'\n#'x1 <- runif(100, 0, 2*pi)\n#'x2 <- runif(100, 0,3)\n#'DATA <- data.frame(x1, x2)\n#'nearest <- nn2(DATA,DATA)\n#'@export\nnn2 <- function(data, query=data, k=min(10,nrow(data)),treetype=c(\"kd\",\"bd\"),\n                searchtype=c(\"standard\",\"priority\",\"radius\"),radius=0.0,eps=0.0)\n{\n  dimension\t<- ncol(data)\n  if(is.null(dimension)) dimension=1L\n  query_dimension  <- ncol(query)\n  if(is.null(query_dimension)) query_dimension=1L\n\n  ND\t\t    <- nrow(data)\n  if(is.null(ND)) ND=length(data)\n  NQ\t\t    <- nrow(query)\n  if(is.null(NQ)) NQ=length(data)\n\n  # Check that both datasets have same dimensionality\n  if(query_dimension != query_dimension)\n    stop(\"Query and data tables must have same dimensions\")\n\n  if(k>ND)\n    stop(\"Cannot find more nearest neighbours than there are points\")\n\n  searchtypeInt=pmatch(searchtype[1],c(\"standard\",\"priority\",\"radius\"))\n  if(is.na(searchtypeInt)) stop(paste(\"Unknown search type\",searchtype))\n  treetype=match.arg(treetype,c(\"kd\",\"bd\"))\n\n  # Coerce to matrix form\n  if(is.data.frame(data))\n    data <- unlist(data,use.names=FALSE)\n\n  if(!length(data)) stop(\"no points in data!\")\n\n  # Coerce to matrix form\n  if(!is.matrix(query))\n    query <- unlist(query,use.names=FALSE)\n\n  if(!length(query)) stop(\"no points in query!\")\n\n  # void get_NN_2Set(double *data, double *query, int *D, int *ND, int *NQ, int *K, double *EPS,\n  # int *nn_index, double *distances)\n\n  results <- .C(\"get_NN_2Set\",\n                as.double(data),\n                as.double(query),\n                as.integer(dimension),\n                as.integer(ND),\n                as.integer(NQ),\n                as.integer(k),\n                as.double(eps),\n                as.integer(searchtypeInt),\n                as.integer(treetype==\"bd\"),\n                as.double(radius*radius),\n                nn.idx   = integer(k*NQ),\n                nn       = double(k*NQ), PACKAGE=\"ANN.L.infinity\")\n\n  # now put the returned vectors into (nq x k) arrays\n  nn.indexes=matrix(results$nn.idx,ncol=k,byrow=TRUE)\n  nn.dist=matrix(results$nn,ncol=k,byrow=TRUE)\n\n  return(list(nn.idx=nn.indexes, nn.dists=nn.dist))\n}\n",
    "created" : 1488848529787.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1331484951",
    "id" : "7BB58126",
    "lastKnownWriteTime" : 1488852871,
    "last_content_update" : 1488852871007,
    "path" : "~/Dropbox (Personal)/Projects/Genes_Inference_in_Cell_Differentiation_Process/R_package/ANN.L.infinity/R/nn.R",
    "project_path" : "R/nn.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}