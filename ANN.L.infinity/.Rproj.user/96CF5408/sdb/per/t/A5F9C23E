{
    "collab_server" : "",
    "contents" : "#include <math.h>    // math routines\n#include \"ANN.h\"     // ANN library header\n#include <R.h>       // R header\n\n//------------------------------------------------------------------------------------------------\n//\t\t\t\t Near Neighbours Program\n//------------------------------------------------------------------------------------------------\nextern \"C\"\n{\n\tvoid get_NN_2Set(double *data, double *query, int *D, int *ND, int *NQ, int *K, double *EPS,\n\t\tint *SEARCHTYPE, int *USEBDTREE, double *SQRAD, int *nn_index, double *distances)\n\t{\n\tconst int d = *D;\t\t// Number of Dimensions for points\n\tconst int nd = *ND;\t\t// Number of Data points\n\tconst int nq= *NQ;\t\t// Number of Query points\n\tconst int k = *K;\t\t// Maximum number of Nearest Neighbours\n\n\tconst int searchtype = *SEARCHTYPE;\n\tconst bool usebdtree = *USEBDTREE?true:false;\n\n\tconst double error_bound = *EPS;\t// enough said!\n\tconst double sqRad = *SQRAD;\t\t// Squared Radius for rad search\n\n\tANNkd_tree\t*the_tree;\t// Search structure\n\n\tANNpointArray data_pts \t= annAllocPts(nd,d);\t\t// Allocate data points\n\tANNidxArray nn_idx \t\t= new ANNidx[k];\t\t// Allocate near neigh indices\n\tANNdistArray dists \t\t= new ANNdist[k];\t\t// Allocate near neighbor dists\n\n\tint *d_ptr = new int[d];\n\tint ptr = 0;\n\n\t// set up column offsets for query point matrix (to convert Row/Col major)\n\tfor(int i = 0; i < d; i++)\n\t{\n\t\td_ptr[i] = i*nd;\n\t}\n\n\tfor(int i = 0; i < nd; i++) // now construct the points\n\t{\n\t\tfor(int j = 0; j < d; j++)\n\t\t{\n\t\t\tdata_pts[i][j]=data[ d_ptr[j]++ ];\n\t\t}\n\t}\n\n\tif(usebdtree){\n\t\tthe_tree = new ANNbd_tree(\t// Build search structure\n\t\t\t\tdata_pts,\t\t\t// The data points\n\t\t\t\tnd,\t\t\t\t\t// Number of data points\n\t\t\t\td);\t\t\t\t\t// Dimension of space\n\t} else {\n\t\tthe_tree = new ANNkd_tree( data_pts, nd, d);\n\t}\n\n\t// set up offsets for query point matrix (to convert Row / Col major)\n\tfor(int i = 0; i < d; i++)\n\t{\n\t\td_ptr[i] = i*nq;\n\t}\n\n\tANNpoint pq = annAllocPt(d);\n\tfor(int i = 0; i < nq; i++)\t// Run all query points against tree\n\t{\n\t\t// read coords of current query point\n\t\tfor(int j = 0; j < d; j++)\n\t\t{\n\t\t\tpq[j]=query[ d_ptr[j]++ ];\n\t\t}\n\n\t\tswitch(searchtype){\n\t\t\tcase 1:\n\t\t\tthe_tree->annkSearch(\t// search\n\t\t\t\tpq,\t// query point\n\t\t\t\tk,\t\t// number of near neighbors\n\t\t\t\tnn_idx,\t\t// nearest neighbors (returned)\n\t\t\t\tdists,\t\t// distance (returned)\n\t\t\t\terror_bound);\t// error bound\n\t\t\tbreak;\n\n\t\t\tcase 2:  // Priority search\n\t\t\tthe_tree->annkPriSearch(pq, k, nn_idx, dists, error_bound);\n\t\t\tbreak;\n\n\t\t\tcase 3: // Fixed radius search\n\t\t\tthe_tree->annkFRSearch(\tpq,\tsqRad, k, nn_idx, dists,error_bound);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tdistances[ptr] = ANN_ROOT(dists[j]);\t// unsquare distance\n\t\t\tnn_index[ptr++]  = nn_idx[j] + 1;\t// put indices in returned array\n\t\t}\n\t}\n\n\t// Do a little bit of memory management......\n\tannDeallocPt(pq);\n\tannDeallocPts(data_pts);\n\tdelete [] nn_idx;\n\tdelete [] dists;\n\tdelete [] d_ptr;\n\tdelete the_tree;\n\t}\n}\n",
    "created" : 1488853176379.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "797048117",
    "id" : "A5F9C23E",
    "lastKnownWriteTime" : 1488853215,
    "last_content_update" : 1488853215857,
    "path" : "~/Dropbox (Personal)/Projects/Genes_Inference_in_Cell_Differentiation_Process/R_package/ANN.L.infinity/src/NN.cc",
    "project_path" : "src/NN.cc",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}