{
    "collab_server" : "",
    "contents" : "//----------------------------------------------------------------------\n// File:\t\t\tann2fig.cpp\n// Programmer:\t\tDavid Mount\n// Last modified:\t05/03/05\n// Description:\t\tconvert ann dump file to fig file\n//----------------------------------------------------------------------\n// Copyright (c) 1997-2005 University of Maryland and Sunil Arya and\n// David Mount.  All Rights Reserved.\n//\n// This software and related documentation is part of the Approximate\n// Nearest Neighbor Library (ANN).  This software is provided under\n// the provisions of the Lesser GNU Public License (LGPL).  See the\n// file ../ReadMe.txt for further information.\n//\n// The University of Maryland (U.M.) and the authors make no\n// representations about the suitability or fitness of this software for\n// any purpose.  It is provided \"as is\" without express or implied\n// warranty.\n//----------------------------------------------------------------------\n// History:\n//\tRevision 0.1  03/04/98\n//\t\tInitial release\n//\tRevision 1.0  04/01/05\n//\t\tChanged dump file suffix from .ann to .dmp.\n//\tRevision 1.1  05/03/05\n//\t\tFixed usage output string.\n//----------------------------------------------------------------------\n//\tThis program inputs an ann dump file of a search structure\n//\tperhaps along with point coordinates, and outputs a fig (Ver 3.1)\n//\tfile (see fig2dev (1)) displaying the tree.  The fig file may\n//\tthen be displayed using xfig, or converted to any of a number of\n//\tother formats using fig2dev.\n//\n//\tIf the dimension is 2 then the entire tree is display.  If the\n//\tdimension is larger than 2 then the user has the option of\n//\tselecting which two dimensions will be displayed, and the slice\n//\tvalue for each of the remaining dimensions.  All leaf cells\n//\tintersecting the slice are shown along with the points in these\n//\tcells. See the procedure getArgs() below for the command-line\n//\targuments.\n//----------------------------------------------------------------------\n\n#include <cstdio>\t\t\t\t\t\t// C standard I/O\n#include <cstdlib>\t\t\t\t\t\t// standard lib defs\n#include <cstring>\t\t\t\t\t\t// C strings\n#include <fstream>\t\t\t\t\t\t// file I/O\n#include <string>\t\t\t\t\t\t// string manipulation\n#include <ANN/ANNx.h>\t\t\t\t\t// all ANN includes\n\nusing namespace std;\t\t\t\t\t// make std:: accessible\n\n//----------------------------------------------------------------------\n// Globals and their defaults\n//----------------------------------------------------------------------\n\nconst int\t\tSTRING_LEN\t\t= 500;\t// string lengths\nconst int\t\tMAX_DIM\t\t\t= 1000; // maximum dimension\nconst double\tDEF_SLICE_VAL\t= 0;\t// default slice value\nconst char\t\tFIG_HEAD[]\t\t= {\"#FIG 3.1\"}; // fig file header\nconst char\t\tDUMP_SUFFIX[]\t= {\".dmp\"};\t// suffix for dump file\nconst char\t\tFIG_SUFFIX[]\t= {\".fig\"};\t// suffix for fig file\n\nchar\t\t\tfile_name[STRING_LEN];\t// (root) file name (say xxx)\nchar\t\t\tinfile_name[STRING_LEN];// input file name (xxx.dmp)\nchar\t\t\toutfile_name[STRING_LEN];// output file name (xxx.fig)\nchar\t\t\tcaption[STRING_LEN];\t// caption line (= command line)\nofstream\t\tofile;\t\t\t\t\t// output file stream\nifstream\t\tifile;\t\t\t\t\t// input file stream\nint\t\t\t\tdim_x = 0;\t\t\t\t// horizontal dimension\nint\t\t\t\tdim_y = 1;\t\t\t\t// vertical dimension\ndouble\t\t\tslice_val[MAX_DIM];\t\t// array of slice values\ndouble\t\t\tu_per_in = 1200;\t\t// fig units per inch (version 3.1)\ndouble\t\t\tin_size = 5;\t\t\t// size of figure (in inches)\ndouble\t\t\tin_low_x = 1;\t\t\t// fig upper left corner (in inches)\ndouble\t\t\tin_low_y = 1;\t\t\t// fig upper left corner (in inches)\ndouble\t\t\tu_size = 6000;\t\t\t// size of figure (in units)\ndouble\t\t\tu_low_x = 1200;\t\t\t// fig upper left corner (in units)\ndouble\t\t\tu_low_y = 1200;\t\t\t// fig upper left corner (in units)\nint\t\t\t\tpt_size = 10;\t\t\t// point size (in fig units)\n\nint\t\t\t\tdim;\t\t\t\t\t// dimension\nint\t\t\t\tn_pts;\t\t\t\t\t// number of points\nANNpointArray\tpts = NULL;\t\t\t\t// point array\n\ndouble\t\t\tscale;\t\t\t\t\t// scale factor for transformation\ndouble\t\t\toffset_x;\t\t\t\t// offsets for transformation\ndouble\t\t\toffset_y;\n\n\t\t\t\t\t\t\t\t\t\t// transformations\n#define TRANS_X(p)\t\t(offset_x + scale*(p[dim_x]))\n#define TRANS_Y(p)\t\t(offset_y - scale*(p[dim_y]))\n\n//----------------------------------------------------------------------\n//\tError handler\n//----------------------------------------------------------------------\n\nvoid Error(const char* msg, ANNerr level)\n{\n\tif (level == ANNabort) {\n\t\tcerr << \"ann2fig: ERROR------->\" << msg << \"<-------------ERROR\\n\";\n\t\texit(1);\n\t}\n\telse {\n\t\tcerr << \"ann2fig: WARNING----->\" << msg << \"<-------------WARNING\\n\";\n\t}\n}\n\n//----------------------------------------------------------------------\n// set_slice_val - set all slice values to given value\n//----------------------------------------------------------------------\n\nvoid set_slice_val(double val)\n{\n\tfor (int i = 0; i < MAX_DIM; i++) {\n\t\tslice_val[i] = val;\n\t}\n}\n\n//----------------------------------------------------------------------\n// getArgs - get input arguments\n//\n//\t\tSyntax:\n//\t\tann2fig [-upi scale] [-x low_x] [-y low_y]\n//\t\t\t\t[-sz size] [-dx dim_x] [-dy dim_y] [-sl dim value]*\n//\t\t\t\t[-ps pointsize]\n//\t\t\t\tfile\n//\n//\t\twhere:\n//\t\t\t-upi scale\t\t\tfig units per inch (default = 1200)\n//\t\t\t-x low_x\t\t\tx and y offset of upper left corner (inches)\n//\t\t\t-y low_y\t\t\t...(default = 1)\n//\t\t\t-sz size\t\t\tmaximum side length of figure (in inches)\n//\t\t\t\t\t\t\t\t...(default = 5)\n//\t\t\t-dx dim_x\t\t\thorizontal dimension (default = 0)\n//\t\t\t-dy dim_y\t\t\tvertical dimension (default = 1)\n//\t\t\t-sv value\t\t\tdefault slice value (default = 0)\n//\t\t\t-sl dim value\t\teach such pair defines the value along the\n//\t\t\t\t\t\t\t\t...given dimension at which to slice.  This\n//\t\t\t\t\t\t\t\t...may be supplied for all dimensions except\n//\t\t\t\t\t\t\t\t...dim_x and dim_y.\n//\t\t\t-ps pointsize\t\tsize of points in fig units (def = 10)\n//\t\t\tfile\t\t\t\tfile (input=file.dmp, output=file.fig)\n//\n//----------------------------------------------------------------------\n\nvoid getArgs(int argc, char **argv)\n{\n\tint i;\n\tint sl_dim;\t\t\t\t\t\t\t\t\t// temp slice dimension\n\tdouble sl_val;\t\t\t\t\t\t\t\t// temp slice value\n\n\tset_slice_val(DEF_SLICE_VAL);\t\t\t\t// set initial slice-values\n\n\tif (argc <= 1) {\n\t\tcerr << \"Syntax:\\n\\\n        ann2fig [-upi scale] [-x low_x] [-y low_y]\\n\\\n                [-sz size] [-dx dim_x] [-dy dim_y] [-sl dim value]*\\n\\\n                file\\n\\\n        \\n\\\n        where:\\n\\\n            -upi scale          fig units per inch (default = 1200)\\n\\\n            -x low_x            x and y offset of upper left corner (inches)\\n\\\n            -y low_y            ...(default = 1)\\n\\\n            -sz size            maximum side length of figure (in inches)\\n\\\n                                ...(default = 5)\\n\\\n            -dx dim_x           horizontal dimension (default = 0)\\n\\\n            -dy dim_y           vertical dimension (default = 1)\\n\\\n            -sv value           default slice value (default = 0)\\n\\\n            -sl dim value       each such pair defines the value along the\\n\\\n                                ...given dimension at which to slice.  This\\n\\\n                                ...may be supplied for each dimension except\\n\\\n                                ...dim_x and dim_y.\\n\\\n            -ps pointsize       size of points in fig units (def = 10)\\n\\\n            file                file (input=file.dmp, output=file.fig)\\n\";\n\t\texit(0);\n\t}\n\n\tANNbool fileSeen = ANNfalse;\t\t\t\t// file argument seen?\n\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-upi\")) {\t\t\t// process -upi option\n\t\t\tsscanf(argv[++i], \"%lf\", &u_per_in);\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-x\")) {\t\t// process -x option\n\t\t\tsscanf(argv[++i], \"%lf\", &in_low_x);\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-y\")) {\t\t// process -y option\n\t\t\tsscanf(argv[++i], \"%lf\", &in_low_y);\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-sz\")) {\t\t// process -sz option\n\t\t\tsscanf(argv[++i], \"%lf\", &in_size);\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-dx\")) {\t\t// process -dx option\n\t\t\tsscanf(argv[++i], \"%d\", &dim_x);\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-dy\")) {\t\t// process -dy option\n\t\t\tsscanf(argv[++i], \"%d\", &dim_y);\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-sv\")) {\t\t// process -sv option\n\t\t\tsscanf(argv[++i], \"%lf\", &sl_val);\n\t\t\tset_slice_val(sl_val);\t\t\t\t// set slice values\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-sl\")) {\t\t// process -sl option\n\t\t\tsscanf(argv[++i], \"%d\", &sl_dim);\n\t\t\tif (sl_dim < 0 || sl_dim >= MAX_DIM) {\n\t\t\t\tError(\"Slice dimension out of bounds\", ANNabort);\n\t\t\t}\n\t\t\tsscanf(argv[++i], \"%lf\", &slice_val[sl_dim]);\n\t\t}\n\t\tif (!strcmp(argv[i], \"-ps\")) {\t\t\t// process -ps option\n\t\t\tsscanf(argv[++i], \"%i\", &pt_size);\n\t\t}\n\t\telse {\t\t\t\t\t\t\t\t\t// must be file name\n\t\t\tfileSeen = ANNtrue;\n\t\t\tsscanf(argv[i], \"%s\", file_name);\n\t\t\tstrcpy(infile_name, file_name);\t\t// copy to input file name\n\t    \tstrcat(infile_name, DUMP_SUFFIX);\n\t    \tstrcpy(outfile_name, file_name);\t// copy to output file name\n\t    \tstrcat(outfile_name, FIG_SUFFIX);\n\t\t}\n\t}\n\n\tif (!fileSeen) {\t\t\t\t\t\t\t// no file seen\n\t\tError(\"File argument is required\", ANNabort);\n\t}\n\n\tifile.open(infile_name, ios::in);\t\t\t// open for reading\n\tif (!ifile) {\n\t\tError(\"Cannot open input file\", ANNabort);\n\t}\n\tofile.open(outfile_name, ios::out);\t\t\t// open for writing\n\tif (!ofile) {\n\t\tError(\"Cannot open output file\", ANNabort);\n\t}\n\n\tu_low_x = u_per_in * in_low_x;\t\t\t\t// convert inches to fig units\n\tu_low_y = u_per_in * in_low_y;\n\tu_size  = u_per_in * in_size;\n\n\tstrcpy(caption, argv[0]);\t\t\t\t\t// copy command line to caption\n\tfor (i = 1; i < argc; i++) {\n\t\tstrcat(caption, \" \");\n\t\tstrcat(caption, argv[i]);\n\t}\n}\n\n//----------------------------------------------------------------------\n// Graphics utilities for fig output\n//\n//\t\twriteHeader\t\t\t\twrite header for fig file\n//\t\twritePoint\t\t\t\twrite a point\n//\t\twriteBox\t\t\t\twrite a box\n//\t\twriteLine\t\t\t\twrite a line\n//----------------------------------------------------------------------\n\nvoid writeHeader()\n{\n\tofile << FIG_HEAD << \"\\n\"\t\t\t\t\t// fig file header\n\t\t << \"Portrait\\n\"\n\t\t << \"Center\\n\"\n\t\t << \"Inches\\n\"\n\t\t << (int) u_per_in << \" 2\\n\";\n}\n\nvoid writePoint(ANNpoint p)\t\t\t\t\t\t// write a single point\n{\n\t\t\t\t\t\t\t\t\t\t\t\t// filled black point object\n\tofile << \"1 3 0 1 -1 7 0 0 0 0.000 1 0.0000 \";\n\tint cent_x = (int) TRANS_X(p);\t\t\t\t// transform center coords\n\tint cent_y = (int) TRANS_Y(p);\n\tofile << cent_x << \" \" << cent_y << \" \"\t\t// write center, radius, bounds\n\t\t << pt_size << \" \" << pt_size << \" \"\n\t\t << cent_x << \" \" << cent_y << \" \"\n\t\t << cent_x + pt_size << \" \" << cent_y + pt_size << \"\\n\";\n}\n\nvoid writeBox(const ANNorthRect &r)\t\t\t\t// write box\n{\n\t\t\t\t\t\t\t\t\t\t\t\t// unfilled box object\n\tofile << \"2 2 0 1 -1 7 0 0 -1 0.000 0 0 -1 0 0 5\\n\";\n\n\tint p0_x = (int) TRANS_X(r.lo);\t\t\t\t// transform endpoints\n\tint p0_y = (int) TRANS_Y(r.lo);\n\tint p1_x = (int) TRANS_X(r.hi);\n\tint p1_y = (int) TRANS_Y(r.hi);\n\tofile << \"\\t\"\n\t\t << p0_x << \" \" << p0_y << \" \"\t\t\t// write vertices\n\t\t << p1_x << \" \" << p0_y << \" \"\n\t\t << p1_x << \" \" << p1_y << \" \"\n\t\t << p0_x << \" \" << p1_y << \" \"\n\t\t << p0_x << \" \" << p0_y << \"\\n\";\n}\n\nvoid writeLine(ANNpoint p0, ANNpoint p1)\t\t// write line\n{\n\t\t\t\t\t\t\t\t\t\t\t\t// unfilled line object\n\tofile << \"2 1 0 1 -1 7 0 0 -1 0.000 0 0 -1 0 0 2\\n\";\n\n\tint p0_x = (int) TRANS_X(p0);\t\t\t\t// transform endpoints\n\tint p0_y = (int) TRANS_Y(p0);\n\tint p1_x = (int) TRANS_X(p1);\n\tint p1_y = (int) TRANS_Y(p1);\n\tofile << \"\\t\"\n\t\t << p0_x << \" \" << p0_y << \" \"\t\t\t// write vertices\n\t\t << p1_x << \" \" << p1_y << \"\\n\";\n}\n\nvoid writeCaption(\t\t\t\t\t\t\t\t// write caption text\n\tconst ANNorthRect\t&bnd_box,\t\t\t\t// bounding box\n\tchar\t\t\t\t*caption)\t\t\t\t// caption\n{\n\tif (!strcmp(caption, \"\\0\")) return;\t\t\t// null string?\n\tint px = (int) TRANS_X(bnd_box.lo);\t\t\t// put .5 in. lower left\n\tint py = (int) (TRANS_Y(bnd_box.lo) + 0.50 * u_per_in);\n\tofile << \"4 0 -1 0 0 0 20 0.0000 4 255 2000 \";\n\tofile << px << \" \" << py << \" \" << caption << \"\\\\001\\n\";\n}\n\n//----------------------------------------------------------------------\n// overlap - test whether a box overlap slicing region\n//\n//\t\tThe slicing region is a 2-dimensional plane in space\n//\t\twhich contains points (x1, x2, ..., xn) satisfying the\n//\t\tn-2 linear equalities:\n//\n//\t\t\t\t\t\txi == slice_val[i]\t\tfor i != dim_x, dim_y\n//\n//\t\tThis procedure returns true of the box defined by\n//\t\tcorner points box.lo and box.hi overlap this plane.\n//----------------------------------------------------------------------\n\nANNbool overlap(const ANNorthRect &box)\n{\n\tfor (int i = 0; i < dim; i++) {\n\t\tif (i != dim_x && i != dim_y &&\n\t\t   (box.lo[i] > slice_val[i] || box.hi[i] < slice_val[i]))\n\t\t\treturn ANNfalse;\n\t}\n\treturn ANNtrue;\n}\n\n//----------------------------------------------------------------------\n// readTree, recReadTree - inputs tree and outputs figure\n//\n//\t\treadTree procedure initializes things and then calls recReadTree\n//\t\twhich does all the work.\n//\n//\t\trecReadTree reads in a node of the tree, makes any recursive\n//\t\tcalls as needed to input the children of this node (if internal)\n//\t\tand maintains the bounding box.  Note that the bounding box\n//\t\tis modified within this procedure, but it is the responsibility\n//\t\tof the procedure that it be restored to its original value\n//\t\ton return.\n//\n//\t\tRecall that these are the formats.  The tree is given in\n//\t\tpreorder.\n//\n//\t\tLeaf node:\n//\t\t\t\tleaf <n_pts> <bkt[0]> <bkt[1]> ... <bkt[n-1]>\n//\t\tSplitting nodes:\n//\t\t\t\tsplit <cut_dim> <cut_val> <lo_bound> <hi_bound>\n//\t\tShrinking nodes:\n//\t\t\t\tshrink <n_bnds>\n//\t\t\t\t\t\t<cut_dim> <cut_val> <side>\n//\t\t\t\t\t\t<cut_dim> <cut_val> <side>\n//\t\t\t\t\t\t... (repeated n_bnds times)\n//\n//\t\tOn reading a leaf we determine whether we should output the\n//\t\tcell's points (if dimension = 2 or this cell overlaps the\n//\t\tslicing region).  For splitting nodes we check whether the\n//\t\tcurrent cell overlaps the slicing plane and whether the\n//\t\tcutting dimension coincides with either the x or y drawing\n//\t\tdimensions.  If so, we output the corresponding splitting\n//\t\tsegment.\n//----------------------------------------------------------------------\n\nvoid recReadTree(ANNorthRect &box)\n{\n\tchar tag[STRING_LEN];\t\t\t\t\t\t// tag (leaf, split, shrink)\n\tint n_pts;\t\t\t\t\t\t\t\t\t// number of points in leaf\n\tint idx;\t\t\t\t\t\t\t\t\t// point index\n\tint cd;\t\t\t\t\t\t\t\t\t\t// cut dimension\n\tANNcoord cv;\t\t\t\t\t\t\t\t// cut value\n\tANNcoord lb;\t\t\t\t\t\t\t\t// low bound\n\tANNcoord hb;\t\t\t\t\t\t\t\t// high bound\n\tint n_bnds;\t\t\t\t\t\t\t\t\t// number of bounding sides\n\tint sd;\t\t\t\t\t\t\t\t\t\t// which side\n\n\tifile >> tag;\t\t\t\t\t\t\t\t// input node tag\n\tif (strcmp(tag, \"leaf\") == 0) {\t\t\t\t// leaf node\n\n\t\tifile >> n_pts;\t\t\t\t\t\t\t// input number of points\n\t\t\t\t\t\t\t\t\t\t\t\t// check for overlap\n\t\tif (dim == 2 || overlap(box)) {\n\t\t\tfor (int i = 0; i < n_pts; i++) {\t// yes, write the points\n\t\t\t\tifile >> idx;\n\t\t\t\twritePoint(pts[idx]);\n\t\t\t}\n\t\t}\n\t\telse {\t\t\t\t\t\t\t\t\t// input but ignore points\n\t\t\tfor (int i = 0; i < n_pts; i++) {\n\t\t\t\tifile >> idx;\n\t\t\t}\n\t\t}\n\t}\n\telse if (strcmp(tag, \"split\") == 0) {\t\t// splitting node\n\n\t\tifile >> cd >> cv >> lb >> hb;\n\t\tif (lb != box.lo[cd] || hb != box.hi[cd]) {\n\t\t\tError(\"Bounding box coordinates are fishy\", ANNwarn);\n\t\t}\n\n\t\tANNcoord lv = box.lo[cd];\t\t\t\t// save bounds for cutting dim\n\t\tANNcoord hv = box.hi[cd];\n\n\t\t//--------------------------------------------------------------\n\t\t//\tThe following code is rather fragile so modify at your\n\t\t//\town risk.  We first decrease the high-end of the bounding\n\t\t//\tbox down to the cutting plane and then read the left subtree.\n\t\t//\tThen we increase the low-end of the bounding box up to the\n\t\t//\tcutting plane (thus collapsing the bounding box to a d-1\n\t\t//\tdimensional hyperrectangle).  Then we draw the projection of\n\t\t//\tits diagonal if it crosses the slicing plane.  This will have\n\t\t//\tthe effect of drawing its intersection on the slicing plane.\n\t\t//\tThen we restore the high-end of the bounding box and read\n\t\t//\tthe right subtree.  Finally we restore the low-end of the\n\t\t//\tbounding box, before returning.\n\t\t//--------------------------------------------------------------\n\t\tbox.hi[cd] = cv;\t\t\t\t\t\t// decrease high bounds\n\t\trecReadTree(box);\t\t\t\t\t\t// read left subtree\n\t\t\t\t\t\t\t\t\t\t\t\t// check for overlap\n\t\tbox.lo[cd] = cv;\t\t\t\t\t\t// increase low bounds\n\t\tif (dim == 2 || overlap(box)) {\t\t\t// check for overlap\n\t\t\tif (cd == dim_x || cd == dim_y) {\t// cut through slice plane\n\t\t\t\twriteLine(box.lo, box.hi);\t\t// draw cutting line\n\t\t\t}\n\t\t}\n\t\tbox.hi[cd] = hv;\t\t\t\t\t\t// restore high bounds\n\n\t\trecReadTree(box);\t\t\t\t\t\t// read right subtree\n\t\tbox.lo[cd] = lv;\t\t\t\t\t\t// restore low bounds\n\t}\n\telse if (strcmp(tag, \"shrink\") == 0) {\t\t// splitting node\n\n\t\tANNorthRect inner(dim, box);\t\t\t// copy bounding box\n\t\tifile >> n_bnds;\t\t\t\t\t\t// number of bounding sides\n\t\tfor (int i = 0; i < n_bnds; i++) {\n\t\t\tifile >> cd >> cv >> sd;\t\t\t// input bounding halfspace\n\t\t\tANNorthHalfSpace hs(cd, cv, sd);\t// create orthogonal halfspace\n\t\t\ths.project(inner.lo);\t\t\t\t// intersect by projecting\n\t\t\ths.project(inner.hi);\n\t\t}\n\t\tif (dim == 2 || overlap(inner)) {\n\t\t\twriteBox(inner);\t\t\t\t\t// draw inner rectangle\n\t\t}\n\t\trecReadTree(inner);\t\t\t\t\t\t// read inner subtree\n\t\trecReadTree(box);\t\t\t\t\t\t// read outer subtree\n\t}\n\telse {\n\t\tError(\"Illegal node type in dump file\", ANNabort);\n\t}\n}\n\nvoid readTree(ANNorthRect &bnd_box)\n{\n\twriteHeader();\t\t\t\t\t\t\t\t// output header\n\twriteBox(bnd_box);\t\t\t\t\t\t\t// draw bounding box\n\twriteCaption(bnd_box, caption);\t\t\t\t// write caption\n\trecReadTree(bnd_box);\t\t\t\t\t\t// do it\n}\n\n//----------------------------------------------------------------------\n// readANN - read the ANN dump file\n//\n//\t\tThis procedure reads in the dump file.  See the format below.\n//\t\tIt first reads the header line with version number.  If the\n//\t\tpoints section is present it reads them (otherwise just leaves\n//\t\tpoints = NULL), and then it reads the tree section.  It inputs\n//\t\tthe bounding box and determines the parameters for transforming\n//\t\tthe image to figure units.  It then invokes the procedure\n//\t\treadTree to do all the real work.\n//\n//\t\tDump File Format: <xxx> = coordinate value (ANNcoord)\n//\n//\t\t#ANN <version number> <comments> [END_OF_LINE]\n//\t\tpoints <dim> <n_pts>\t\t\t(point coordinates: this is optional)\n//\t\t0 <xxx> <xxx> ... <xxx>\t\t\t(point indices and coordinates)\n//\t\t1 <xxx> <xxx> ... <xxx>\n//\t\t  ...\n//\t\ttree <dim> <n_pts> <bkt_size>\n//\t\t<xxx> <xxx> ... <xxx>\t\t\t(lower end of bounding box)\n//\t\t<xxx> <xxx> ... <xxx>\t\t\t(upper end of bounding box)\n//\t\t\t\tIf the tree is null, then a single line \"null\" is\n//\t\t\t\toutput.  Otherwise the nodes of the tree are printed\n//\t\t\t\tone per line in preorder.  Leaves and splitting nodes\n//\t\t\t\thave the following formats:\n//\t\tLeaf node:\n//\t\t\t\tleaf <n_pts> <bkt[0]> <bkt[1]> ... <bkt[n-1]>\n//\t\tSplitting nodes:\n//\t\t\t\tsplit <cut_dim> <cut_val> <lo_bound> <hi_bound>\n//\t\tShrinking nodes:\n//\t\t\t\tshrink <n_bnds>\n//\t\t\t\t\t\t<cut_dim> <cut_val> <side>\n//\t\t\t\t\t\t<cut_dim> <cut_val> <side>\n//\t\t\t\t\t\t... (repeated n_bnds times)\n//\n//\t\tNote: Infinite lo_ and hi_bounds are printed as the special\n//\t\t\t\tvalues \"-INF\" and \"+INF\", respectively.  We do not\n//\t\t\t\tcheck for this, because the current version of ANN\n//\t\t\t\tstarts with a finite bounding box if the tree is\n//\t\t\t\tnonempty.\n//----------------------------------------------------------------------\n\nvoid readANN()\n{\n\tint j;\n\tchar str[STRING_LEN];\t\t\t\t\t\t// storage for string\n    char version[STRING_LEN];\t\t\t\t\t// storage for version\n\tint  bkt_size;\t\t\t\t\t\t\t\t// bucket size\n\n\tifile >> str;\t\t\t\t\t\t\t\t// input header\n\tif (strcmp(str, \"#ANN\") != 0) {\t\t\t\t// incorrect header\n\t\tError(\"Incorrect header for dump file\", ANNabort);\n\t}\n    ifile.getline(version, STRING_LEN);\t\t\t// get version (ignore)\n\tifile >> str;\t\t\t\t\t\t\t\t// get major heading\n\tif (strcmp(str, \"points\") == 0) {\t\t\t// points section\n\t\tifile >> dim;\t\t\t\t\t\t\t// read dimension\n\t\tifile >> n_pts;\t\t\t\t\t\t\t// number of points\n\t\tpts = annAllocPts(n_pts, dim);\t\t\t// allocate points\n\t\tfor (int i = 0; i < n_pts; i++) {\t\t// input point coordinates\n\t\t\tint idx;\t\t\t\t\t\t\t// point index\n\t\t\tifile >> idx;\t\t\t\t\t\t// input point index\n\t\t\tif (idx < 0 || idx >= n_pts) {\n\t\t\t\tError(\"Point index is out of range\", ANNabort);\n\t\t\t}\n\t\t\tfor (j = 0; j < dim; j++) {\n\t\t\t\tifile >> pts[idx][j];\t\t\t// read point coordinates\n\t\t\t}\n\t\t}\n\t\tifile >> str;\t\t\t\t\t\t\t// get next major heading\n\t}\n\tif (strcmp(str, \"tree\") == 0) {\t\t\t\t// tree section\n\t\tifile >> dim;\t\t\t\t\t\t\t// read dimension\n\t\tif (dim_x > dim || dim_y > dim) {\n\t\t\tError(\"Dimensions out of bounds\", ANNabort);\n\t\t}\n\t\tifile >> n_pts;\t\t\t\t\t\t\t// number of points\n\t\tifile >> bkt_size;\t\t\t\t\t\t// bucket size (ignored)\n\t\t\t\t\t\t\t\t\t\t\t\t// read bounding box\n\t\tANNorthRect bnd_box(dim);\t\t\t\t// create bounding box\n\t\tfor (j = 0; j < dim; j++) {\n\t\t\tifile >> bnd_box.lo[j];\t\t\t\t// read box low coordinates\n\t\t}\n\t\tfor (j = 0; j < dim; j++) {\n\t\t\tifile >> bnd_box.hi[j];\t\t\t\t// read box high coordinates\n\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t// compute scaling factors\n\t\tdouble box_len_x = bnd_box.hi[dim_x] - bnd_box.lo[dim_x];\n\t\tdouble box_len_y = bnd_box.hi[dim_y] - bnd_box.lo[dim_y];\n\t\t\t\t\t\t\t\t\t\t\t\t// longer side determines scale\n\t\tif (box_len_x > box_len_y) scale = u_size/box_len_x;\n\t\telse\t\t\t\t\t   scale = u_size/box_len_y;\n\t\t\t\t\t\t\t\t\t\t\t\t// compute offsets\n\t\toffset_x = u_low_x - scale*bnd_box.lo[dim_x];\n\t\toffset_y = u_low_y + scale*bnd_box.hi[dim_y];\n\t\treadTree(bnd_box);\t\t\t\t\t\t// read the tree and process\n\t}\n\telse if (strcmp(str, \"null\") == 0) return;\t// empty tree\n\telse {\n\t\tcerr << \"Input string: \" << str << \"\\n\";\n\t\tError(\"Illegal ann format.  Expecting section heading\", ANNabort);\n\t}\n}\n\n//----------------------------------------------------------------------\n// Main program\n//\n// Gets the command-line arguments and invokes the main scanning\n// procedure.\n//----------------------------------------------------------------------\n\nint main(int argc, char **argv)\n{\n\tgetArgs(argc, argv);\t\t\t\t\t\t// get input arguments\n\treadANN();\t\t\t\t\t\t\t\t\t// read the dump file\n}\n",
    "created" : 1488854186473.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3535486483",
    "id" : "F73CDD7A",
    "lastKnownWriteTime" : 1488854229,
    "last_content_update" : 1488854229552,
    "path" : "~/Dropbox (Personal)/Projects/Genes_Inference_in_Cell_Differentiation_Process/R_package/ANN.L.infinity/src/ann2fig.cpp",
    "project_path" : "src/ann2fig.cpp",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}