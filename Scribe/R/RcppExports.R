# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title
#' di_single_run
#' @description
#' This function simulates the DIRECTED mutual information from X to Y when you have a SINGLE run of the process
#' 
#' @param x one random variable from the time-series data
#' 
#' @param y another random variable from the time-series data
#'
#' @param n Parameter n determines the the number of previous time samples upon which the mi is conditioned (delay in the formula I(x-->y)=I(x_{t-d};y_t|y_{t-1}) default: d=1)
#'
#' @details
#' \code{di_single_run} takes two random variables x and y as well as a delay n to estimate the direct information between variable x and y. 
#' @return a matrix for the condition mutual information estimators between all pairwise variables (x, y) in the data matrix x, y
#' @export
di_single_run <- function(x, y, n) {
    .Call('_Scribe_di_single_run', PACKAGE = 'Scribe', x, y, n)
}

#' @title
#' di_single_run_conditioned
#' @description
#' This function simulates the CONDITIONED DIRECTED mutual information from X to Y when you have a SINGLE run of the processes
#' 
#' @param x one random variable from the time-series data
#' 
#' @param y another random variable from the time-series data
#'
#' @param z z is a dataframe (or matrix) containing the data of other processes upon the past of which the mi is conditioned
#' 
#' @param n Parameter n determines the the number of previous time samples upon which the mi is conditioned
#' 
#' @details
#' \code{di_single_run_conditioned} takes two random variables x and y as well as the parameter n to calculate the direct information conditioned on variable z. 
#' @return a matrix for the condition mutual information estimators between all pairwise variables (x, y) in the data matrix x, y
#' @export
di_single_run_conditioned <- function(x, y, z, n) {
    .Call('_Scribe_di_single_run_conditioned', PACKAGE = 'Scribe', x, y, z, n)
}

#' @title
#' rdi_many_runs
#' @description
#' This function simulates the DIRECTED mutual information from X to Y when you have multiple run of the processes
#' 
#' @param x a random variable with multiple run of the same process
#' 
#' @param y another random variable with multiple run of another process
#'
#' @details
#' \code{rdi_many_runs} takes two random variables (with the same multiple realization of the two processes) and estimate the direct information between them. 
#' using the formula: 0.5 * d * log(pi) - log(gamma(0.5 * d + 1))
#' It's implimented in C++, providing a (small) increase in speed over the R equivalent.
#' @return a numeric vector storing the DI from two multiple run variables
#' @export
rdi_many_runs <- function(x, y) {
    .Call('_Scribe_rdi_many_runs', PACKAGE = 'Scribe', x, y)
}

#' @title
#' rdi_single_run
#' @description
#' This function simulates the RESTRICTED DIRECTED mutual information from X to Y when you have a SINGLE run of the processes
#' 
#' @param x one random variable from the time-series data
#' 
#' @param y another random variable from the time-series data
#' 
#' @param d delay in the formula I(x-->y)=I(x_{t-d};y_t|y_{t-1}) default: d=1
#'
#' @details
#' \code{rdi_single_run} takes two random variables x and y as well as a time delay d to estimate the restricted direct infomation between them.
#' @return a matrix for the condition mutual information estimators between all pairwise variables (x, y) in the data matrix x, y
#' @export
rdi_single_run <- function(x, y, d) {
    .Call('_Scribe_rdi_single_run', PACKAGE = 'Scribe', x, y, d)
}

#' @title
#' lmi_single_run
#' @description
#' This subroutine calculates the lagged mutual information 
#' 
#' @param x one random variable from the time-series data
#' 
#' @param y another random variable from the time-series data
#'
#' @param delay Time lags used to estimate the RDI values  
#'
#' @details
#' \code{cmi} takes two random variable x and y and estimated their mutual information conditioned on the third random variable z
#' using the KSG estimator. 
#' It relies on the ANN package to query the kNN with KDTree algorithm. 
#' @return a numeric value for the condition mutual information estimator between two variables (x, y) conditioned on variable z
#' @export
lmi_single_run <- function(x, y, delay) {
    .Call('_Scribe_lmi_single_run', PACKAGE = 'Scribe', x, y, delay)
}

#' @title
#' This function simulates the CONDITIONED DIRECTED mutual information from X to Y CONDITIONED ON Z when you have a SINGLE run of the processes
#' @description
#' This subroutine calculates the volume of a d-dimensional unit ball for Euclidean norm
#' 
#' @param x one random variable from the time-series data
#' 
#' @param y another random variable from the time-series data
#' 
#' @param z z is a dataframe or matrix consisting of the data for different variables
#' 
#' @param z_delays z_delay is also a dataframe or matrix consisting of the delays to be applied to different variables
#' 
#' @param d delay in the formula I(x-->y)=I(x_{t-d};y_t|y_{t-1}) default: d=1
#'
#' @details
#' \code{rdi_single_run_conditioned} takes two random variables x and y as well as the parameter n to calculate the restricted direct information conditioned on variable z. 
#' @return a matrix for the condition mutual information estimators between all pairwise variables (x, y) in the data matrix x, y
#' @export
rdi_single_run_conditioned <- function(x, y, z, z_delays, d) {
    .Call('_Scribe_rdi_single_run_conditioned', PACKAGE = 'Scribe', x, y, z, z_delays, d)
}

extract_max_rdi_value_delay <- function(rdi_result, delays) {
    .Call('_Scribe_extract_max_rdi_value_delay', PACKAGE = 'Scribe', rdi_result, delays)
}

calculate_rdi_cpp <- function(expr_data, delays, super_graph, turning_points, method) {
    .Call('_Scribe_calculate_rdi_cpp', PACKAGE = 'Scribe', expr_data, delays, super_graph, turning_points, method)
}

calculate_rdi_cpp_wrap <- function(expr_data, delays, super_graph, turning_points, method) {
    .Call('_Scribe_calculate_rdi_cpp_wrap', PACKAGE = 'Scribe', expr_data, delays, super_graph, turning_points, method)
}

extract_top_incoming_nodes_delays <- function(max_rdi_value, max_rdi_delays, k) {
    .Call('_Scribe_extract_top_incoming_nodes_delays', PACKAGE = 'Scribe', max_rdi_value, max_rdi_delays, k)
}

calculate_conditioned_rdi_cpp_wrap <- function(expr_data, super_graph, max_rdi_value, max_rdi_delays, k) {
    .Call('_Scribe_calculate_conditioned_rdi_cpp_wrap', PACKAGE = 'Scribe', expr_data, super_graph, max_rdi_value, max_rdi_delays, k)
}

#' @title
#' entropy
#' @description
#' This subroutine calculates the volume of a d-dimensional unit ball for Euclidean norm
#' 
#' @param R_x number of dimension
#' 
#' @param R_k number of dimension
#'
#' @details
#' \code{entropy} takes a integer of dimensions and then calculate the olume of a d-dimensional unit ball for Euclidean norm
#' using the formula: 0.5 * d * log(pi) - log(gamma(0.5 * d + 1))
#' It's implimented in C++, providing a (small) increase in speed over the R equivalent.
#' @return a updated matrix with gene expression smoothed with window size equal to window_size
#' @export
smooth_gene <- function(expr_data, window_size) {
    .Call('_Scribe_smooth_gene', PACKAGE = 'Scribe', expr_data, window_size)
}

rdi_single_run_multiple_run_cpp <- function(x, y, d, run_vec) {
    .Call('_Scribe_rdi_single_run_multiple_run_cpp', PACKAGE = 'Scribe', x, y, d, run_vec)
}

calculate_rdi_multiple_run_cpp <- function(expr_data, delays, run_vec, super_graph, turning_points, method) {
    .Call('_Scribe_calculate_rdi_multiple_run_cpp', PACKAGE = 'Scribe', expr_data, delays, run_vec, super_graph, turning_points, method)
}

calculate_rdi_multiple_run_cpp_wrap <- function(expr_data, delays, run_vec, super_graph, turning_points, method) {
    .Call('_Scribe_calculate_rdi_multiple_run_cpp_wrap', PACKAGE = 'Scribe', expr_data, delays, run_vec, super_graph, turning_points, method)
}

rdi_multiple_runs_conditioned_cpp <- function(x, y, z, z_delays, d, run_vec) {
    .Call('_Scribe_rdi_multiple_runs_conditioned_cpp', PACKAGE = 'Scribe', x, y, z, z_delays, d, run_vec)
}

#' @title
#' This function simulates the CONDITIONED DIRECTED mutual information from X to Y CONDITIONED ON Z when you have a SINGLE run of the processes
#' @description
#' This subroutine calculates the volume of a d-dimensional unit ball for Euclidean norm
#' 
#' @param x one random variable from the time-series data
#' 
#' @param y another random variable from the time-series data
#' 
#' @param z z is a dataframe or matrix consisting of the data for different variables
#' 
#' @param z_delays z_delay is also a dataframe or matrix consisting of the delays to be applied to different variables
#' 
#' @param d delay in the formula I(x-->y)=I(x_{t-d};y_t|y_{t-1}) default: d=1
#'
#' @details
#' \code{rdi_single_run_conditioned} takes two random variables x and y as well as the parameter n to calculate the restricted direct information conditioned on variable z. 
#' @return a matrix for the condition mutual information estimators between all pairwise variables (x, y) in the data matrix x, y
#' @export
rdi_multiple_runs_conditioned <- function(x, y, z, z_delays, d, run_vec) {
    .Call('_Scribe_rdi_multiple_runs_conditioned', PACKAGE = 'Scribe', x, y, z, z_delays, d, run_vec)
}

calculate_multiple_run_conditioned_rdi_cpp <- function(expr_data, super_graph, max_rdi_value, max_rdi_delays, run_vec, k) {
    .Call('_Scribe_calculate_multiple_run_conditioned_rdi_cpp', PACKAGE = 'Scribe', expr_data, super_graph, max_rdi_value, max_rdi_delays, run_vec, k)
}

calculate_multiple_run_conditioned_rdi_wrap <- function(expr_data, super_graph, max_rdi_value, max_rdi_delays, run_vec, k) {
    .Call('_Scribe_calculate_multiple_run_conditioned_rdi_wrap', PACKAGE = 'Scribe', expr_data, super_graph, max_rdi_value, max_rdi_delays, run_vec, k)
}

clr <- function(x) {
    .Call('_Scribe_clr', PACKAGE = 'Scribe', x)
}

#'  This subroutine calculates the volume of a d-dimensional unit ball for Euclidean norm
NULL

#' This function estimates the entropy of a continuous random variable
NULL

#' This function estimates the CONDITIONAL mutual information of X and Y given Z
#' Multiply a number by two
#'
NULL

knn_density <- function(x, y, k = 5L) {
    .Call('_Scribe_knn_density', PACKAGE = 'Scribe', x, y, k)
}

knn_density_2d <- function(x, y, nGrid, k = 5L) {
    .Call('_Scribe_knn_density_2d', PACKAGE = 'Scribe', x, y, nGrid, k)
}

digamma_0 <- function(x) {
    .Call('_Scribe_digamma_0', PACKAGE = 'Scribe', x)
}

#' @title
#' vd
#' @description
#' This subroutine calculates the volume of a d-dimensional unit ball for Euclidean norm
#' 
#' @param d number of dimension
#' 
#' @details
#' \code{vd} takes a integer of dimensions and then calculate the volume of a d-dimensional unit ball for Euclidean norm
#' using the formula: 0.5 * d * log(pi) - log(gamma(0.5 * d + 1))
#' It's implimented in C++, providing a (small) increase in speed over the R equivalent.
#' @return a numeric value for the d-dimensional unit ball for Euclidean norm
#' @export
vd <- function(d) {
    .Call('_Scribe_vd', PACKAGE = 'Scribe', d)
}

#' @title
#' entropy
#' @description
#' This subroutine estimates the entropy of a continuous random variable
#' 
#' @param x data matrix used for calculating the entropy
#' 
#' @param k number for nearest neighbors used in entropy calculation
#'
#' @details
#' \code{entropy} takes a continuous random variable and then estimates
#' entropy using the KSG estimator. 
#' It relies on the ANN package to query the kNN with KDTree algorithm.  
#' @return a vector of entropy values
#' @export
entropy <- function(x, k) {
    .Call('_Scribe_entropy', PACKAGE = 'Scribe', x, k)
}

#' @title
#' mi
#' @description
#' This function estimates the mutual information of two random variables based on their observed values
#' 
#' @param x one random variable from the time-series data
#' 
#' @param y another random variable from the time-series data
#'
#' @param k number for nearest neighbors used in entropy calculation
#'
#' @details
#' \code{mi} takes two random variables x and y to estimate the mutual information between them 
#' using the KSG estimator
#' It relies on the ANN package to query the kNN with KDTree algorithm. 
#' @return a numeric value for the mutual information estimator between two variables (x, y)
#' @export
mi <- function(x, y, k) {
    .Call('_Scribe_mi', PACKAGE = 'Scribe', x, y, k)
}

#' @title
#' cmi
#' @description
#' This subroutine calculates the volume of a d-dimensional unit ball for Euclidean norm
#' 
#' @param x one random variable from the time-series data
#' 
#' @param y another random variable from the time-series data
#'
#' @param z condition random variable for variables (x, y) from the time-series data
#'
#' @param k number for nearest neighbors used in entropy calculation
#'
#' @details
#' \code{cmi} takes two random variable x and y and estimated their mutual information conditioned on the third random variable z
#' using the KSG estimator. 
#' It relies on the ANN package to query the kNN with KDTree algorithm. 
#' @return a numeric value for the condition mutual information estimator between two variables (x, y) conditioned on variable z
#' @export
cmi <- function(x, y, z, k) {
    .Call('_Scribe_cmi', PACKAGE = 'Scribe', x, y, z, k)
}

