{
    "collab_server" : "",
    "contents" : "// ver 0.1; code review at Oct 2, 2017\n// ver 0.2; update the documentation at Oct 2, 2017\n\n#include <cmath>\n#include <RcppArmadillo.h>\n#include \"../inst/include/information_estimator.h\"\n\n// [[Rcpp::depends(RcppArmadillo)]]\n// #include <Rcpp.h>\n// #include <omp.h>\n// // [[Rcpp::plugins(openmp)]]\n\nusing namespace Rcpp;\nusing namespace arma;\n\n//-------------------------------------------------------------------------------------------------------------------\n/*\ncalculate direction information for single run\n*/\n//-------------------------------------------------------------------------------------------------------------------\n\n// This function simulates the DIRECTED mutual information from X to Y when you have a SINGLE run of the processes\n// Parameter n determines the the number previous time samples upon which the mi is conditioned\n// double mi_cpp(double x, double y, double xy, int k = 5, int N)\n// double cmi_cpp(double x, double y, double xyz, double xz, double yz, int k = 5, int N)\n\ndouble di_single_run_cpp(NumericMatrix& x, NumericMatrix& y, int n = 5, bool uniformalize = false)\n{\n  \n  int x_cols = x.cols(); int y_cols = y.cols();\n  if(x_cols != y_cols)\n  {\n    stop(\"dimension of samples should be the same\");\n    return -1;\n  }\n  \n  int tau = n; \n  int tot_len = x.rows() - tau; \n  \n  int col_id = 0;\n  int i = 0, j = 0; \n  NumericMatrix x_past(tot_len, n * y_cols);\n  NumericMatrix y_past(tot_len, n * y_cols);\n  \n  // int max_thread = omp_get_max_threads();\n  // omp_set_num_threads(max_thread);\n  // #pragma omp parallel for shared(n, x_cols, y_cols, tot_len, x, y, x_past, y_past) private(i, j, col_id) //schedule(dynamic) default(none) //collapse(2) , _\n  \n  for(i = 0; i < tot_len; i ++)\n  {\n    for(j = 0; j < n * y_cols; j ++)\n    { // identify the index for the column\n      if(j == 0)\n      {\n        col_id = 0;\n      }\n      else\n      {\n        col_id = (j) % x_cols;\n      }\n      x_past(i, j) = x(i + (int) j / x_cols, col_id); // identify the index for the row\n      y_past(i, j) = y(i + (int) j / x_cols, col_id);\n    }\n  }\n  \n  NumericMatrix y_past0 = y(Range(tau, tau + tot_len - 1), _);\n  \n  if(uniformalize == true) {\n    // int k = 5, method = 1, k_density = 0; double bw = 0;\n    List ucmi_res = ucmi_cpp(x_past, y_past0, y_past, 5, 1, 0, 0); // k, method, k_density, bw\n    return ucmi_res[\"ucmi_res\"]; \n  } else {\n    List cmi_res = cmi_cpp(x_past, y_past0, y_past);\n    return cmi_res[\"cmi_res\"]; \n  } \n}\n\n//' @title\n//' di_single_run\n//' @description\n//' This function estimates the DIRECTED mutual information from X to Y when you have a SINGLE run of the process\n//' \n//' @param x one random variable from the time-series data\n//' \n//' @param y another random variable from the time-series data\n//'\n//' @param n Parameter n determines the the number of previous time samples upon which the mi is conditioned (delay in the formula I(x-->y)=I(x_{t-d};y_t|y_{t-1}) default: d=1)\n//'\n//' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n//' @details\n//' \\code{di_single_run} takes two random variables x and y as well as a delay n to estimate the direct information between variable x and y. \n//' @return a matrix for the condition mutual information estimators between all pairwise variables (x, y) in the data matrix x, y\n//' @export\n// [[Rcpp::export]]\ndouble di_single_run(SEXP x, SEXP y, SEXP n, SEXP uniformalize) \n{ \n  NumericMatrix x_cpp(x); \n  NumericMatrix y_cpp(y); \n  \n  int n_cpp = as<int>(n); \n  bool uniformalize_cpp = as<bool>(uniformalize); \n  \n  double di_res = di_single_run_cpp(x_cpp, y_cpp, n_cpp, uniformalize_cpp);\n  return di_res;\n}\n\n//-------------------------------------------------------------------------------------------------------------------\n/*\ncalculate conditional direction information for single run\n*/\n//-------------------------------------------------------------------------------------------------------------------\n\ndouble di_single_run_conditioned_cpp(NumericMatrix x, NumericMatrix y, NumericMatrix& z, int n = 5, bool uniformalize = false)\n{\n  uniformalize = false; // we cannot support kernel density estimator > 2 dim \n  int x_cols = x.cols(), y_cols = y.cols(); // , z_rows = z.rows(); // z_row is number of conditioning incoming nodes\n  if(x_cols > y_cols)\n  {\n    stop(\"dimension of samples should be the same\");\n    return -1;\n  }\n  \n  int tau = n; \n  int tot_len = x.rows() - tau; \n  \n  NumericMatrix x_past = x(Range(tau - 1, tau - 2 + tot_len), _); \n  NumericMatrix yz_past = y(Range(tau - 1, tau - 2 + tot_len), _), tmp; \n\n  // need to redesign the cbind function in order to use parallel    \n  // int i, j, k_x, k_yz; \n  // NumericMatrix x_past(tot_len, n * y_cols);\n  // NumericMatrix yz_past(tot_len, n * y_cols * (1 + z_rows));\n  \n  // int max_thread = omp_get_max_threads();\n  // omp_set_num_threads(max_thread);\n  // #pragma omp parallel for shared(tot_len, n, y_cols, x, y, z, x_past, yz_past, z_rows) private(i, j, k_x, k_yz) //schedule(dynamic) default(none) //collapse(2) , _\n  // for(i = 0; i < tot_len; i ++)\n  // {\n  //   for(j = 0; j < n; j ++)\n  //   { // identify the index for the column\n  //     for(k_x = 0; k_x < y_cols; k_x ++)\n  //     {\n  //       x_past(i, k_x + j * y_cols) = x(i + j, k_x); // identify the index for the row\n  //     }\n      \n  //     for(k_yz = 0; k_yz < y_cols * (1 + z_rows); k_yz ++)\n  //     {\n  //       if(k_yz > y_cols * z_rows - 1) // if(k_yz < y_cols) /* k_yz is the last values */\n  //       {\n  //         yz_past(i, k_yz + j * y_cols * (1 + z_rows)) = y(i + j, k_yz);      \n  //       }\n  //       else\n  //       { // i + j: column ind; k_yz % (1 + z_rows): row ind // k_yz / y_cols - 2\n  //         yz_past(i, k_yz + j * y_cols * (1 + z_rows)) = z( (int) k_yz % (1 + z_rows), i + j ); // (int) k_yz / y_cols - 2       \n  //       }\n  //     }\n  //   }\n  // }\n\n  // use cbind\n  for(int i = 1; i < n + 1; i ++)\n  {\n    if(i > 1)\n    {\n      tmp = x(Range(tau - i, tau - i - 1 + tot_len), _);\n      x_past = cbind(tmp, x_past);\n      tmp = y(Range(tau - i, tau - i - 1 + tot_len), _);\n      yz_past = cbind(tmp, yz_past);\n    }\n    \n    for(int j = 0; j < z.cols(); j ++ )\n    {\n      tmp = z(Range(tau - i, tau - i - 1 + tot_len), _);\n      yz_past = cbind(tmp, yz_past);\n    } \n  }\n  \n  NumericMatrix y_past0 = y(Range(tau, tau + tot_len - 1), _);\n\n  if(uniformalize == true) {\n    List ucmi_res = ucmi_cpp(x_past, y_past0, yz_past, 5, 1, 0, 0); // k, method, k_density, bw\n    return ucmi_res[\"ucmi_res\"]; \n  } else {\n    List cmi_res = cmi_cpp(x_past, y_past0, yz_past);\n    return cmi_res[\"cmi_res\"]; \n  }\n}\n\n//' @title\n//' di_single_run_conditioned\n//' @description\n//' This function estimates the CONDITIONED DIRECTED mutual information from X to Y, conditioning on a third variable, z, when you have a SINGLE run of the processes\n//' \n//' @param x one random variable from the time-series data\n//' \n//' @param y another random variable from the time-series data\n//'\n//' @param z z is a dataframe (or matrix) containing the data of other processes upon the past of which the mi is conditioned\n//' \n//' @param n Parameter n determines the the number of previous time samples upon which the mi is conditioned\n//' \n//' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n//' @details\n//' \\code{di_single_run_conditioned} takes two random variables x, y and z as well as the parameter n to calculate the direct information conditioned on variable z. \n//' @return a numeric value for the condition mutual information estimator variables (x, y), conditioning on a third variable, z. \n//' @export\n// [[Rcpp::export]]\ndouble di_single_run_conditioned(SEXP x, SEXP y, SEXP z, SEXP n, SEXP uniformalize) \n{ \n  NumericMatrix x_cpp(x); \n  NumericMatrix y_cpp(y); \n  NumericMatrix z_cpp(z); \n  \n  int n_cpp = as<int>(n); \n  bool uniformalize_cpp = as<bool>(uniformalize); \n  \n  double di_res = di_single_run_conditioned_cpp(x_cpp, y_cpp, z_cpp, n_cpp, uniformalize_cpp);\n  return di_res;\n}\n\n//-------------------------------------------------------------------------------------------------------------------\n/*\ncalculate restricted direction information for many runs\n*/\n//-------------------------------------------------------------------------------------------------------------------\n\ndouble rdi_many_runs_cpp(NumericMatrix& x, NumericMatrix& y, bool uniformalize = false)\n{\n  int dx = x.cols(), dy = y.cols();\n  if(dx != dy)\n  {\n    stop(\"The dimension of time samples has to be the same for X and Y\");\n  }\n  NumericVector ans(dx); // maybe mean or so? \n  NumericMatrix x_0, y_0, y_1;\n  \n  // OpenMP here too \n  int t; \n  // int max_thread = omp_get_max_threads();\n  // omp_set_num_threads(max_thread);\n  // #pragma omp parallel for shared(dx, x, y, ans) private(t, _, x_0, y_0, y_1) //schedule(dynamic) default(none) //collapse(2) , _\n  for(t = 1; t < dx; t ++)\n  {\n    x_0 = x(_, Range(t - 1, t - 1));\n    y_0 = y(_, Range(t, t));\n    y_1 = y(_, Range(t - 1, t - 1)); \n\n    if(uniformalize == true) {\n      List ucmi_res = ucmi_cpp(x_0, y_0, y_1, 5, 1, 0, 0); // k, method, k_density, bw\n      ans[t - 1] = ucmi_res[\"ucmi_res\"]; \n    } else {\n      List cmi_res = cmi_cpp(x_0, y_0, y_1);\n      ans[t - 1] = cmi_res[\"cmi_res\"]; \n    }\n  }\n  \n  return sum(ans); // return sum of ans? \n}\n\n//' @title\n//' rdi_many_runs\n//' @description\n//' This function estimates the DIRECTED mutual information from X to Y when you have multiple run of the processes.\n//' \n//' @param x a random variable with multiple run of the same process.\n//' \n//' @param y another random variable with multiple run of another process.\n//'\n//' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n//' @details\n//' \\code{rdi_many_runs} takes two random variables (with the same multiple realization of the two processes) and estimate \n//' the direct information between them at each time point. It then sums up those information estimators. This function can\n//' only be used when you have hundreds runs of the same time-series experiment. \n//' @return a numeric value storing the DI from two multiple run variables\n//' @export\n// [[Rcpp::export]]\ndouble rdi_many_runs(SEXP x, SEXP y, SEXP uniformalize) \n{ \n  NumericMatrix x_cpp(x); \n  NumericMatrix y_cpp(y); \n  bool uniformalize_cpp = as<bool>(uniformalize);\n  \n  double rdi_many_runs_res = rdi_many_runs_cpp(x_cpp, y_cpp, uniformalize_cpp);\n  return rdi_many_runs_res;\n}\n\n//-------------------------------------------------------------------------------------------------------------------\n/*\ncalculate restricted direction information for a single run\n*/\n//-------------------------------------------------------------------------------------------------------------------\n\ndouble rdi_single_run_cpp(NumericMatrix& x, NumericMatrix& y, int d = 1, bool uniformalize = false) \n{\n  int Nx = x.rows(); int Ny = y.rows(); //int dx = x.cols(); int dy = y.cols(); \n  \n  if(Nx != Ny)\n  {\n    stop(\"The number of time samples has to be the same for X and Y\");\n    return -1;\n  }\n  \n  NumericMatrix x_0 = x(Range(0, Nx - d - 1), _);\n  NumericMatrix y_0 = y(Range(d, Ny - 1), _);\n  NumericMatrix y_1 = y(Range(d - 1, Nx - 2), _);\n  \n  if(uniformalize == true) {\n    List ucmi_res = ucmi_cpp(x_0, y_0, y_1, 5, 1, 0, 0); // k, method, k_density, bw\n    return ucmi_res[\"ucmi_res\"]; \n  } else {\n    List cmi_res = cmi_cpp(x_0, y_0, y_1);\n    return cmi_res[\"cmi_res\"]; \n  }\n}\n\n//' @title\n//' rdi_single_run\n//' @description\n//' This function estimates the RESTRICTED DIRECTED mutual information from X to Y when you have a SINGLE run of the processes\n//' \n//' @param x one random variable from the time-series data\n//' \n//' @param y another random variable from the time-series data\n//' \n//' @param d delay in the formula I(x-->y)=I(x_{t-d};y_t|y_{t-1}) default: d=1\n//'\n//' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n//' @details\n//' \\code{rdi_single_run} takes two random variables x and y as well as a time delay d to estimate the restricted direct infomation between them.\n//' @return a numeric value for the restricted direct information between x and y with a time delay d = 1. \n//' @export\n// [[Rcpp::export]]\ndouble rdi_single_run(SEXP x, SEXP y, SEXP d, SEXP uniformalize) \n{ \n  NumericMatrix x_cpp(x); \n  NumericMatrix y_cpp(y); \n  \n  int d_cpp = as<int>(d); \n  bool uniformalize_cpp = as<bool>(uniformalize); \n  \n  double rdi_single_run_res = rdi_single_run_cpp(x_cpp, y_cpp, d_cpp, uniformalize_cpp);\n  return rdi_single_run_res;\n}\n\n\n//-------------------------------------------------------------------------------------------------------------------\n/*\n  calculate the lagged mutual information \n*/\n//-------------------------------------------------------------------------------------------------------------------\n\ndouble lmi_single_run_cpp(NumericMatrix& x, NumericMatrix& y, int delay = 1, bool uniformalize = false) \n{\n  int Nx = x.rows(); int Ny = y.rows(); \n  \n  if(Nx != Ny)\n  {\n    stop(\"The number of time samples has to be the same for X and Y\");\n    return -1;\n  }\n  \n  NumericMatrix x_0 = x(Range(0, Nx - delay - 1), _);\n  NumericMatrix y_0 = y(Range(delay, Ny - 1), _);\n  \n  // Rcout << \"\\n before running CMI \" << std::endl;\n  return mi_cpp(x_0, y_0); \n}\n\n//' @title\n//' lmi_single_run\n//' @description\n//' This subroutine calculates the lagged mutual information \n//' \n//' @param x one random variable from the time-series data\n//' \n//' @param y another random variable from the time-series data\n//'\n//' @param delay Time lags used to estimate the RDI values  \n//'\n//' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n//' @details\n//' \\code{lmi_single_run} takes two random variable x and y and estimated their mutual information with a time lag d. \n//' using the KSG estimator. \n//' It relies on the ANN package to query the kNN with KDTree algorithm. \n//' @return a numeric value for the mutual information estimator between two variables (x, y) with a time lag d.\n//' @export\n// [[Rcpp::export]]\ndouble lmi_single_run(SEXP x, SEXP y, SEXP delay, SEXP umi) \n{ \n  NumericMatrix x_cpp(x); \n  NumericMatrix y_cpp(y); \n\n  int delay_cpp = as<int>(delay); \n  bool umi_cpp = as<bool>(umi); \n  \n  double lmi_res = lmi_single_run_cpp(x_cpp, y_cpp, delay_cpp, umi_cpp);\n  return lmi_res;\n}\n\n// lmi for multiple runs\n// [[Rcpp::export]]\ndouble lmi_multiple_run_cpp(NumericMatrix& x, NumericMatrix& y, int d = 1, IntegerVector run_vec = 0, bool uniformalize = false) \n{\n  int Nx = x.rows(); int Ny = y.rows(); int run_len; \n  \n  if(Nx != Ny)\n  {\n    stop(\"The number of time samples has to be the same for X and Y\");\n    return -1;\n  }\n \n  int run_max = max(run_vec); // run_vec: vector to represent the run, need to be just numeric numbers and starts from 0. \n  int current_ind = 0; // current initial index for storing new slice of data \n\n  NumericMatrix x_0_res, y_0_res, tmp; // matrix passed to cmi function\n  IntegerVector index_all = seq_len(run_vec.size()) - 1, current_run_ind; // cell index from 0 to maximal number of cells; run index corresponding to current run during iteration \n\n  if(run_max == 0) \n  {\n    x_0_res = x(Range(0, Nx - d - 1), _); // x should only has 1 colum \n    y_0_res = y(Range(d, Ny - 1), _);\n  } else {\n\n    // correctly set the dimensionality for the x_0, y_0 and y_1 matrix \n    int tot_len = Nx - d * (run_max + 1); // number of samples minus the delay times total number of runs \n\n    mat x_0(tot_len, 1), y_0(tot_len, 1); // arma matrix \n    \n    uvec pos; // arma uvec \n    vec vals; // arma vec \n\n    IntegerVector rng; \n\n    for(int i = 0; i <= run_max; i++) // concatenate the data \n    {\n      current_run_ind = index_all[run_vec == i]; // get the cells that belong to a particular run \n      run_len = current_run_ind.size(); \n\n      if(current_run_ind.size() < d)\n      {\n        stop(\"Each run has to have more samples than the designated 'delays'\");\n        return -1;\n      }\n\n      rng = Range(current_ind, current_ind + run_len - d - 1); \n\n      pos = as<uvec>( rng ); \n      \n      // assuming x is only one column (Cx, Cy is not used)\n      tmp = x(Range(min(current_run_ind), min(current_run_ind) + run_len - d - 1), Range(0, 0)); //x(Range(1, 2), Range(1, 1));\n      vals = as<vec>( tmp ); \n      x_0.elem(pos) = vals; \n\n      IntegerVector rng_vec = Range(min(current_run_ind), min(current_run_ind) + run_len - d - 1); \n      // for(int test_na = 0; test_na < vals.n_elem; test_na ++) \n      // {\n      //   if(arma::is_finite(vals[test_na]) == false) \n      //   {\n      //     // Rcout << \"identify non-finite values for x_0 here; i is \" << i << \" rng_vec is \" << rng_vec << std::endl; \n      //   }\n      // }\n\n\n      tmp = y(Range(min(current_run_ind) + d, min(current_run_ind) + run_len - 1), Range(0, 0)); //x(Range(1, 2), Range(1, 1));\n      vals = as<vec>( tmp ); \n      y_0.elem(pos) = vals; \n\n      // for(int test_na = 0; test_na < vals.n_elem; test_na ++) \n      // {\n      //   if(arma::is_finite(vals[test_na]) == false) \n      //   {\n      //     Rcout << \"identify non-finite values for x_0 here; i is \" << i << \" rng_vec is \" << rng_vec << std::endl; \n      //   }\n      // }\n\n      // for(int test_na = 0; test_na < vals.n_elem; test_na ++) \n      // {\n      //   if(arma::is_finite(vals[test_na]) == false) \n      //   {\n      //     Rcout << \"identify non-finite values for x_0 here; i is \" << i << \" rng_vec is \" << rng_vec << std::endl; \n      //   }\n      // }\n\n      current_ind = current_ind + run_len - d; // move to the the next position after filling the current run (note that there is no - 1)\n    }\n\n\n    x_0_res = as<NumericMatrix>( wrap(x_0) ); // this conversion have problems? \n    y_0_res = as<NumericMatrix>( wrap(y_0) );\n  }  \n\n  return mi_cpp(x_0_res, y_0_res);  \n}\n\n//' @title\n//' lmi_multiple_run\n//' @description\n//' This subroutine calculates the lagged mutual information with multiple realization of the same processes. \n//' \n//' @param x one random variable from the time-series data\n//' \n//' @param y another random variable from the time-series data\n//'\n//' @param d Time lags used to estimate the RDI values  \n//'\n//' @param run_vec A integer vector encodes the information of the run id (run id start from 0) \n//'\n//' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n//' @details\n//' \\code{lmi_multiple_run} takes two random variables x and y, each has multiple realization of the same process and estimated their mutual information with a time lag d. \n//' using the KSG estimator. \n//' It relies on the ANN package to query the kNN with KDTree algorithm. \n//' @return a numeric value for the estimated mutual information between two variables (x, y) with a time lag d. \n//' @export\n// [[Rcpp::export]]\ndouble lmi_multiple_run(SEXP x, SEXP y, SEXP d, SEXP run_vec, SEXP umi) \n{ \n  NumericMatrix x_cpp(x); \n  NumericMatrix y_cpp(y); \n\n  int d_cpp = as<int>(d); \n\n  IntegerVector run_vec_cpp(run_vec); \n  bool umi_cpp = as<bool>(umi);\n\n  double lmi_res = lmi_multiple_run_cpp(x_cpp, y_cpp, d_cpp, run_vec_cpp, umi_cpp);\n  return lmi_res;\n}\n//-------------------------------------------------------------------------------------------------------------------\n/*\ncalculate conditional restricted direction information for a single run\n*/\n//-------------------------------------------------------------------------------------------------------------------\n\ndouble rdi_single_run_conditioned_cpp(NumericMatrix& x, NumericMatrix& y, NumericMatrix& z, NumericVector& z_delays, int d = 1, bool uniformalize = false) \n{\n  uniformalize = false; // we cannot support kernel density estimator > 2 dim \n\n  int Nx = x.rows(); int Ny = y.rows(); int Nz = z.rows(); // int dx = x.cols(); int dy = y.cols(); int dz = z.cols(); \n  if(Nx != Ny | Nx != Nz)\n  {\n    stop(\"The number of time samples has to be the same for X and Y or Z\");\n    return -1;\n  }\n  \n  z_delays.push_back(d);\n  int tau = max(z_delays); \n  \n  int tot_len = x.rows() - tau;  \n  \n  NumericMatrix yz = y(Range(tau - 1, tau - 2 + tot_len), _);\n  \n  NumericMatrix tmp; \n  \n  // OpenMP here too \n  // int max_thread = omp_get_max_threads();\n  // omp_set_num_threads(max_thread);\n  // #pragma omp parallel for shared(z, tau, z_delays, tot_len) private(j, tmp, yz) //schedule(dynamic) default(none) //collapse(2) , _\n    \n  // using cbind\n  for(int j = 0; j < z.cols(); j ++ )\n  {\n    tmp = z(Range(tau - z_delays[j], tau - z_delays[j] + tot_len - 1), Range(j, j));\n    yz = cbind(tmp, yz);\n  } \n  \n  NumericMatrix x_0 = x(Range(tau - d, tau - d + tot_len - 1), _);\n  NumericMatrix y_0 = y(Range(tau, tau + tot_len - 1), _);\n  \n  if(uniformalize == true) {\n    List ucmi_res = ucmi_cpp(x_0, y_0, yz, 5, 1, 0, 0); // k, method, k_density, bw\n    return ucmi_res[\"ucmi_res\"]; \n  } else {\n    List cmi_res = cmi_cpp(x_0, y_0, yz);\n    return cmi_res[\"cmi_res\"]; \n  }\n}\n\n//' @title\n//' rdi_single_run_conditioned\n//' @description\n//' This function estimates the CONDITIONED DIRECTED mutual information from X to Y CONDITIONED ON Z when you have a SINGLE run of the processes\n//' \n//' @param x one random variable from the time-series data\n//' \n//' @param y another random variable from the time-series data\n//' \n//' @param z z is a dataframe or matrix consisting of the data for different variables which will be conditioned on. \n//' \n//' @param z_delays z_delay is also a dataframe or matrix consisting of the delays to be applied to different variables\n//' \n//' @param d delay in the formula I(x-->y)=I(x_{t-d};y_t|y_{t-1}) default: d=1\n//'\n//' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n//' @details\n//' \\code{rdi_single_run_conditioned} takes two random variables x and y as well as the parameter d to calculate the restricted direct information conditioned on variable z. \n//' @return a numeric value for the estimated condition mutual information between variable x and y conditioning on a third variable z \n//' @export\n// [[Rcpp::export]]\ndouble rdi_single_run_conditioned(SEXP x, SEXP y, SEXP z, SEXP z_delays, SEXP d, SEXP uniformalize) \n{ \n  NumericMatrix x_cpp(x); \n  NumericMatrix y_cpp(y); \n  NumericMatrix z_cpp(z); \n  \n  NumericVector z_delays_cpp(z_delays); \n  \n  int d_cpp = as<int>(d); \n  bool uniformalize_cpp = as<bool>(uniformalize); \n  \n  double rdi_single_run_conditioned_res = rdi_single_run_conditioned_cpp(x_cpp, y_cpp, z_cpp, z_delays_cpp, d_cpp, uniformalize_cpp);\n  return rdi_single_run_conditioned_res;\n}\n\n// ----------------------------------------------------------------------------------------------------------------------------------------------- //\n\n// Convert a NumericMatrix (R object) to an Armadillo matrix (C++ object)\n// //[[Rcpp::export]]\n// arma::mat R2armaMat_num(NumericMatrix rMat)\n// {\n//   arma::mat armaMat = arma::mat(rMat.begin(), rMat.nrow(), rMat.ncol(), false);\n//   return armaMat;\n// }\n\n//-------------------------------------------------------------------------------------------------------------------\n/*\ncalculate restricted direction information for all pairs of genes from the expr_data matrix\n*/\n//-------------------------------------------------------------------------------------------------------------------\n\n// [[Rcpp::export]]\nList extract_max_rdi_value_delay(NumericMatrix rdi_result, IntegerVector delays)\n{\n  \n  int i, j, k, max_delay = delays[0], n_genes = rdi_result.rows();\n  int delays_len = (int) rdi_result.cols() / n_genes; \n  double tmp, max_val;\n  \n  // NumericVector rdi_vec(delays_len);\n  NumericMatrix max_rdi_value(n_genes, n_genes);\n  IntegerMatrix max_rdi_delays(n_genes, n_genes);\n  \n  if(delays.length() != delays_len)\n  {\n    stop(\"Length of delays doesn't match up the rdi result\");\n    return -1; \n  }\n  for(i = 0; i < n_genes; i ++) \n  {\n    for(j = 0; j < n_genes; j ++)\n    {\n      if(i != j) \n      {\n        max_val = rdi_result(i, j); // deal with the case where there is only a single delay tested \n        for(k = 0; k < delays_len; k ++)\n        { \n          tmp = rdi_result(i, j + k * n_genes);\n          if(max_val < tmp) {\n            max_val = tmp;\n            max_delay = delays[k];\n          }\n        }\n        max_rdi_value(i, j) = max_val;\n        max_rdi_delays(i, j) = max_delay; \n      }\n    }\n  }\n  \n  return List::create(Rcpp::Named(\"max_rdi_value\") = max_rdi_value, \n                      Rcpp::Named(\"max_rdi_delays\") = max_rdi_delays);\n}\n\n/** \nlibrary(InformationEstimator)\nextract_max_rdi_value_delay(AT1_RDI_parallel_res, c(5, 10, 15))\n*/\n\n// [[Rcpp::export]]\nList calculate_rdi_cpp(NumericMatrix& expr_data, IntegerVector delays, IntegerMatrix& super_graph, IntegerVector& turning_points, int method, bool uniformalize = false) //, method: 1 rdi; 2: lmi \n{\n  const int n_genes(expr_data.cols()), n_samples(expr_data.rows());\n\n  if(max(delays) > n_samples)\n  {\n    stop(\"Number of samples has to be larger than the delays\"); \n    return -1; \n  }\n  \n  IntegerMatrix max_rdi_delays(n_genes, n_genes); // declare max_rdi_delays when turning_points provided \n  \n  // Convert arguments to Armadillo objects\n  // const arma::mat data = R2armaMat_num(expr_data); // Continuous data does not need reindexing R->C++\n  // const int n_pairs = (int)(((double)n_genes/2.0) * (double)(n_genes+1));\n  \n  // // Number of cores to use\n  // //const int cores = sysconf(_SC_NPROCESSORS_ONLN);\n  // omp_set_num_threads(cores);\n  \n  // Compute RDI in parallel\n  int delays_len = delays.length(); \n  \n  int RDI_ncols; \n  if(turning_points.length() == n_genes) \n  {\n    RDI_ncols = n_genes; \n  } else {\n    RDI_ncols = n_genes * delays_len; \n  }\n\n  NumericMatrix RDI(n_genes, RDI_ncols);     \n  std::fill(RDI.begin(), RDI.end(), 0); //NA_REAL \n  NumericMatrix expr_1(n_samples, 1), expr_2(n_samples, 1);\n  \n  // this part maybe slow if we do paralleling because RDI matrix is huge \n  \n  int i, j, k; \n  IntegerVector current_pair; \n  // #pragma omp parallel for shared(n_genes, expr_data, delays_len, RDI) private(i, j, k, expr_1, expr_2, _) //schedule(dynamic) default(none) //collapse(2) , _\n  for(int super_graph_ind = 0; super_graph_ind < super_graph.rows(); super_graph_ind ++) \n  {\n    current_pair = super_graph(Range(super_graph_ind, super_graph_ind), _);\n    i = current_pair[0]; j = current_pair[1]; \n    \n    expr_1 = expr_data(_, Range(i, i)); //Range(0, n_genes - 1)\n    expr_2 = expr_data(_, Range(j, j)); //Range(0, n_genes - 1)\n\n    // int max_thread = omp_get_max_threads();\n    // omp_set_num_threads(max_thread);\n    // #pragma omp parallel for shared(delays_len, i, j, n_genes, expr_1, expr_2, RDI) private(k) //schedule(dynamic) default(none) //collapse(2) , _\n    \n    // if we provide turning_points estimation, we will use that to determine the time delay\n    if(turning_points.length() == n_genes) // !Rf_isNull(turning_points)\n    {\n      Rcout << \"using user provided information about time-delay \" << turning_points.length() << std::endl;\n      int current_delay = turning_points[i] - turning_points[j];\n      \n      if(i == j) \n      {\n        continue; // keep diagnoal as 0 \n      }\n\n      if(method == 1)\n      {\n        RDI(i, j) = rdi_single_run_cpp(expr_1, expr_2, current_delay, uniformalize); // how to deal with delays include multiple values?\n      }\n      else if(method == 2)\n      { // + k * n_genes\n        RDI(i, j) = lmi_single_run_cpp(expr_1, expr_2, current_delay, uniformalize); // how to deal with delays include multiple values?\n      }\n      max_rdi_delays(i, j) = current_delay;\n    } else {\n      for(k = 0; k < delays_len; ++ k)\n      {\n        if(i == j) \n        {\n          continue; // keep diagnoal as 0 \n        }\n        \n        if(method == 1)\n        {\n          RDI(i, j + k * n_genes) = rdi_single_run_cpp(expr_1, expr_2, delays[k], uniformalize); // how to deal with delays include multiple values?\n        }\n        else if(method == 2)\n        {\n          RDI(i, j + k * n_genes) = lmi_single_run_cpp(expr_1, expr_2, delays[k], uniformalize); // how to deal with delays include multiple values?\n        }\n      }\n    }\n  }\n\n  // perform the multiple run test (add a new argument to represent the vector for different runs)\n  if(turning_points.length() == n_genes) // !Rf_isNull(turning_points)\n  {\n    return List::create(Rcpp::Named(\"RDI\") = RDI, \n                        Rcpp::Named(\"delays\") = R_NilValue,\n                        Rcpp::Named(\"max_rdi_value\") = RDI, \n                        Rcpp::Named(\"max_rdi_delays\") = max_rdi_delays);\n  }\n  else{\n    // run extract_max_rdi_value_delay \n    List max_rdi_value_delay_list = extract_max_rdi_value_delay(RDI, delays); \n    \n    return List::create(Rcpp::Named(\"RDI\") = RDI, \n                        Rcpp::Named(\"delays\") = delays,\n                        Rcpp::Named(\"max_rdi_value\") = max_rdi_value_delay_list[\"max_rdi_value\"], \n                        Rcpp::Named(\"max_rdi_delays\") = max_rdi_value_delay_list[\"max_rdi_delays\"]);\n  }\n}\n\n//' @title\n//' calculate_rdi_cpp_wrap\n//' @description\n//' This function estimates the DIRECTED mutual information for all gene pairs in the expr_data matrix when you have a SINGLE run of the processes\n//' \n//' @param expr_data a matrix for all variables in a time-series where each row is a time point and each column is a variable (for example, a gene). \n//' The rows are ordered according to time, from earliest to latest. \n//' \n//' @param delays An integer vector storing the time delays between pairs of variables you would like to try. \n//' \n//' @param super_graph An integer matrix where each row is the variable IDs or gene pairs you would like to estimate restricted direct information (RDI) from. \n//'  \n//' @param turning_points Either 0 or a numeric vector describing the inflection point (linear trajectory) or branch point (bifurcation point) for each gene. \n//' If the turning_point for each gene is provided, the time delay will be estimated based on the turning point. \n//'\n//' @param method An integer of either 1 or 2 to determine which information metric will be used to quantify the causality. \n//' If method is 1, then lagged mutual information will be used; if method is 2, then the restricted direct information will be used. \n//'\n//' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n//' @details\n//' \\code{calculate_rdi_cpp_wrap} takes an expression matrix (expr_data) and possible gene pairs (encoded in super_graph) to estimate the restricted \n//' direct information based on the time delay which can be estimated from the turning_point vector. \n//' @return a numeric matrix of conditional RDI values for all possible pairs of genes from expr_data. If the gene pairs is not encoded in the super_graph, it will remain as 0 in the matrix.  \n//' @export\n// [[Rcpp::export]]\nList calculate_rdi_cpp_wrap(SEXP expr_data, SEXP delays, SEXP super_graph, SEXP turning_points, SEXP method, SEXP uniformalize) //, SEXP R_cores\n{ \n  NumericMatrix expr_data_cpp(expr_data); \n  IntegerVector delays_cpp(delays); \n  \n  IntegerMatrix super_graph_cpp(super_graph); \n  IntegerVector turning_points_cpp(turning_points);\n  int method_cpp = as<int>(method); \n  bool uniformalize_cpp = as<bool>(uniformalize); \n  \n  List rdi_list = calculate_rdi_cpp(expr_data_cpp, delays_cpp, super_graph_cpp, turning_points_cpp, method_cpp, uniformalize_cpp); //cores\n \n  return rdi_list;\n}\n\n/** \n library(InformationEstimator)\n sample_row = 30; sample_col = 50; \n noise = matrix(rnorm(mean = 0, sd = 1e-10, sample_row * sample_col), nrow = sample_col)\n\n test <- calculate_rdi(t(lung_exprs_AT1[1:30, 1:50]) + noise, c(5, 10, 15))\n */\n\n// max_rdi_delays could be double matrix in future (current IntegerMatrix)\n// [[Rcpp::export]]\nList extract_top_incoming_nodes_delays(NumericMatrix max_rdi_value, IntegerMatrix max_rdi_delays, int k = 1)\n{\n  int n_genes = max_rdi_value.rows(), i, j, current_k_ind;\n\n  NumericMatrix top_incoming_values(n_genes, k + 1);\n  IntegerMatrix top_incoming_delays(n_genes, k + 1), top_incoming_nodes(n_genes, k + 1);\n  \n  IntegerVector top_k_plus_1 = seq_len(k); top_k_plus_1.push_front(0); \n  \n  NumericVector x, x_ordered;\n  IntegerVector x_order_ind, top_k_plus_1_x_order_ind; \n\n\n  for(i = 0; i < n_genes; i ++)\n  {\n    max_rdi_value(i, i) = -5; // avoid diag is calculated as the incoming node \n    x = max_rdi_value(_, i); // first dimension is source; second dimension is target \n   \n    NumericVector x_ordered = clone(x).sort(true); // decreasing sort; rdi value from highest to lowest \n    x_order_ind =  match(x_ordered, x) - 1; // order starts from 1; all duplicated points get the same location \n\n    top_k_plus_1_x_order_ind = x_order_ind[top_k_plus_1];  // top k + 1  ordered genes index\n\n    max_rdi_value(i, i) = 0; // go back to the original value \n\n    for(j = 0; j < k + 1; j ++) // for each gene get the top k + 1 input node \n    {\n      current_k_ind = top_k_plus_1_x_order_ind[j]; // index x_ordered to get the top k's id (node index)\n\n      top_incoming_nodes(i, j) = current_k_ind; //top_k_plus_1_x_order_ind[j]; //[top_k_plus_1];\n      top_incoming_delays(i, j) = max_rdi_delays(current_k_ind, i); // current_k_ind: index for current maximal incoming gene\n      top_incoming_values(i, j) = x_ordered[j]; // rdi value  \n    }\n  } \n\n  return List::create(Rcpp::Named(\"top_incoming_nodes\") = top_incoming_nodes, \n              Rcpp::Named(\"top_incoming_delays\") = top_incoming_delays,\n              Rcpp::Named(\"top_incoming_values\") = top_incoming_values); \n}\n\n/**\nlibrary(InformationEstimator)\nsample_row = 30; sample_col = 50; \nnoise = matrix(rnorm(mean = 0, sd = 1e-10, sample_row * sample_col), nrow = sample_col)\ntest <- calculate_rdi(t(lung_exprs_AT1[1:30, 1:50]) + noise, c(5, 10, 15))\n\ntest_extract <- extract_top_incoming_nodes_delays(test$max_rdi_value, test$max_rdi_delays, k = 2)\n*/\n\n//-------------------------------------------------------------------------------------------------------------------\n/*\ncalculate conditional restricted direction information for all genes in a expression matrix \n*/\n//-------------------------------------------------------------------------------------------------------------------\n\nNumericMatrix calculate_conditioned_rdi_cpp(NumericMatrix& expr_data, IntegerMatrix& super_graph, \n                                            NumericMatrix& max_rdi_value, IntegerMatrix& max_rdi_delays, int k = 1, bool uniformalize = false) //, const int cores, const bool verbose\n{  \n  uniformalize = false; // we cannot support kernel density estimator > 2 dim \n  \n  if(expr_data.cols() < 3) {\n    stop(\"You need at least 3 genes to calculate conditional RDI values\");\n  }\n  \n  NumericVector k_ncol = NumericVector::create(k, expr_data.cols() - 2); // condition on at most n_gene - 2 incoming genes\n  k = min(k_ncol); // minal value from k and the column \n  \n  List top_incoming_nodes_delays_list = extract_top_incoming_nodes_delays(max_rdi_value, max_rdi_delays, k); \n\n  IntegerMatrix top_incoming_nodes = top_incoming_nodes_delays_list[\"top_incoming_nodes\"];\n  IntegerMatrix top_incoming_delays = top_incoming_nodes_delays_list[\"top_incoming_delays\"]; \n  NumericMatrix top_incoming_values = top_incoming_nodes_delays_list[\"top_incoming_values\"];  \n\n  int n_genes = expr_data.cols(), n_sample = expr_data.rows(), tau, total_length, id3, delay_id3, current_id_tmp, delay; //tmp: current target  \n\n  // valid_top_k_in_k_ordered is used to get the valid_top_k to the original order (setdiff function annoyingly sorts the data randomly)\n  IntegerVector gene_pair(2), tmp(1), valid_top_k_in_k(k), top_k_plus_1(k + 1), valid_top_k(k), valid_top_k_in_k_ordered, valid_delay_tmp(1); // optimize by setting the correct dimension   // ind_for_top_k(k),  \n  \n  NumericMatrix cRDI_mat(n_genes, n_genes), expr1_t, expr2_t, past_tmp; \n  std::fill(cRDI_mat.begin(), cRDI_mat.end(), 0); // initialize the cRDI matrix as 0 instead of C ++ NA values \n  \n  // OpenMP here too (not thread safe) \n  for(int i = 0; i < super_graph.rows(); i ++) \n  {\n    gene_pair = super_graph(i, _); \n    top_k_plus_1 = top_incoming_nodes(Range(gene_pair[1], gene_pair[1]), _); // top k incoming nodes \n    tmp = gene_pair[0]; // current incoming node \n\n    if(intersect(top_k_plus_1, tmp).length() > 0) // if current node is in the top_k_plus_1, remove k; else remove the smallest one \n    {\n      valid_top_k = setdiff(top_k_plus_1, tmp); // note that setdiff annoying the order of valid_top_k\n    }\n    else\n    {\n      tmp = top_k_plus_1[k]; // remove the smallest one, the k + 1 incoming node \n      valid_top_k = setdiff(top_k_plus_1, tmp); // note that setdiff annoyingly changes the order of valid_top_k\n    }\n    \n    // assign the node indices to ind_for_top_k\n    valid_top_k_in_k = match(valid_top_k, top_k_plus_1) - 1; // match gives order and the index (1 to k) starts from 1 -> valid_top_k_in_k\n    valid_top_k_in_k_ordered = clone(valid_top_k_in_k).sort(); // the index for top_k_plus_1 is sorted\n    valid_top_k = top_k_plus_1[valid_top_k_in_k_ordered]; // now the valid_top_k's value follows the ordering in the top_k_plus_1 \n    \n    if(valid_top_k.size() < k) \n    { // avoid any weird rare situation \n      Rcout << \"all incoming node has the same RDI value for gene pair \" << gene_pair[0] << \" and \" << gene_pair[1] << \". The target gene may have no expression.\" << std::endl;\n      cRDI_mat(gene_pair[0], gene_pair[1]) = max_rdi_value(gene_pair[0], gene_pair[1]); \n      continue;\n    }\n\n    IntegerVector valid_top_k_incoming_delays(k); // re-initialize this everytime because we have push_back later\n\n    // assign the valid top_k_incoming delays based on the sorted valid_top_k_in_k_ordered index \n    for(int j = 0; j < k; j ++ )\n    {\n      current_id_tmp = valid_top_k_in_k_ordered[j]; // range: 0 -> k - 1\n      valid_delay_tmp = top_incoming_delays(Range(gene_pair[1], gene_pair[1]), Range(current_id_tmp, current_id_tmp)); // the current_id_tmp^{th} delay value \n      valid_top_k_incoming_delays[j] = valid_delay_tmp[0]; \n    }\n\n    delay = max_rdi_delays(gene_pair[0], gene_pair[1]); // the delay corresponds to max RDI value for the current gene pair \n    valid_top_k_incoming_delays.push_back(delay); // identify and use the biggest value as the delay for all genes (to avoid index over-flow or out of boundary); last value corresponds to the delay for the current test gene pair \n    tau = max(valid_top_k_incoming_delays); \n    total_length = n_sample - tau; \n\n    expr1_t = expr_data(Range(tau - delay, tau - 1 - delay + total_length), Range(gene_pair[0], gene_pair[0])); \n    expr2_t = expr_data(Range(tau, tau - 1 + total_length), Range(gene_pair[1], gene_pair[1])); \n    NumericMatrix yz = expr_data(Range(tau - 1, tau  - 2 + total_length), Range(gene_pair[1], gene_pair[1])); // initialize yz as expr2_t with one time lag \n\n    // OpenMP here too \n    for(int id = 0; id < k; id ++)\n    {\n      id3 = valid_top_k[id];\n      delay_id3 = valid_top_k_incoming_delays[id];\n      past_tmp = expr_data(Range(tau - delay_id3, tau  - delay_id3 - 1 + total_length),\n                            Range(id3, id3));\n      yz = cbind(past_tmp, yz);\n    }\n\n    // std::ofstream file(\"test_cond_rdi.txt\");\n    // if (file.is_open())\n    // {\n    //   file << \"current super_graph ind is \" << gene_pair << '\\n';\n    //   file << \"expr1_t\\n\" << expr1_t << \"\\nexpr2_t\\n\" << expr2_t << \"\\nyz\\n\" << yz << '\\n';\n    // }\n\n    if(uniformalize == true) {\n      List uniformalize_res = ucmi_cpp(expr1_t, expr2_t, yz, 5, 1, 0, 0); // k, method, k_density, bw\n      cRDI_mat(gene_pair[0], gene_pair[1]) =  uniformalize_res[\"cmi_res\"];    \n    } else {\n      List cmi_res = cmi_cpp(expr1_t, expr2_t, yz);\n      cRDI_mat(gene_pair[0], gene_pair[1]) =  cmi_res[\"cmi_res\"];    \n    }\n  }\n  \n  // return results\n  return cRDI_mat; \n}\n\n//' @title\n//' calculate_conditioned_rdi_cpp_wrap\n//' @description\n//' This function estimates the conditional DIRECTED mutual information for all gene pairs in the expr_data matrix when you have a SINGLE run of the processes.\n//' \n//' @param expr_data a matrix for all variables in a time-series where each row is a time point and each column is a variable (for example, a gene). \n//' The rows are ordered according to time, from earliest to latest. \n//' \n//' @param super_graph An integer matrix where each row is the variable IDs or gene pairs you would like to estimate restricted direct information (RDI) from. \n//'  \n//' @param max_rdi_value A numeric matrix where each element corresponding to the maximal (identified from a series of time lags when calculating the rdi values) rdi value between two variables.  \n//' \n//' @param max_rdi_delays An integer matrix where each element corresponding to the time delay corresponding to the maximal (identified from a series of time lags when calculating the rdi values) rdi value between two variables.  \n//'\n//' @param k An integer for the number of incoming nodes to be conditioned on \n//'\n//' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n//' @details\n//' \\code{calculate_conditioned_rdi_cpp_wrap} takes an expression matrix (expr_data) and possible gene pairs (encoded in super_graph), as well as the matrices of maximal rdi value or the delays corresponding to those values to \n//' estimate the conditional restricted direct information, conditioning on top k incoming nodes. \n//' @return a numeric matrix of conditional RDI values for all possible pairs of genes from expr_data. If the gene pairs is not encoded in the super_graph, it will remain as 0 in the matrix.  \n//' @export\n// [[Rcpp::export]]\nNumericMatrix calculate_conditioned_rdi_cpp_wrap(SEXP expr_data, SEXP super_graph,\n                               SEXP max_rdi_value, SEXP max_rdi_delays, SEXP k, SEXP uniformalize) //, SEXP R_cores\n{\n  NumericMatrix expr_data_cpp(expr_data);\n  IntegerMatrix super_graph_cpp(super_graph);\n  NumericMatrix max_rdi_value_cpp(max_rdi_value);\n  IntegerMatrix max_rdi_delays_cpp(max_rdi_delays);\n  int k_cpp = as<int>(k);\n  bool uniformalize_cpp = as<int>(uniformalize);\n  \n  NumericMatrix cRDI = calculate_conditioned_rdi_cpp(expr_data_cpp, super_graph_cpp, max_rdi_value_cpp, max_rdi_delays_cpp, k_cpp, uniformalize_cpp); //cores\n  return cRDI;\n}\n\n/**\nlibrary(InformationEstimator)\ndim(lung_exprs_AT1)\n \nsample_row = 123; sample_col = 218; \nset.seed(2017)\nnoise = matrix(rnorm(mean = 0, sd = 1e-10, sample_row * sample_col), nrow = sample_row)\na <- Sys.time()\nrdi_list <- calculate_rdi(lung_exprs_AT1[1:sample_row, 1:sample_col] + noise, c(5, 10, 15), method = 1)\nb <- Sys.time()\nrdi_time <- b - a \n  \ntop_delays <- extract_top_incoming_nodes_delays(rdi_list$max_rdi_value, rdi_list$max_rdi_delays, k = 1)\n   \ntmp <- expand.grid(1:sample_col, 1:sample_col, stringsAsFactors = F)\nsuper_graph <- tmp[tmp[, 1] != tmp[, 2], ] - 1 # convert to C++ index \n \nmax_rdi_value <- as.matrix(rdi_list$max_rdi_value); max_rdi_delays <- as.matrix(rdi_list$max_rdi_delays); \na <- Sys.time()\ncRDI <- calculate_conditioned_rdi_cpp_wrap(t(lung_exprs_AT1[1:sample_row, 1:sample_col]) + noise, as.matrix(super_graph), max_rdi_value, max_rdi_delays, 2L)\nb <- Sys.time()\ncrdi_time <- b - a \n \n# super_graph \na <- Sys.time()\ncRDI_R <- calculate_conditioned_rdi(t(lung_exprs_AT1[1:sample_row, 1:sample_col]), super_graph = NULL, rdi_list, 2L)\nb <- Sys.time()\nR_crdi_time <- b - a \n \n*/\n\n//' @title\n//' smooth_gene\n//' @description\n//' This subroutine takes a time-series data and returns a moving average for the data. \n//' \n//' @param expr_data a matrix for all variables in a time-series where each row is a time point and each column is a variable (for example, a gene). \n//' The rows are ordered according to time, from earliest to latest. \n//' \n//' @param window_size Integer value for the smoothing window used for calculating the moving average.  \n//'\n//' @details\n//' \\code{entropy} takes a integer of dimensions and then calculate the olume of a d-dimensional unit ball for Euclidean norm\n//' using the formula: 0.5 * d * log(pi) - log(gamma(0.5 * d + 1))\n//' It's implimented in C++, providing a (small) increase in speed over the R equivalent.\n//' @return a updated matrix with gene expression smoothed with window size equal to window_size\n//' @export\n// [[Rcpp::export]]\nNumericMatrix smooth_gene(NumericMatrix& expr_data, const int window_size = 40)\n{ // columns: genes; rows: cells \n  int win_range = expr_data.rows() - window_size;\n  NumericMatrix expr_data_smooth(expr_data(Range(0, win_range), _));\n  \n  NumericVector tmp(win_range + 1), tmp_1;\n  for(int i = 0; i < expr_data.cols(); i ++) // genes \n  {\n    for(int j = 0; j <= win_range; j ++) // cells\n    {\n      tmp_1 = expr_data(Range(j, j + window_size - 1), Range(i, i)); \n      tmp[j] = mean(tmp_1);\n    }\n    expr_data_smooth(_, i) = tmp;\n  }\n  \n  return expr_data_smooth;\n}\n\n/**\nrun_new_dpt <- function(cds, norm_method = 'none', root = NULL, color_by = 'Cell_type'){\n  message('root should be the id to the cell not the cell name ....')\n  norm_data <- monocle:::normalize_expr_data(cds, norm_method = norm_method)\n  norm_data <- t(norm_data)\n  duplicated_genes <- which(base::duplicated.array(norm_data))\n  norm_data[duplicated_genes, 1] <- norm_data[duplicated_genes, 1] + rnorm(length(duplicated_genes), 0, 1)\n  dm <- DiffusionMap(norm_data)\n  dpt <- DPT(dm)\n  ts <- dm@transitions\n  M <- destiny:::accumulated_transitions(dm)\n  if(is.null(root)){\n  }\n  else{\n    dm <- DiffusionMap(norm_data)\n    dpt <- DPT(dm, tips = root)\n  }\n  if('Hours' %in% colnames(pData(cds)))\n    pData(cds)$Hours <- pData(cds)[, color_by]\n  p1 <- qplot(DM$DC1, DM$DC2, colour = pData(cds)$Hours)\n  branch <- dpt@branch\n  if(is.null(root))\n    root <- which.min(pData(cds)$Pseudotime)\n  pt <- dpt[root, ]\n  dp_res <- list(dm = dm, pt = pt, ts = ts, M = M, ev = dm@eigenvectors, p1 = p1, branch = branch)\n  return(dp_res)\n}\n\nmessage('test di_single_run_cpp')\nlibrary(InformationEstimator)\na <- Sys.time()\ndi_single_run(as.matrix(XYZ[, 1]), as.matrix(XYZ[, 2]), 10)\ndi_single_run(as.matrix(XYZ[, 1]), as.matrix(XYZ[, 3]), 10)\ndi_single_run(as.matrix(XYZ[, 2]), as.matrix(XYZ[, 3]), 10)\nb <- Sys.time()\nb - a \n# 11.56868 mins\n\n# 0.00824910072759\n# 0.00761374668366\n# 0.00794952458964\n \nmessage('test di_multiple_run_cpp')\nlibrary(InformationEstimator)\nrdi_many_runs(as.matrix(XYZ[, 1:2]), as.matrix(XYZ[, 2:3]))\nrdi_many_runs(as.matrix(XYZ[, 2:3]), as.matrix(XYZ[, 1:2]))\nrdi_many_runs(as.matrix(XYZ[, c(1, 2)]), as.matrix(XYZ[, c(2, 3)]))\n\nmessage('test di_single_run_conditioned_cpp')\nlibrary(InformationEstimator)\na <- Sys.time()\ndi_single_run_conditioned(as.matrix(XYZ[, 1]), as.matrix(XYZ[, 2]), as.matrix(XYZ[, 3]))\ndi_single_run_conditioned(as.matrix(XYZ[, 1]), as.matrix(XYZ[, 3]), as.matrix(XYZ[, 2]))\ndi_single_run_conditioned(as.matrix(XYZ[, 2]), as.matrix(XYZ[, 3]), as.matrix(XYZ[, 1]))\nb <- Sys.time()\nb - a\n\n# Time difference of 13.76443 mins\n\nmessage('test rdi_single_run_cpp')\nlibrary(InformationEstimator)\na <- Sys.time()\nrdi_single_run(as.matrix(XYZ[, 1]), as.matrix(XYZ[, 2]), 1)\nrdi_single_run(as.matrix(XYZ[, 1]), as.matrix(XYZ[, 3]), 1)\nrdi_single_run(as.matrix(XYZ[, 2]), as.matrix(XYZ[, 3]), 1)\nb <- Sys.time()\nb - a\n# \n# 0.0129632127358\n# 0.00873069345257\n# 0.0104163795216\n\n# Time difference of 2.090866 mins\n\nmessage('test rdi_single_run_conditioned_cpp')\nlibrary(InformationEstimator)\na <- Sys.time()\nrdi_single_run_conditioned(as.matrix(XYZ[, 1]), as.matrix(XYZ[, 2]), as.matrix(XYZ[, 3]), 1L, 1L)\nrdi_single_run_conditioned(as.matrix(XYZ[, 1]), as.matrix(XYZ[, 3]), as.matrix(XYZ[, 2]), 1L, 1L)\nrdi_single_run_conditioned(as.matrix(XYZ[, 2]), as.matrix(XYZ[, 3]), as.matrix(XYZ[, 1]), 1L, 1L)\nb <- Sys.time()\nb - a\n\nlibrary(InformationEstimator)\ntest_res <- smooth_gene(XYZ) #  \nqplot(test[, 1], test[, 2])\n\n# compare with the pairwise distance \nlibrary(InformationEstimator)\nN <- 10000\na <- Sys.time()\ncalculate_rdi(XYZ[1:N, ], 1.0, 1) # \nb <- Sys.time()\n\nlibrary(InformationEstimator)\nN <- 10000\na <- Sys.time()\ncalculate_rdi(XYZ[1:N, ], 1.0, 3L)\nb <- Sys.time()\n\ncalculate_conditioned_rdi(XYZ) # \n\n# test the neuron simulation dataset (RDI + cRDI)\n# test on the neuron simulation dataset (use three cells only first):\nload('/Users/xqiu/Dropbox (Personal)/Projects/Monocle2_revision/RData/fig3.RData')\n  \n# avoid duplicated cells\nexprs(nao_sim_cds)[2, 401] <- 0.001\nexprs(nao_sim_cds)[3, 801] <- 0.001\n\n# nao_sim_cds <- reduceDimension(nao_sim_cds, max_components = 3, norm_method = 'none', verbose = T, pseudo_expr = 0, scaling = F, auto_param_selection = F, initial_method = run_dpt, reduction_method = 'SimplePPT')\nnao_sim_cds <- orderCells(nao_sim_cds)\nplot_cell_trajectory(nao_sim_cds, color_by = 'State') + facet_wrap(~State)\nplot_cell_trajectory(nao_sim_cds, x = 2, y = 3, color_by = 'State') + facet_wrap(~State)\n\nnao_sim_cds <- orderCells(nao_sim_cds, root_state = 4)\ndimnames(nao_exprs_mat) <- dimnames(nao_sim_cds)\nnao_exprs_mat <- t(nao_exprs_mat)\nneuron_branch <- nao_exprs_mat[pData(nao_sim_cds)$State %in% c(4, 3), ]\nastrocyte_branch <- nao_exprs_mat[pData(nao_sim_cds)$State %in% c(4, 5), ]\noligodendrocyte_branch <- nao_exprs_mat[pData(nao_sim_cds)$State %in% c(4, 5), ]\n\nsave(file = '../../RData/simulation_data', neuron_branch, astrocyte_branch, oligodendrocyte_branch)\n\nlibrary(InformationEstimator)\nlibrary(monocle)\n\nnoise = matrix(rnorm(mean = 0, sd = 1e-10, 200 * 13), nrow = 200)\na <- Sys.time()\nres <- calculate_rdi(neuron_branch[1:200, ] + noise, 1:3, 1) # run rdi \nb <- Sys.time()\n\na <- Sys.time()\nRDI_parallel_res <- di::calculate_and_write_pairwise_dmi(neuron_branch[1:200, ], delays = 1:3, cores = detectCores() - 2, verbose = T)\nb <- Sys.time()\n\nlung <- load_lung()\na <- Sys.time()\nRDI_parallel_res <- di::calculate_and_write_pairwise_dmi(t(exprs(lung)), delays = c(5, 10, 15), cores = detectCores() - 2, verbose = T)\nb <- Sys.time()\n\nnoise = matrix(rnorm(mean = 0, sd = 1e-10, nrow(lung) * ncol(lung)), nrow = ncol(lung))\nres <- calculate_rdi(t(exprs(lung)) + noise, c(5, 10, 15), 1) # run rdi \n\na <- Sys.time()\nRDI_parallel_res <- calculate_rdi(t(exprs(lung)), delays = c(5, 10, 15), cores = detectCores() - 2, verbose = T)\nb <- Sys.time()\n\n*/\n// \n// // [[Rcpp::export]]\n// RcppExport SEXP loglik_MP(SEXP s_beta, SEXP s_x, SEXP s_nCpu) {\n//   NumericVector x(s_x);\n//   NumericVector beta(s_beta);\n//   int n_cpu = IntegerVector(s_nCpu)[0];\n//   double mu = beta[0];\n//   double sigma = beta[1];\n//   double ll = 0;\n//   omp_set_dynamic(0);         // Explicitly disable dynamic teams\n//   omp_set_num_threads(n_cpu); // Use n_cpu threads for all\n//   // consecutive parallel regions\n//   #pragma omp parallel\n//   {\n//     double ll_thread = 0;\n//   #pragma omp for \n//     for(int i = 0; i < x.length(); i++) {\n//       ll_thread -= (x[i] - mu)*(x[i] - mu);\n//     }\n//   #pragma omp critical\n//   {\n//     ll += ll_thread;\n//   }\n//   }\n//   ll *= 0.5/sigma/sigma;\n//   ll -= (0.5*log(2*M_PI) + log(sigma))*x.length();\n//   NumericVector result(1, ll);\n//   return result;\n// }\n\n// // Convert a NumericMatrix (R object) to an Armadillo matrix (C++ object)\n\n// // [[Rcpp::export]]\n// NumericMatrix calculate_rdi_cpp(NumericMatrix expr_data, const NumericVector delays, const int n_cores)\n// {\n// \n//   // Convert arguments to Armadillo objects\n//   const arma::mat data = R2armaMat_num(expr_data); // Continuous data does not need reindexing R->C++\n//   const int n_genes(data.n_cols), n_samples(data.n_rows);\n//   const int n_pairs = (int)(((double)n_genes/2.0) * (double)(n_genes+1));\n// \n//   // // Number of cores to use\n//   // //const int n_cores = sysconf(_SC_NPROCESSORS_ONLN);\n//   // omp_set_num_threads(n_cores);\n// \n//   // Compute RDI in parallel\n//   int delays_len = length(delays); \n//   NumericMatrix RDI = arma::mat(n_genes, n_genes * delays_len, arma::fill::zeros);\n//   \n//   // #pragma omp parallel for shared(expr_data,delays,RDI) private(i,j,k) schedule(dynamic) default(none) collapse(2)\n//   // this part maybe slow because RDI matrix is huge \n//   for(int i(0); i<n_genes; ++i)\n//   {\n//     for(int j(0); j<n_genes; ++j)\n//     {\n//      for(int k(0); j < delays_len; ++ k)\n//      {\n//        if(i == j) \n//        {\n//          RDI[i, i] = 0; \n//        }\n//        RDI(i, j + k * n_genes) = rdi_single_run_cpp(expr_data(, i), expr_data(, j), delays[k]); // how to deal with delays include multiple values?\n//      }\n//     }\n//   }\n//   \n//   return RDI;\n// }\n\n// [[Rcpp::plugins(openmp)]]\n\n// find the max delay for each pair\n\n// find top k incoming node: \n\n// perform the conditioinal RDI calculation \n// prepare the dataset in R before pass to C++ \n// \n// // [[Rcpp::export]]\n// NumericMatrix calculate_conditioned_rdi_cpp(NumericMatrix expr_data, CharacterMatrix super_graph, \n//  NumericMatrix top_k_plus_1_incoming_id, NumericMatrix rdi_res, const int k = 1, const int n_cores, \n//  const bool verbsoe = TRUE)\n// {\n//  if(verbsoe == TRUE) Rcout << \"Calculating the conditional restricted direct mutual information for each pair of genes\" << std::endl;\n//  k = min(k, ncol(expr_data) - 2); // minal value k and the column \n// \n//  NumericMatrix cRDI_mat(expr_data); \n//  for(int i = 0; i < super_graph.nrow(); i ++) \n//  {\n//    NumericVector index_name = super_graph(i, _);\n//    NumericVector gene_pair = super_graph(i, _); \n//    NumericVector top_k_plus_1 = top_k_plus_1_incoming_id(gene_pair[2], ); \n//    NumericVector valid_top_k = setdiff(top_k_plus_1, gene_pair[1]); \n// \n//    NumericMatrix expr1_t = genes_data(_, index_name[0]); \n//    NumericMatrix expr2_t = genes_data(_, index_name[1]); \n//    NumericMatrix past; \n//    for(int id = 0; id < length(top_k_gene_delay); id ++)\n//    {\n//      past = rbind(past, genes_data(_, top_k_plus_1[id])); \n//    }\n// \n//         cRDI_mat(i, j) = cmi(expr1_t, expr2_t, past); \n//  }\n// \n//  // return results\n// \n//  return cRDI_mat; \n// }\n// \n// \n\n\n// the non-deterministic crash bug (address 0x0, cause 'unknown') fixed \n\n// [[Rcpp::export]]\ndouble rdi_multiple_run_cpp(NumericMatrix& x, NumericMatrix& y, int d = 1, IntegerVector run_vec = 0, bool uniformalize = false) \n{\n  int Nx = x.rows(); int Ny = y.rows(); int run_len; // int Cx = x.cols(); int Cy = y.cols(); \n  \n  if(Nx != Ny)\n  {\n    stop(\"The number of time-series samples has to be the same for X and Y\");\n    return -1;\n  }\n\n  int run_max = max(run_vec); // run_vec: vector to represent the run, need to be just numeric numbers and starts from 0. \n  int current_ind = 0; // current initial index for storing new slice of data \n\n  NumericMatrix x_0_res, y_0_res, y_1_res, tmp; // matrix passed to cmi function\n  IntegerVector index_all = seq_len(run_vec.size()) - 1, current_run_ind; // cell index from 0 to maximal number of cells; run index corresponding to current run during iteration \n  \n  if(run_max == 0) \n  {\n    x_0_res = x(Range(0, Nx - d - 1), _); // x should only has 1 colum \n    y_0_res = y(Range(d, Ny - 1), _);\n    y_1_res = y(Range(d - 1, Nx - 2), _); \n  } else {\n\n    // correctly set the dimensionality for the x_0, y_0 and y_1 matrix \n    int tot_len = Nx - ( d * (run_max + 1) ); // number of samples minus, the delay times total number of runs \n\n    mat x_0(tot_len, 1), y_0(tot_len, 1), y_1(tot_len, 1); // arma matrix or colvec\n    \n    uvec pos; // arma uvec \n    vec vals; // arma vec \n\n    IntegerVector rng; \n\n    for(int i = 0; i <= run_max; i++) // concatenate the data \n    {\n      current_run_ind = index_all[run_vec == i]; // get the cells that belong to a particular run \n      run_len = current_run_ind.size(); \n\n      if(run_len < d)\n      {\n        stop(\"Each run has to have more samples than the designated 'delays'\");\n        return -1;\n      }\n\n      rng = Range(current_ind, current_ind + run_len - d - 1);\n      \n      pos = as<uvec>( rng ); \n\n      // assuming x is only one column (Cx, Cy is not used)\n      tmp = x(Range(min(current_run_ind), min(current_run_ind) + run_len - d - 1), Range(0, 0)); //x(Range(1, 2), Range(1, 1));\n      vals = as<vec>( tmp ); \n      x_0.elem(pos) = vals; \n\n      IntegerVector rng_vec = Range(min(current_run_ind), min(current_run_ind) + run_len - d - 1); \n\n      // for(int test_na = 0; test_na < vals.n_elem; test_na ++) \n      // {\n      //   if(arma::is_finite(vals[test_na]) == false) \n      //   {\n      //     Rcout << \"identify non-finite values for x_0 here; i is \" << i << \" rng_vec is \" << rng_vec << std::endl; \n      //   }\n      // }\n\n      tmp = y(Range(min(current_run_ind) + d, min(current_run_ind) + run_len - 1), Range(0, 0)); //x(Range(1, 2), Range(1, 1));\n      vals = as<vec>( tmp ); \n      y_0.elem(pos) = vals; \n\n      // for(int test_na = 0; test_na < vals.n_elem; test_na ++) \n      // {\n      //   if(arma::is_finite(vals[test_na]) == false) \n      //   {\n      //     Rcout << \"identify non-finite values for x_0 here; i is \" << i << \" rng_vec is \" << rng_vec << std::endl; \n      //   }\n      // }\n\n      tmp = y(Range(min(current_run_ind) + d - 1, min(current_run_ind) + run_len - 2), Range(0, 0)); //x(Range(1, 2), Range(1, 1));\n\n      vals = as<vec>( tmp ); \n      y_1.elem(pos) = vals; \n\n      // for(int test_na = 0; test_na < vals.n_elem; test_na ++) \n      // {\n      //   if(arma::is_finite(vals[test_na]) == false) \n      //   {\n      //     Rcout << \"identify non-finite values for x_0 here; i is \" << i << \" rng_vec is \" << rng_vec << std::endl; \n      //   }\n      // }\n\n      current_ind = current_ind + run_len - d; // move to the the next position after filling the current run (note that there is no - 1)\n    }\n\n    x_0_res = as<NumericMatrix>(wrap(x_0)); // this conversion have problems? \n    y_0_res = as<NumericMatrix>(wrap(y_0));\n    y_1_res = as<NumericMatrix>(wrap(y_1));\n\n  }  \n\n  // for(int test_na = 0; test_na < y_1_res.size(); test_na ++) \n  // {\n  //   if(arma::is_finite(y_1_res[test_na]) == false) \n  //   {\n  //     Rcout << \"identify non-finite values for y_1_res here\" << std::endl; \n  //   }\n  // }\n\n  if(uniformalize == true) {\n    List ucmi_res = ucmi_cpp(x_0_res, y_0_res, y_1_res, 5, 1, 0, 0); // k, method, k_density, bw\n    return ucmi_res[\"ucmi_res\"]; \n  } else {\n    List cmi_res = cmi_cpp(x_0_res, y_0_res, y_1_res);\n    return cmi_res[\"cmi_res\"]; \n  } \n}\n\n// [[Rcpp::export]]\nList calculate_rdi_multiple_run_cpp(NumericMatrix& expr_data, IntegerVector delays, IntegerVector run_vec,\n                                    IntegerMatrix& super_graph, IntegerVector turning_points = 0, int method = 1, bool uniformalize = false) //, method: 1 rdi; 2: lmi \n{\n  const int n_genes(expr_data.cols()), n_samples(expr_data.rows());\n\n  if(max(delays) > n_samples)\n  {\n    stop(\"Number of samples has to be larger than the delays\"); \n    return -1; \n  }\n  \n  IntegerMatrix max_rdi_delays(n_genes, n_genes);\n  \n  // Convert arguments to Armadillo objects\n  // const arma::mat data = R2armaMat_num(expr_data); // Continuous data does not need reindexing R->C++\n  // Rcout << \"n_genes is \" << n_genes << \" n_samples is \" << n_samples << \" delay length is \" << delays.length() << std::endl;\n  // const int n_pairs = (int)(((double)n_genes/2.0) * (double)(n_genes+1));\n  \n  // // Number of cores to use\n  // //const int cores = sysconf(_SC_NPROCESSORS_ONLN);\n  // omp_set_num_threads(cores);\n  \n  // Compute RDI in parallel\n  int delays_len = delays.length(); \n  \n  int RDI_ncols;  \n  if(turning_points.length() == n_genes) \n  {\n    RDI_ncols = n_genes; \n  } else {\n    RDI_ncols = n_genes * delays_len; \n  }\n\n  NumericMatrix RDI(n_genes, RDI_ncols);    \n  std::fill(RDI.begin(), RDI.end(), 0); \n  NumericMatrix expr_1(n_samples, 1), expr_2(n_samples, 1);\n\n  // this part maybe slow if we do paralleling because RDI matrix is huge \n  \n  int i, j, k; \n  IntegerVector current_pair; \n  // #pragma omp parallel for shared(n_genes, expr_data, delays_len, RDI) private(i, j, k, expr_1, expr_2, _) //schedule(dynamic) default(none) //collapse(2) , _\n  for(int super_graph_ind = 0; super_graph_ind < super_graph.rows(); super_graph_ind ++) \n  {\n    current_pair = super_graph(Range(super_graph_ind, super_graph_ind), _);\n    i = current_pair[0]; j = current_pair[1]; \n    \n    expr_1 = expr_data(_, Range(i, i)); //Range(0, n_genes - 1)\n    expr_2 = expr_data(_, Range(j, j)); //Range(0, n_genes - 1)\n\n    // int max_thread = omp_get_max_threads();\n    // omp_set_num_threads(max_thread);\n    // #pragma omp parallel for shared(delays_len, i, j, n_genes, expr_1, expr_2, RDI) private(k) //schedule(dynamic) default(none) //collapse(2) , _\n    if(turning_points.length() == n_genes) //!Rf_isNull(turning_points) \n    {\n      Rcout << \"using user provided information about time-delay \" << turning_points.length() << std::endl;\n      int current_delay = turning_points[i] - turning_points[j];\n\n      if(i == j) \n      {\n        continue; \n      }\n      \n      if(method == 1)\n      {\n        RDI(i, j) = rdi_multiple_run_cpp(expr_1, expr_2, current_delay, run_vec, uniformalize); // how to deal with delays include multiple values?\n      }\n      else if(method == 2)\n      {\n        RDI(i, j) = lmi_multiple_run_cpp(expr_1, expr_2, current_delay, run_vec, uniformalize); // how to deal with delays include multiple values?\n      } \n      max_rdi_delays(i, j) = current_delay;\n    } else {\n      for(k = 0; k < delays_len; ++ k)\n      {\n        if(i == j) \n        {\n          continue; // keep diagnoal as 0 \n        }\n        \n        if(method == 1)\n        {\n          RDI(i, j + k * n_genes) = rdi_multiple_run_cpp(expr_1, expr_2, delays[k], run_vec, uniformalize); // how to deal with delays include multiple values?\n        }\n        else if(method == 2)\n        {\n          RDI(i, j + k * n_genes) = lmi_multiple_run_cpp(expr_1, expr_2, delays[k], run_vec, uniformalize); // how to deal with delays include multiple values?\n        }\n      }\n    }\n  }\n\n  // perform the multiple run test (add a new argument to represent the vector for different runs)\n  if(turning_points.length() == n_genes) // Rf_isNull(turning_points) \n  {  \n    return List::create(Rcpp::Named(\"RDI\") = RDI, \n                        Rcpp::Named(\"delays\") = R_NilValue,\n                        Rcpp::Named(\"max_rdi_value\") = RDI, \n                        Rcpp::Named(\"max_rdi_delays\") = max_rdi_delays);\n  }\n  else{\n    // run extract_max_rdi_value_delay \n    List max_rdi_value_delay_list = extract_max_rdi_value_delay(RDI, delays); \n    \n    return List::create(Rcpp::Named(\"RDI\") = RDI, \n                        Rcpp::Named(\"delays\") = delays,\n                        Rcpp::Named(\"max_rdi_value\") = max_rdi_value_delay_list[\"max_rdi_value\"], \n                        Rcpp::Named(\"max_rdi_delays\") = max_rdi_value_delay_list[\"max_rdi_delays\"]);\n  }\n}\n\n//' @title\n//' calculate_rdi_multiple_run_cpp_wrap\n//' @description\n//' This function estimates the DIRECTED mutual information for all gene pairs in the expr_data matrix when you have a SINGLE run of the processes\n//' \n//' @param expr_data a matrix for all variables in a time-series where each row is a time point and each column is a variable (for example, a gene). \n//' The rows are ordered according to time, from earliest to latest. \n//' \n//' @param delays An integer vector storing the time delays between pairs of variables you would like to try. \n//' \n//' @param super_graph An integer matrix where each row is the variable IDs or gene pairs you would like to estimate restricted direct information (RDI) from. \n//'  \n//' @param turning_points Either 0 or a numeric vector describing the inflection point (linear trajectory) or branch point (bifurcation point) for each gene. \n//' If the turning_point for each gene is provided, the time delay will be estimated based on the turning point. \n//'\n//' @param method An integer of either 1 or 2 to determine which information metric will be used to quantify the causality. \n//' If method is 1, then lagged mutual information will be used; if method is 2, then the restricted direct information will be used. \n//'\n//' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n//' @details\n//' \\code{calculate_rdi_multiple_run_cpp_wrap}, similar to calculate_rdi_cpp_wrap, takes an expression matrix (expr_data) and possible gene pairs (encoded in super_graph) to estimate the restricted \n//' direct information based on the time delay which can be estimated from the turning_point vector. It, however, differs to calculate_rdi_cpp_wrap, in that it can concatenate different experiments (runs) into a single run of the data for causality estimation. \n//' @return a numeric matrix of conditional RDI values for all possible pairs of genes from expr_data. If the gene pairs is not encoded in the super_graph, it will remain as 0 in the matrix.  \n//' @export\n// [[Rcpp::export]]\nList calculate_rdi_multiple_run_cpp_wrap(SEXP expr_data, SEXP delays, SEXP run_vec, SEXP super_graph, SEXP turning_points, SEXP method, SEXP uniformalize) //, SEXP R_cores\n{ \n  NumericMatrix expr_data_cpp(expr_data); \n  IntegerVector delays_cpp(delays); \n  IntegerVector run_vec_cpp(run_vec); \n  \n  IntegerMatrix super_graph_cpp(super_graph); \n  IntegerVector turning_points_cpp(turning_points);\n  int method_cpp = as<int>(method); \n  bool uniformalize_cpp = as<bool>(uniformalize); \n  \n  List rdi_list = calculate_rdi_multiple_run_cpp(expr_data_cpp, delays_cpp, run_vec_cpp, super_graph_cpp, turning_points_cpp, method_cpp, uniformalize_cpp); //cores\n\n  return rdi_list;\n}\n\n/** \n library(InformationEstimator)\n sample_row = 30; sample_col = 50; \n noise = matrix(rnorm(mean = 0, sd = 1e-10, sample_row * sample_col), nrow = sample_col)\n\n test <- calculate_rdi(t(lung_exprs_AT1[1:30, 1:50]) + noise, c(5, 10, 15))\n */\n\n/** \n library(InformationEstimator)\n sample_row = 30; sample_col = 50; \n noise = matrix(rnorm(mean = 0, sd = 1e-10, sample_row * sample_col), nrow = sample_col)\n\n  sample_row = 123; sample_col = 218; \n  set.seed(2017)\n  noise = matrix(rnorm(mean = 0, sd = 1e-10, sample_row * sample_col), nrow = sample_row)\n  a <- Sys.time()\n  rdi_list <- calculate_rdi(lung_exprs_AT1[1:sample_row, 1:sample_col] + noise, c(5, 10, 15), method = 1)\n  b <- Sys.time()\n  rdi_time <- b - a \n    \n  top_delays <- extract_top_incoming_nodes_delays(rdi_list$max_rdi_value, rdi_list$max_rdi_delays, k = 1)\n     \n  tmp <- expand.grid(1:sample_col, 1:sample_col, stringsAsFactors = F)\n  super_graph <- tmp[tmp[, 1] != tmp[, 2], ] - 1 # convert to C++ index \n   \n // SEXP expr_data, SEXP delays, SEXP run_vec, SEXP super_graph, SEXP method\n  test <- calculate_rdi_multiple_run_cpp_wrap(t(lung_exprs_AT1[1:30, 1:50]) + noise, \n            c(5, 10, 15), rep(c(1, 2), each = 25), super_graph, method)\n*/\n\n//-------------------------------------------------------------------------------------------------------------------\n/*\ncalculate conditional restricted direction information for a single run\n*/\n//-------------------------------------------------------------------------------------------------------------------\n\n// [[Rcpp::export]]\ndouble rdi_multiple_runs_conditioned_cpp(NumericMatrix& x, NumericMatrix& y, \n                                         NumericMatrix& z, IntegerVector& z_delays, int d = 1, IntegerVector run_vec = 0, bool uniformalize = false) \n{\n  uniformalize = false; // we cannot support kernel density estimator > 2 dim \n  \n  int Nx = x.rows(); int Ny = y.rows(); int Nz = z.rows(); int run_len; // int Cx = x.cols(); int Cy = y.cols(); int Cz = z.cols(); \n  if(Nx != Ny | Nx != Nz)\n  {\n    stop(\"The number of time samples has to be the same for X and Y or Z\");\n    return -1;\n  }\n  \n  z_delays.push_back(d);\n  int tau = max(z_delays); \n\n  int run_max = max(run_vec); // run_vec: vector to represent the run, need to be just numeric numbers and starts from 0. \n  int current_ind = 0; // current initial index for storing new slice of data (--current_incoming_k)\n\n  NumericMatrix x_0_res, y_0_res, yz_res, tmp; // matrix passed to cmi function\n  IntegerVector index_all = seq_len(run_vec.size()) - 1, current_run_ind; // cell index from 1 to maximal number of cells; cell index corresponding to current run during iteration \n\n  if(run_max == 0) // note that run id starts from 0 \n  {\n    int tot_len = x.rows() - tau;  \n    \n    yz_res = y(Range(tau - 1, tau - 2 + tot_len), _);\n    \n    NumericMatrix tmp; \n    \n    // OpenMP here too \n    // int max_thread = omp_get_max_threads();\n    // omp_set_num_threads(max_thread);\n    // #pragma omp parallel for shared(z, tau, z_delays, tot_len) private(j, tmp, yz) //schedule(dynamic) default(none) //collapse(2) , _\n      \n    // using cbind\n    for(int j = 0; j < z.cols(); j ++ )\n    {\n      tmp = z(Range(tau - z_delays[j], tau - z_delays[j] + tot_len - 1), Range(j, j));\n      yz_res = cbind(tmp, yz_res);\n    } \n    \n    x_0_res = x(Range(tau - d, tau - d + tot_len - 1), _);\n    y_0_res = y(Range(tau, tau + tot_len - 1), _);\n\n  } else {\n    mat x_0, y_0; // pre-define the size of the matrix: (1000, 2) \n    \n    uvec pos; //unsigned vector \n    vec vals; \n\n    int tot_len = Nx - tau * (run_max + 1); \n\n    mat yz(tot_len, z.cols() + 1); // tot_len: number of cells in total across all runs; z.col() + 1: number of top k incoming nodes and y vector \n\n    for(int i = 0; i <= run_max; i++) // concatenate the data \n    {\n      current_run_ind = index_all[run_vec == i]; // get the cells that belong to a particular run \n      run_len = current_run_ind.size();\n\n      if(current_run_ind.size() < d)\n      {\n        stop(\"Each run has to have more samples than the designated 'delays'\");\n        return -1;\n      }\n      tot_len = run_len - tau; // x.rows() \n      \n      // prepare the value for yz (only the y values)\n      NumericMatrix locs_tmp(2, tot_len); // first row: row index; second row: column index; each column is a coordinate\n      locs_tmp(0, _) = Range(current_ind, current_ind + tot_len - 1);\n      // we could change the index below to the maximal value \n      locs_tmp(1, _) = rep(0, tot_len); \n      umat locs = as<umat>( locs_tmp );  \n      uvec eids = sub2ind( size(yz), locs ); // Obtain Element IDs\n            \n      // pos = as<uvec>(Range(current_ind, current_ind + tot_len - 1)); \n      tmp = y(Range(min(current_run_ind) + tau - 1, min(current_run_ind) + tau - 2 + tot_len), Range(0, 0)); // x(Range(min(current_run_ind), min(current_run_ind) + Nx - d - 1), Range(1, 1)); //x(Range(1, 2), Range(1, 1));\n\n      vals = as<vec>( tmp ); \n      yz.elem( eids ) = vals;\n           \n      // OpenMP here too \n      // int max_thread = omp_get_max_threads();\n      // omp_set_num_threads(max_thread);\n      // #pragma omp parallel for shared(z, tau, z_delays, tot_len) private(j, tmp, yz) //schedule(dynamic) default(none) //collapse(2) , _\n        \n      // we could change the index below \n      for(int j = 0; j < z.cols(); j ++ )\n      {\n        locs_tmp(1, _) = rep(j + 1, tot_len); // first column belong to y values so starting from the second column \n        umat locs = as<umat>( locs_tmp );  \n\n        uvec eids = sub2ind( size(yz), locs ); // Obtain Element IDs\n        tmp = z(Range(min(current_run_ind) + tau - z_delays[j], min(current_run_ind) + tau - z_delays[j] + tot_len - 1), Range(j, j));\n        vals = as<vec>( tmp ); \n        \n        yz.elem( eids ) = vals;        \n      } \n\n      tmp = x(Range(min(current_run_ind) + tau - d, min(current_run_ind) + tau - d + tot_len - 1), Range(0, 0));\n      vals = as<vec>( tmp );\n      x_0 = join_cols(x_0, vals); //.elem(pos) = vals;\n      \n      tmp = y(Range(min(current_run_ind) + tau, min(current_run_ind) + tau + tot_len - 1), Range(0, 0));      \n      vals = as<vec>( tmp );\n      y_0 = join_cols(y_0, vals); //.elem(pos) = vals;    \n\n      current_ind += tot_len; // update the index (note that there is no - 1)\n    }\n\n    x_0_res = as<NumericMatrix>(wrap(x_0));\n    y_0_res = as<NumericMatrix>(wrap(y_0));\n    yz_res = as<NumericMatrix>(wrap(yz)); \n\n  }\n  \n  if(uniformalize == true) {\n    List ucmi_res = ucmi_cpp(x_0_res, y_0_res, yz_res, 5, 1, 0, 0); // k, method, k_density, bw\n    return ucmi_res[\"ucmi_res\"]; \n  } else {\n    List cmi_res = cmi_cpp(x_0_res, y_0_res, yz_res);\n    return cmi_res[\"cmi_res\"]; \n  } \n}\n\n//' @title\n//' This function simulates the CONDITIONED DIRECTED mutual information from X to Y CONDITIONED ON Z when you have a SINGLE run of the processes\n//' @description\n//' This subroutine calculates the volume of a d-dimensional unit ball for Euclidean norm\n//' \n//' @param x one random variable from the time-series data\n//' \n//' @param y another random variable from the time-series data\n//' \n//' @param z z is a dataframe or matrix consisting of the data for different variables\n//' \n//' @param z_delays z_delay is also a dataframe or matrix consisting of the delays to be applied to different variables\n//' \n//' @param d delay in the formula I(x-->y)=I(x_{t-d};y_t|y_{t-1}) default: d=1\n//'\n//' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n//' @details\n//' \\code{rdi_single_run_conditioned} takes two random variables x and y as well as the parameter n to calculate the restricted direct information conditioned on variable z. \n//' @return a matrix for the condition mutual information estimators between all pairwise variables (x, y) in the data matrix x, y\n//' @export\n// [[Rcpp::export]]\ndouble rdi_multiple_runs_conditioned(SEXP x, SEXP y, SEXP z, SEXP z_delays, SEXP d, SEXP run_vec, SEXP uniformalize) \n{ \n  NumericMatrix x_cpp(x); \n  NumericMatrix y_cpp(y); \n  NumericMatrix z_cpp(z); \n  \n  IntegerVector z_delays_cpp(z_delays); \n  IntegerVector run_vec_cpp(run_vec); \n  \n  int d_cpp = as<int>(d); \n  bool uniformalize_cpp = as<bool>(uniformalize); \n  double rdi_single_run_conditioned_res = rdi_multiple_runs_conditioned_cpp(x_cpp, y_cpp, z_cpp, z_delays_cpp, d_cpp, run_vec_cpp, uniformalize_cpp);\n\n  return rdi_single_run_conditioned_res;\n}\n\n// test all the above functions in the following \n\n/** \n library(InformationEstimator)\n sample_row = 30; sample_col = 50; \n noise = matrix(rnorm(mean = 0, sd = 1e-10, sample_row * sample_col), nrow = sample_col)\n\n  sample_row = 123; sample_col = 218; \n  set.seed(2017)\n  noise = matrix(rnorm(mean = 0, sd = 1e-10, sample_row * sample_col), nrow = sample_row)\n  a <- Sys.time()\n  rdi_list <- calculate_rdi(lung_exprs_AT1[1:sample_row, 1:sample_col] + noise, c(5, 10, 15), method = 1)\n  b <- Sys.time()\n  rdi_time <- b - a \n    \n  top_delays <- extract_top_incoming_nodes_delays(rdi_list$max_rdi_value, rdi_list$max_rdi_delays, k = 1)\n     \n  tmp <- expand.grid(1:sample_col, 1:sample_col, stringsAsFactors = F)\n  super_graph <- tmp[tmp[, 1] != tmp[, 2], ] - 1 # convert to C++ index \n   \n // SEXP expr_data, SEXP delays, SEXP run_vec, SEXP super_graph, SEXP method\n  test <- rdi_multiple_runs_conditioned_cpp(t(lung_exprs_AT1[1:30, 1:50]) + noise, \n            c(5, 10, 15), rep(c(1, 2), each = 25), super_graph, method)\n*/\n\n//-------------------------------------------------------------------------------------------------------------------\n/*\ncalculate conditional restricted direction information for all genes in a expression matrix \n*/\n//-------------------------------------------------------------------------------------------------------------------\n\n// [[Rcpp::export]]\nNumericMatrix calculate_conditioned_rdi_multiple_run_cpp(NumericMatrix& expr_data, IntegerMatrix& super_graph, \n                                            NumericMatrix& max_rdi_value, IntegerMatrix& max_rdi_delays, IntegerVector run_vec = 0, int k = 1, bool uniformalize = false) //, const int cores, const bool verbose\n{\n  uniformalize = false; // we cannot support kernel density estimator > 2 dim \n  \n  if(expr_data.cols() < 3) {\n    stop(\"You need at least 3 genes to calculate conditional RDI values\");\n  }\n  \n  NumericVector k_ncol = NumericVector::create(k, expr_data.cols() - 2); // conditioned at most n - 2 genes (2: two current testing genes)\n  k = min(k_ncol); // minal value from k and the column \n  \n  List top_incoming_nodes_delays_list = extract_top_incoming_nodes_delays(max_rdi_value, max_rdi_delays, k); // get the top k incoming node and the corresponding delays \n\n  IntegerMatrix top_incoming_nodes = top_incoming_nodes_delays_list[\"top_incoming_nodes\"];\n  IntegerMatrix top_incoming_delays = top_incoming_nodes_delays_list[\"top_incoming_delays\"]; \n  NumericMatrix top_incoming_values = top_incoming_nodes_delays_list[\"top_incoming_values\"];  \n\n  int n_genes = expr_data.cols(), n_sample = expr_data.rows(), current_id_tmp, delay; // tau, total_length, id3, delay_id3, tmp: current target  \n\n  // valid_top_k_in_k_ordered is used to get the valid_top_k to the original order (setdiff function annoyingly sorts the data randomly)\n  IntegerVector gene_pair(2), tmp(1), valid_top_k_in_k(k), top_k_plus_1(k + 1), valid_top_k(k), valid_top_k_in_k_ordered, valid_delay_tmp(1); // ind_for_top_k(k), little computational gain by setting the correct dimension  \n\n  NumericMatrix cRDI_mat(n_genes, n_genes), expr1_t, expr2_t, past_tmp; \n  std::fill(cRDI_mat.begin(), cRDI_mat.end(), 0); // initialize the cRDI matrix as 0 instead of the C ++ NA values (so the diagnoal will be 0 values)\n  \n  // OpenMP here too (not thread safe) \n  for(int i = 0; i < super_graph.rows(); i ++) \n  {\n    gene_pair = super_graph(i, _); \n    top_k_plus_1 = top_incoming_nodes(Range(gene_pair[1], gene_pair[1]), _); // top k incoming nodes \n    tmp = gene_pair[0]; // get the incoming node \n\n    if(intersect(top_k_plus_1, tmp).length() > 0) // if current node tmp is in the top_k_plus_1, remove tmp; else remove the smallest one \n    {\n      valid_top_k = setdiff(top_k_plus_1, tmp);\n    }\n    else\n    {\n      tmp = top_k_plus_1[k]; // remove the smallest one (k + 1 points in total)\n      valid_top_k = setdiff(top_k_plus_1, tmp); \n    }\n    \n    // assign the node indices to ind_for_top_k\n    valid_top_k_in_k = match(valid_top_k, top_k_plus_1) - 1; // match gives order and the index (1 to k) starts from 1 -> valid_top_k_in_k\n    valid_top_k_in_k_ordered = clone(valid_top_k_in_k).sort(); // the index for top_k_plus_1 is sorted\n    valid_top_k = top_k_plus_1[valid_top_k_in_k_ordered]; // now the valid_top_k's value follows the ordering in the top_k_plus_1 \n\n    if(valid_top_k.size() < k) \n    { // avoid any weird rare situation (all incoming RDI value are 0)\n      cRDI_mat(gene_pair[0], gene_pair[1]) = max_rdi_value(gene_pair[0], gene_pair[1]); \n      continue;\n    }\n    \n    IntegerVector valid_top_k_incoming_delays(k); // re-initialize this everytime because we have push_back later\n\n    // assign the valid top_k_incoming delays based on the sorted valid_top_k_in_k_ordered index \n    for(int j = 0; j < k; j ++ )\n    {\n      current_id_tmp = valid_top_k_in_k_ordered[j]; // range: 0 -> k - 1\n      valid_delay_tmp = top_incoming_delays(Range(gene_pair[1], gene_pair[1]), Range(current_id_tmp, current_id_tmp)); // the current_id_tmp^{th} delay value \n      valid_top_k_incoming_delays[j] = valid_delay_tmp[0]; \n    }\n\n    delay = max_rdi_delays(gene_pair[0], gene_pair[1]); // the delay corresponds to max RDI value for the current gene pair \n \n    // use rdi_conditioned to calculate the values: \n    NumericMatrix x = expr_data(_, Range(gene_pair[0], gene_pair[0]));\n    NumericMatrix y = expr_data(_, Range(gene_pair[1], gene_pair[1]));\n\n    // prepare the data for all top-k incoming nodes' expression data \n    NumericMatrix z(n_sample, k);\n    for (int i = 0; i < valid_top_k.size(); i++) {\n      z(_,i) = expr_data(_, valid_top_k(i));\n    }\n\n    cRDI_mat(gene_pair[0], gene_pair[1])  = rdi_multiple_runs_conditioned_cpp(x, y, z, valid_top_k_incoming_delays, delay, run_vec, uniformalize); \n  }\n  \n  // return results\n  return cRDI_mat; \n}\n\n//' @title\n//' calculate_conditioned_rdi_multiple_run_wrap\n//' @description\n//' This function estimates the conditional DIRECTED mutual information for all gene pairs in the expr_data matrix when you have a SINGLE run of the processes.\n//' \n//' @param expr_data a matrix for all variables in a time-series where each row is a time point and each column is a variable (for example, a gene). \n//' The rows are ordered according to time, from earliest to latest. \n//' \n//' @param super_graph An integer matrix where each row is the variable IDs or gene pairs you would like to estimate restricted direct information (RDI) from. \n//'  \n//' @param max_rdi_value A numeric matrix where each element corresponding to the maximal (identified from a series of time lags when calculating the rdi values) rdi value between two variables.  \n//' \n//' @param max_rdi_delays An integer matrix where each element corresponding to the time delay corresponding to the maximal (identified from a series of time lags when calculating the rdi values) rdi value between two variables.  \n//'\n//' @param run_vec An integer vector keeping the run id for each sample. \n//'\n//' @param k An integer for the number of incoming nodes to be conditioned on.\n//'\n//' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n//' @details\n//' \\code{calculate_conditioned_rdi_multiple_run_wrap}, similar to calculate_conditioned_rdi_cpp_wrap, takes an expression matrix (expr_data) and possible gene pairs (encoded in super_graph), as well as the matrices of maximal rdi value or the delays corresponding to those values to \n//' estimate the conditional restricted direct information, conditioning on top k incoming nodes. It, however, differs to calculate_conditioned_rdi_cpp_wrap, in that it can concatenate different experiments (runs) into a single run of the data for causality estimation. \n//' @return a numeric matrix of conditional RDI values for all possible pairs of genes from expr_data. If the gene pairs is not encoded in the super_graph, it will remain as 0 in the matrix.  \n//' @export\n// [[Rcpp::export]]\nNumericMatrix calculate_conditioned_rdi_multiple_run_wrap(SEXP expr_data, SEXP super_graph, SEXP max_rdi_value, SEXP max_rdi_delays, SEXP run_vec, SEXP k, SEXP uniformalize) //, SEXP R_cores\n{ \n  NumericMatrix expr_data_cpp(expr_data), max_rdi_value_cpp(max_rdi_value); \n  IntegerMatrix super_graph_cpp(super_graph), max_rdi_delays_cpp(max_rdi_delays); \n\n  IntegerVector run_vec_cpp(run_vec); \n  int k_cpp = as<int>(k); \n  bool uniformalize_cpp = as<bool>(uniformalize); \n  \n  NumericMatrix crdi_res = calculate_conditioned_rdi_multiple_run_cpp(expr_data_cpp, super_graph_cpp, max_rdi_value_cpp, max_rdi_delays_cpp, run_vec_cpp, k_cpp, uniformalize_cpp); //cores\n\n  return crdi_res;\n}\n\n// implement UMI here \n\n\n/*** R\nrm(list = ls())\n\n library(devtools)\n load_all()\n library(monocle)\n library(plyr)\n lung <- load_lung()\n lung <- buildBranchCellDataSet(lung, progenitor_method = 'duplicate')\n data <- t(exprs(lung))\n run_vec <- as.numeric(revalue(pData(lung)$Branch, c(\"Y_1\" = 1, \"Y_30\" = 2)))\n noise = matrix(rnorm(mean = 0, sd = 1e-1, nrow(data) * ncol(data)), nrow = nrow(data))\n sample_gene <- 10; sample_cell <- 200\n data_sampled <- data[1:sample_cell, 1:sample_gene] + noise[1:sample_cell, 1:sample_gene]\n a <- Sys.time()\n rdi_list <- calculate_rdi(data_sampled, c(1, 2, 3), method = 1)\n b <- Sys.time()\n rdi_time <- b - a \n top_delays <- extract_top_incoming_nodes_delays(rdi_list$max_rdi_value, rdi_list$max_rdi_delays, k = 1)\n tmp <- expand.grid(1:sample_gene, 1:sample_gene, stringsAsFactors = F)\n super_graph <- tmp[tmp[, 1] != tmp[, 2], ] - 1 # convert to C++ index \n library(devtools)\n load_all()\n library(monocle)\n library(plyr)\n con_rid_res_test <- calculate_multiple_run_conditioned_rdi_wrap(data_sampled, as.matrix(super_graph), as.matrix(rdi_list$max_rdi_value), as.matrix(rdi_list$max_rdi_delays), run_vec[1:sample_cell] - 1, 1)\n test_extract <- extract_top_incoming_nodes_delays(rdi_list$max_rdi_value, rdi_list$max_rdi_delays, k = 1)\n calculate_rdi_multiple_run_cpp_wrap(data_sampled, c(1, 2, 3), run_vec[1:sample_cell] - 1, as.matrix(super_graph), 1)\n duplicated()\n calculate_rdi_multiple_run_cpp_wrap(data_sampled, 1:3, rep(0, length(run_vec)), as.matrix(super_graph), 1)\n\nlibrary(Scribe)\nlibrary(devtools)\nload_all('~/Dropbox (Personal)/Projects/Causal_network/causal_network/Cpp/di-grn/Scribe')\nlibrary(monocle)\n\nload(\"/Users/xqiu/Dropbox (Cole Trapnell's Lab)/Monocle 2/first_revision/Monocle2_revision/RData/fig3.RData\") # cds data\nload('/Users/xqiu/Dropbox (Personal)/Projects/Causal_network/causal_network/RData/neuron_network') # network data\n\n# neuron_network not exist\nneuron_network$Type <- c('Neuron', 'Oligo', 'Astro', 'Neuron', 'AO',\n                        'Neuron', 'Neuron', 'Neuron', 'Neuron', \"Neuron\",\n                        'AO', 'AO', 'Astro', 'Oligo', 'Olig', 'Astro',\n                        'Astro', 'Astro', 'Olig', 'Astro', 'Oligo')\n\n#\nfData(neuron_sim_cds)$gene_short_name <- fData(neuron_sim_cds)$gene_short_names\nfData(na_sim_cds)$gene_short_name <- fData(na_sim_cds)$gene_short_names\n\ngene_name_vec <- c('Pax6', 'Mash1', 'Brn2', 'Zic1', 'Tuj1', 'Hes5', 'Scl', 'Olig2', 'Stat3', 'Myt1L', 'Aldh1L', 'Sox8', 'Mature')\n\ndebug(rdi_crdi_pseudotime)\nrdi_crdi_pseudotime_res_list <- rdi_crdi_pseudotime(t(exprs(na_sim_cds)[1:12, 1:200]), window_size = 50) #13 mature gives Na values\n*/\n\n/*** R\n\n# run multiple run on the real simulation datasets: \n \n*/\n\n// [[Rcpp::export]]\nNumericMatrix calculate_umi_cpp(NumericMatrix& expr_data, IntegerMatrix& super_graph, int k, int method, int k_density, double bw) //, method: 1 rdi; 2: lmi \n{\n  const int n_genes(expr_data.cols()), n_samples(expr_data.rows());\n  \n  NumericMatrix uMI(n_genes, n_genes);     \n  std::fill(uMI.begin(), uMI.end(), 0); //NA_REAL \n  NumericMatrix expr_1(n_samples, 1), expr_2(n_samples, 1);\n  \n  // this part maybe slow if we do paralleling because RDI matrix is huge \n  \n  int i, j; \n  IntegerVector current_pair; \n  // #pragma omp parallel for shared(n_genes, expr_data, delays_len, RDI) private(i, j, k, expr_1, expr_2, _) //schedule(dynamic) default(none) //collapse(2) , _\n  for(int super_graph_ind = 0; super_graph_ind < super_graph.rows(); super_graph_ind ++) \n  {\n    current_pair = super_graph(Range(super_graph_ind, super_graph_ind), _);\n    i = current_pair[0]; j = current_pair[1]; \n    \n    expr_1 = expr_data(_, Range(i, i)); //Range(0, n_genes - 1)\n    expr_2 = expr_data(_, Range(j, j)); //Range(0, n_genes - 1)\n    \n    uMI(i, j) = umi_cpp(expr_1, expr_2, k = k, method = method, k_density = k_density, bw = bw); // how to deal with delays include multiple values?\n  }\n  \n  return uMI;\n}\n \n //' @title\n //' calculate_umi_cpp_wrap\n //' @description\n //' This function estimates the uniformed mutual information for all gene pairs in the expr_data matrix\n //' \n //' @param expr_data a matrix for all variables in a time-series where each row is a time point and each column is a variable (for example, a gene). \n //' The rows are ordered according to time, from earliest to latest. \n //' \n //' @param super_graph An integer matrix where each row is the variable IDs or gene pairs you would like to estimate restricted direct information (RDI) from. \n //'  \n //' @param k Number for nearest neighbors used in entropy calculation.\n //' \n //' @param methodWhich 2D density estimator you would like to use. 1 is kde estimator and 2 is knn based estimator. Default to be 1. \n //'\n //' @param k_density The number of k nearest neighbors you would like to use when calculating the density (only applicable when method == 2 or using knn based density estimation).\n //'\n //' @param bw Bindwidth used for the kernel density estimator. Currently it is not used. The bindwidth in the kde function is automatically estimated. \n //' @details\n //' \\code{calculate_umi_cpp_wrap} takes an expression matrix (expr_data) and possible gene pairs (encoded in super_graph) to estimate the uniformed \n //' mutual information. \n //' @return a numeric matrix of uniform mutual information values for all possible pairs of genes from expr_data. If the gene pairs is not encoded in the super_graph, it will remain as 0 in the matrix.  \n //' @export\n // [[Rcpp::export]]\n NumericMatrix calculate_umi_cpp_wrap(SEXP expr_data, SEXP super_graph, SEXP k, SEXP method, SEXP k_density, SEXP bw) \n { \n   NumericMatrix expr_data_cpp(expr_data); \n   IntegerMatrix super_graph_cpp(super_graph); \n\n   int k_cpp = as<int>(k);\n   int method_cpp = as<int>(method); \n   int k_density_cpp = as<int>(k_density); \n\n   double bw_cpp = as<double>(bw); \n   \n   NumericMatrix uMI = calculate_umi_cpp(expr_data_cpp, super_graph_cpp, k_cpp, method_cpp, k_density_cpp, bw_cpp); //cores\n   \n   return uMI;\n }\n \n",
    "created" : 1507861768322.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3103576429",
    "id" : "817D66FB",
    "lastKnownWriteTime" : 1507862791,
    "last_content_update" : 1507862791788,
    "path" : "~/Dropbox (Personal)/Projects/Causal_network/causal_network/Cpp/Real_deal/Scribe/Scribe/src/utility.cpp",
    "project_path" : "src/utility.cpp",
    "properties" : {
    },
    "relative_order" : 16,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}