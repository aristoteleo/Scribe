{
    "collab_server" : "",
    "contents" : "# this script keeps all other relevant causality detection algorithms: \n\n#' Perform the Granger causality test for two genes. \n#' \n#' This function uses the grangertest function from lmtest package to determine if one time series contains the necessary \n#' dynamic information to recover the influence of another causal variable. Note that granger casuality only deals with linear relationships. \n#' See the \\package{lmtest} for details\n#' of the grangertest function. \n#' \n#' @param ordered_exprs_mat CellDataSet for the experiment\n#' @return a matrix \n#' @import lmtest\n#' @importFrom lmtest grangertest\n#' @export\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' gene_pairs_mat <- matrix(c('H19', 'Ccnd2', 'Ccnd2', 'Scnn1g'), ncol = 2)\n#' cal_grangertest(lung, gene_pairs_mat)\n#' }\n#' @export\n#' \ncal_grangertest <- function(ordered_exprs_mat) { # why not just x0, x1 as argument?\n  df <- data.frame(ordered_exprs_mat)\n  x0_by_x1 <- grangertest(x0 ~ x1, order = 1, data = df)\n  x1_by_x0 <- grangertest(x1 ~ x0, order = 1, data = df)\n  \n  return(data.frame(x0_by_x1 = x0_by_x1$`Pr(>F)`[2], \n                    x1_by_x0 = x1_by_x0$`Pr(>F)`[2]))\n}\n\n#' Perform the Granger causality test for two genes. \n#' \n#' This function uses the grangertest function from vars package to determine if one time series contain the necessary \n#' dynamic information to recover the influence of another causal variable. See the \\package{vars} for details\n#' of the VAR or causality function. \n#' \n#' @param ordered_exprs_mat CellDataSet for the experiment\n#' @return a ggplot2 plot object\n#' @import vars\n#' @importFrom vars VAR\n#' @importFrom vars causality\n#' @export\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' gene_pairs_mat <- matrix(c('H19', 'Ccnd2', 'Ccnd2', 'Scnn1g'), ncol = 2)\n#' cal_cross_map(lung, gene_pairs_mat)\n#' }\n#' @export\n#' \ncal_grangertest_var <- function(ordered_exprs_mat) {\n  var <- VAR(ordered_exprs_mat, p = 1, type = \"const\")\n  x1_by_x0 <- causality(var, cause = \"x0\")$Granger\n  x0_by_x1 <- causality(var, cause = \"x1\")$Granger\n  \n  return(data.frame(x0_by_x1 = x0_by_x1$p.value, \n                    x1_by_x0 = x1_by_x0$p.value))\n}\n\n#' Calculate the mutual information between all gene pairs   \n#' \n#' This function uses the knnmi.all function from \\package{parmigene} package to calculate the mutual information between all pairs of genes in the data. \n#' See the \\package{parmigene} for details of the knnmi.all function. \n#'  \n#' @param cds CellDataSet for the experiment\n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom plyr ddply\n#' @importFrom reshape2 melt\n#' @export\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' cal_knn_mi_parmigene(t(exprs(lung))\n#' }\n#' @export\n#' \ncal_knn_mi_parmigene <- function(cds) {\n  exprs_mat <- exprs(cds)\n  parmigene::knnmi.all(exprs_mat)\n}\n\n# mi_res <- matrix(1, nrow = ncol(time_series), ncol = ncol(time_series))\n\n#' Calculate the mutual information between all pairs of genes using the KSG estimator for MI. \n#' \n#' This function calculates the mutual information using the KSG estimators. \n#' \n#' @param cds CellDataSet for the experiment, columns ordered by exprimental time or pseudotime with Monocle 2\n#' @param k Number of nearest neighbors used for calculating the mutual information values. \n#' @return a list for the mutual information values for all possible pairs of genes. \n#' @export\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' cal_knn_mi(lung)\n#' }\n#' @export\n#' \ncal_knn_mi <- function(cds, k = 5) {\n    expr_data <- t(exprs(cds))\n\n    combn_mat <- combn(1:ncol(expr_data), 2)\n    combn_mat_split <- split(t(combn_mat), 1:ncol(combn_mat))\n\n    mclapply(combn_mat_split, function(x, time_series, k = k){\n    col_names <- colnames(time_series)[x]\n    mi(as.matrix(time_series[, col_names[1]], ncol = 1), \n       as.matrix(time_series[, col_names[1]], ncol = 1), \n       k = k, normalize = F)\n  }, time_series = expr_data, k = k, mc.cores = detectCores() - 2)\n}\n\n#' Perform cross-convergence mapping test for two genes. \n#' \n#' This function uses the CCM function from rEDM package to determine if one time series contain the necessary \n#' dynamic information to recover the influence of another causal variable. See the \\package{rEDM} for details\n#' of the ccm function. \n#' \n#' @param ordered_exprs_mat CellDataSet for the experiment\n#' @param lib_colum The index (or name) of the column to cross map from (same as in rEDM).\n#' @param target_column The index (or name) of the column to cross map to (same as in rEDM). \n#' @param RNGseed will set a seed for the random number generator, enabling reproducible runs of ccm with randomly generated libraries (same as in rEDM). \n#' @return a \n#' @importFrom rEDM ccm\n#' @export\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' gene_pairs_mat <- matrix(c('H19', 'Ccnd2', 'Ccnd2', 'Scnn1g'), ncol = 2)\n#' cal_cross_map(lung, gene_pairs_mat)\n#' }\n#' @export\n#' \ncal_cross_map <- function(ordered_exprs_mat, lib_colum, target_column, RNGseed = 2016) { \n  # lib_xmap_target <- ccm(ordered_exprs_mat, E = 3, random_libs = TRUE, lib_column = lib_colum, #ENSG00000122180.4\n  #                        target_column = target_column, lib_sizes = seq(10, 75, by = 5), num_samples = 300, RNGseed = RNGseed)\n  # target_xmap_lib <- ccm(ordered_exprs_mat, E = 3, random_libs = TRUE, lib_column = target_column, #ENSG00000122180.4\n  #                        target_column = lib_colum, lib_sizes = seq(10, 75, by = 5), num_samples = 300, RNGseed = RNGseed)\n  # \n  lib_xmap_target <- ccm(ordered_exprs_mat, lib_column = lib_colum, E = 1, #ENSG00000122180.4\n                         target_column = target_column, RNGseed = RNGseed)\n  target_xmap_lib <- ccm(ordered_exprs_mat, lib_column = target_column, E = 1, #ENSG00000122180.4\n                         target_column = lib_colum, RNGseed = RNGseed)\n  \n  lib_xmap_target_means <- ccm_means(lib_xmap_target)\n  target_xmap_lib_means <- ccm_means(target_xmap_lib)\n  \n  return(data.frame(mean_lib_xmap_target_means = mean(lib_xmap_target_means$rho[is.finite(lib_xmap_target_means$rho)], na.rm = T), \n                    mean_target_xmap_lib_means = mean(target_xmap_lib_means$rho[is.finite(target_xmap_lib_means$rho)], na.rm = T)))\n}\n\n",
    "created" : 1508371709388.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2239932347",
    "id" : "F0A1A56F",
    "lastKnownWriteTime" : 1508372343,
    "last_content_update" : 1508372343238,
    "path" : "~/Dropbox (Personal)/Projects/Causal_network/causal_network/Cpp/Real_deal/Scribe/Scribe/R/other_estimators.R",
    "project_path" : "R/other_estimators.R",
    "properties" : {
    },
    "relative_order" : 18,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}