{
    "collab_server" : "",
    "contents" : "utils::globalVariables(c(\"Pseudotime\", \"value\", \"ids\", \"prin_graph_dim_1\", \"prin_graph_dim_2\", \"State\", \n                         \"value\", \"feature_label\", \"expectation\", \"colInd\", \"rowInd\", \"value\", \n                         \"source_prin_graph_dim_1\", \"source_prin_graph_dim_2\"))\n\nmonocle_theme_opts <- function()\n{\n    theme(strip.background = element_rect(colour = 'white', fill = 'white')) +\n    theme(panel.border = element_blank()) +\n    theme(axis.line.x = element_line(size=0.25, color=\"black\")) +\n    theme(axis.line.y = element_line(size=0.25, color=\"black\")) +\n    theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) +\n    theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + \n    theme(panel.background = element_rect(fill='white')) +\n    theme(legend.key=element_blank())\n}\n\n#' @title Plots the minimum spanning tree on cells.\n#' @description Displays the trajectory of the cells in a reduced dimension space. Cells collected at time zero are located near one of the tips of the tree. plot_cell_trajectory cannot determine which tip is the start of the tree. You can indicated the beginning by re-calling 'orderCells' on your CellDataSet and using the 'root_state' parameter to identify the stating branch. The cells in the trajectory can be colored by several different factors using the 'color_by' parameter.\n#' @param cds CellDataSet for the experiment\n#' @param x the column of reducedDimS(cds) to plot on the horizontal axis\n#' @param y the column of reducedDimS(cds) to plot on the vertical axis\n#' @param color_by the cell attribute (e.g. the column of pData(cds)) to map to each cell's color\n#' @param show_tree whether to show the links between cells connected in the minimum spanning tree\n#' @param show_backbone whether to show the diameter path of the MST used to order the cells\n#' @param backbone_color the color used to render the backbone.\n#' @param markers a gene name or gene id to use for setting the size of each cell in the plot\n#' @param markers_linear a boolean used to indicate whether you want to scale the markers logarithimically or linearly\n#' @param show_cell_names draw the name of each cell in the plot\n#' @param show_state_number a boolean that determines whether or not the state number for each cell should be shown\n#' @param cell_size The size of the point for each cell\n#' @param cell_link_size The size of the line segments connecting cells (when used with ICA) or the principal graph (when used with DDRTree)\n#' @param cell_name_size the size of cell name labels\n#' @param state_number_size if 'show_state_number' is set to true, this variable will control the size of the number labels \n#' @param show_branch_points Whether to show icons for each branch point (only available when reduceDimension was called with DDRTree)\n#' @param theta How many degrees you want to rotate the trajectory\n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom reshape2 melt\n#' @export\n#' @examples\n#' \\dontrun{\n#' data(HSMM)\n#' plot_cell_trajectory(HSMM)\n#' plot_cell_trajectory(HSMM, color_by=\"Pseudotime\", show_backbone=FALSE)\n#' plot_cell_trajectory(HSMM, markers=\"MYH3\")\n#' }\nplot_cell_trajectory <- function(cds, \n                               x=1, \n                               y=2, \n                               color_by=\"State\", \n                               show_tree=TRUE, \n                               show_backbone=TRUE, \n                               backbone_color=\"black\", \n                               markers=NULL, \n                               markers_linear = FALSE,\n                               show_cell_names=FALSE,\n                               show_state_number = FALSE,\n                               cell_size=1.5,\n                               cell_link_size=0.75,\n                               cell_name_size=2,\n                               state_number_size = 2.9,\n                               show_branch_points=TRUE,\n                               theta = 0){\n  gene_short_name <- NA\n  sample_name <- NA\n  sample_state <- pData(cds)$State\n  data_dim_1 <- NA\n  data_dim_2 <- NA\n  \n  #TODO: need to validate cds as ready for this plot (need mst, pseudotime, etc)\n  lib_info_with_pseudo <- pData(cds)\n  \n  if (is.null(cds@dim_reduce_type)){\n    stop(\"Error: dimensionality not yet reduced. Please call reduceDimension() before calling this function.\")\n  }\n  \n  if (cds@dim_reduce_type == \"ICA\"){\n    reduced_dim_coords <- reducedDimS(cds)\n  }else if (cds@dim_reduce_type %in% c(\"simplePPT\", \"DDRTree\") ){\n    reduced_dim_coords <- reducedDimK(cds)\n  }else {\n    stop(\"Error: unrecognized dimensionality reduction method.\")\n  }\n  \n  ica_space_df <- data.frame(Matrix::t(reduced_dim_coords[c(x,y),]))\n  colnames(ica_space_df) <- c(\"prin_graph_dim_1\", \"prin_graph_dim_2\")\n  \n  ica_space_df$sample_name <- row.names(ica_space_df)\n  ica_space_df$sample_state <- row.names(ica_space_df)\n  #ica_space_with_state_df <- merge(ica_space_df, lib_info_with_pseudo, by.x=\"sample_name\", by.y=\"row.names\")\n  #print(ica_space_with_state_df)\n  dp_mst <- minSpanningTree(cds)\n  \n  if (is.null(dp_mst)){\n    stop(\"You must first call orderCells() before using this function\")\n  }\n  \n  edge_list <- as.data.frame(get.edgelist(dp_mst))\n  colnames(edge_list) <- c(\"source\", \"target\")\n  \n  edge_df <- merge(ica_space_df, edge_list, by.x=\"sample_name\", by.y=\"source\", all=TRUE)\n  #edge_df <- ica_space_df\n  edge_df <- plyr::rename(edge_df, c(\"prin_graph_dim_1\"=\"source_prin_graph_dim_1\", \"prin_graph_dim_2\"=\"source_prin_graph_dim_2\"))\n  edge_df <- merge(edge_df, ica_space_df[,c(\"sample_name\", \"prin_graph_dim_1\", \"prin_graph_dim_2\")], by.x=\"target\", by.y=\"sample_name\", all=TRUE)\n  edge_df <- plyr::rename(edge_df, c(\"prin_graph_dim_1\"=\"target_prin_graph_dim_1\", \"prin_graph_dim_2\"=\"target_prin_graph_dim_2\"))\n  \n  S_matrix <- reducedDimS(cds)\n  data_df <- data.frame(t(S_matrix[c(x,y),]))\n  data_df <- cbind(data_df, sample_state)\n  colnames(data_df) <- c(\"data_dim_1\", \"data_dim_2\")\n  data_df$sample_name <- row.names(data_df)\n  data_df <- merge(data_df, lib_info_with_pseudo, by.x=\"sample_name\", by.y=\"row.names\")\n  \n  return_rotation_mat <- function(theta) {\n    theta <- theta / 180 * pi\n    matrix(c(cos(theta), sin(theta), -sin(theta), cos(theta)), nrow = 2)\n  }\n  \n  tmp <- return_rotation_mat(theta) %*% t(as.matrix(data_df[, c(2, 3)]))\n  data_df$data_dim_1 <- tmp[1, ]\n  data_df$data_dim_2 <- tmp[2, ]\n  \n  tmp <- return_rotation_mat(theta = theta) %*% t(as.matrix(edge_df[, c('source_prin_graph_dim_1', 'source_prin_graph_dim_2')]))\n  edge_df$source_prin_graph_dim_1 <- tmp[1, ]\n  edge_df$source_prin_graph_dim_2 <- tmp[2, ]\n  \n  tmp <- return_rotation_mat(theta) %*% t(as.matrix(edge_df[, c('target_prin_graph_dim_1', 'target_prin_graph_dim_2')]))\n  edge_df$target_prin_graph_dim_1 <- tmp[1, ]\n  edge_df$target_prin_graph_dim_2 <- tmp[2, ]\n  \n  markers_exprs <- NULL\n  if (is.null(markers) == FALSE){\n    markers_fData <- subset(fData(cds), gene_short_name %in% markers)\n    if (nrow(markers_fData) >= 1){\n      markers_exprs <- reshape2::melt(as.matrix(exprs(cds[row.names(markers_fData),])))\n      colnames(markers_exprs)[1:2] <- c('feature_id','cell_id')\n      markers_exprs <- merge(markers_exprs, markers_fData, by.x = \"feature_id\", by.y=\"row.names\")\n      #print (head( markers_exprs[is.na(markers_exprs$gene_short_name) == FALSE,]))\n      markers_exprs$feature_label <- as.character(markers_exprs$gene_short_name)\n      markers_exprs$feature_label[is.na(markers_exprs$feature_label)] <- markers_exprs$Var1\n    }\n  }\n  if (is.null(markers_exprs) == FALSE && nrow(markers_exprs) > 0){\n    data_df <- merge(data_df, markers_exprs, by.x=\"sample_name\", by.y=\"cell_id\")\n    if(markers_linear){\n      g <- ggplot(data=data_df, aes(x=data_dim_1, y=data_dim_2, size= (value * 0.1))) + facet_wrap(~feature_label)\n    } else {\n      g <- ggplot(data=data_df, aes(x=data_dim_1, y=data_dim_2, size=log10(value + 0.1))) + facet_wrap(~feature_label)\n    }\n  }else{\n    g <- ggplot(data=data_df, aes(x=data_dim_1, y=data_dim_2)) \n  }\n  if (show_tree){\n    g <- g + geom_segment(aes_string(x=\"source_prin_graph_dim_1\", y=\"source_prin_graph_dim_2\", xend=\"target_prin_graph_dim_1\", yend=\"target_prin_graph_dim_2\"), size=cell_link_size, linetype=\"solid\", na.rm=TRUE, data=edge_df)\n  }\n  \n  # FIXME: setting size here overrides the marker expression funtionality. \n  # Don't do it!\n  if (is.null(markers_exprs) == FALSE && nrow(markers_exprs) > 0){\n    g <- g + geom_point(aes_string(color = color_by), na.rm = TRUE)\n  }else {\n    g <- g + geom_point(aes_string(color = color_by), size=I(cell_size), na.rm = TRUE)\n  }\n  \n  \n  if (show_branch_points && cds@dim_reduce_type == 'DDRTree'){\n    mst_branch_nodes <- cds@auxOrderingData[[cds@dim_reduce_type]]$branch_points\n    branch_point_df <- subset(edge_df, sample_name %in% mst_branch_nodes)[,c(\"sample_name\", \"source_prin_graph_dim_1\", \"source_prin_graph_dim_2\")]\n    branch_point_df$branch_point_idx <- match(branch_point_df$sample_name, mst_branch_nodes)\n    branch_point_df <- branch_point_df[!duplicated(branch_point_df$branch_point_idx), ]\n    \n    g <- g + geom_point(aes_string(x=\"source_prin_graph_dim_1\", y=\"source_prin_graph_dim_2\"), \n                        size=5, na.rm=TRUE, data=branch_point_df) +\n      geom_text(aes_string(x=\"source_prin_graph_dim_1\", y=\"source_prin_graph_dim_2\", label=\"branch_point_idx\"), \n                size=4, color=\"white\", na.rm=TRUE, data=branch_point_df)\n  }\n  if (show_cell_names){\n    g <- g +geom_text(aes(label=sample_name), size=cell_name_size)\n  }\n  if (show_state_number){\n    g <- g + geom_text(aes(label = sample_state), size = state_number_size)\n  }\n  \n  g <- g + \n    #scale_color_brewer(palette=\"Set1\") +\n    monocle_theme_opts() + \n    xlab(paste(\"Component\", x)) + \n    ylab(paste(\"Component\", y)) +\n    theme(legend.position=\"top\", legend.key.height=grid::unit(0.35, \"in\")) +\n    #guides(color = guide_legend(label.position = \"top\")) +\n    theme(legend.key = element_blank()) +\n    theme(panel.background = element_rect(fill='white'))\n  g\n}\n\n#' @rdname package-deprecated\n#' @title Plots the minimum spanning tree on cells.\n#' This function is deprecated.\n#' @description This function arranges all of the cells in the cds in a tree and\n#' predicts their location based on their pseudotime value\n#' @param cds CellDataSet for the experiment\n#' @param x the column of reducedDimS(cds) to plot on the horizontal axis\n#' @param y the column of reducedDimS(cds) to plot on the vertical axis\n#' @param color_by the cell attribute (e.g. the column of pData(cds)) to map to each cell's color\n#' @param show_tree whether to show the links between cells connected in the minimum spanning tree\n#' @param show_backbone whether to show the diameter path of the MST used to order the cells\n#' @param backbone_color the color used to render the backbone.\n#' @param markers a gene name or gene id to use for setting the size of each cell in the plot\n#' @param show_cell_names draw the name of each cell in the plot\n#' @param cell_size The size of the point for each cell\n#' @param cell_link_size The size of the line segments connecting cells (when used with ICA) or the principal graph (when used with DDRTree)\n#' @param cell_name_size the size of cell name labels\n#' @param show_branch_points Whether to show icons for each branch point (only available when reduceDimension was called with DDRTree)\n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom reshape2 melt\n#' @export\n#' @seealso plot_cell_trajectory\n#' @examples\n#' \\dontrun{\n#' data(HSMM)\n#' plot_cell_trajectory(HSMM)\n#' plot_cell_trajectory(HSMM, color_by=\"Pseudotime\", show_backbone=FALSE)\n#' plot_cell_trajectory(HSMM, markers=\"MYH3\")\n#' }\nplot_spanning_tree <- function(cds, \n                                 x=1, \n                                 y=2, \n                                 color_by=\"State\", \n                                 show_tree=TRUE, \n                                 show_backbone=TRUE, \n                                 backbone_color=\"black\", \n                                 markers=NULL, \n                                 show_cell_names=FALSE, \n                                 cell_size=1.5,\n                                 cell_link_size=0.75,\n                                 cell_name_size=2,\n                                 show_branch_points=TRUE){\n  .Deprecated(\"plot_cell_trajectory\") #include a package argument, too\n  plot_cell_trajectory(cds=cds, \n                       x=x, \n                       y=y, \n                       color_by=color_by, \n                       show_tree=show_tree, \n                       show_backbone=show_backbone, \n                       backbone_color=backbone_color, \n                       markers=markers, \n                       show_cell_names=show_cell_names, \n                       cell_size=cell_size,\n                       cell_link_size=cell_link_size,\n                       cell_name_size=cell_name_size,\n                       show_branch_points=show_branch_points)\n}\n\n\n#' @title Plots expression for one or more genes as a violin plot\n#' \n#' @description Accepts a subset of a CellDataSet and an attribute to group cells by,\n#' and produces one or more ggplot2 objects that plots the level of expression for\n#' each group of cells. \n#'\n#' @param cds_subset CellDataSet for the experiment\n#' @param grouping the cell attribute (e.g. the column of pData(cds)) to group cells by on the horizontal axis\n#' @param min_expr the minimum (untransformed) expression level to use in plotted the genes.\n#' @param cell_size the size (in points) of each cell used in the plot\n#' @param nrow the number of rows used when laying out the panels for each gene's expression\n#' @param ncol the number of columns used when laying out the panels for each gene's expression\n#' @param panel_order the order in which genes should be layed out (left-to-right, top-to-bottom)\n#' @param color_by the cell attribute (e.g. the column of pData(cds)) to be used to color each cell  \n#' @param plot_trend whether to plot a trendline tracking the average expression across the horizontal axis.\n#' @param label_by_short_name label figure panels by gene_short_name (TRUE) or feature id (FALSE)\n#' @param relative_expr Whether to transform expression into relative values\n#' @param log_scale a boolean that determines whether or not to scale data logarithmically\n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom reshape2 melt\n#' @importFrom BiocGenerics sizeFactors\n#' @export\n#' @examples\n#' \\dontrun{\n#' data(HSMM)\n#' my_genes <- HSMM[row.names(subset(fData(HSMM), gene_short_name %in% c(\"ACTA1\", \"ID1\", \"CCNB2\"))),]\n#' plot_genes_violin(my_genes, grouping=\"Hours\", ncol=2, min_expr=0.1)\n#' }\nplot_genes_violin <- function (cds_subset, grouping = \"State\", min_expr = NULL, cell_size = 0.75, \n                              nrow = NULL, ncol = 1, panel_order = NULL, color_by = NULL, \n                              plot_trend = FALSE, label_by_short_name = TRUE, relative_expr = TRUE, \n                              log_scale = TRUE) \n{\n  if (cds_subset@expressionFamily@vfamily %in% c(\"negbinomial\", \n                                                 \"negbinomial.size\")) {\n    integer_expression = TRUE\n  }\n  else {\n    integer_expression = FALSE\n    relative_expr = TRUE\n  }\n  if (integer_expression) {\n    cds_exprs = exprs(cds_subset)\n    if (relative_expr) {\n      if (is.null(sizeFactors(cds_subset))) {\n        stop(\"Error: to call this function with relative_expr=TRUE, you must call estimateSizeFactors() first\")\n      }\n      cds_exprs = Matrix::t(Matrix::t(cds_exprs)/sizeFactors(cds_subset))\n    }\n    #cds_exprs = reshape2::melt(round(as.matrix(cds_exprs)))\n    cds_exprs = reshape2::melt(as.matrix(cds_exprs))\n  }\n  else {\n    cds_exprs = exprs(cds_subset)\n    cds_exprs = reshape2::melt(as.matrix(cds_exprs))\n  }\n  if (is.null(min_expr)) {\n    min_expr = cds_subset@lowerDetectionLimit\n  }\n  colnames(cds_exprs) = c(\"f_id\", \"Cell\", \"expression\")\n  cds_exprs$expression[cds_exprs$expression < min_expr] = min_expr\n  cds_pData = pData(cds_subset)\n  \n  # \n  # # Custom bit for adding in a group for \n  # if(! is.null(show_combined)) {\n  #   for(combine_gene in show_combined) {\n  #     cds_pData_all = subset(cds_pData, gene == combine_gene)\n  #     cds_pData_all[, grouping] = paste(\"All\", combine_gene)\n  #     cds_pData = rbind(cds_pData, cds_pData_all)\n  #   }\n  # }\n  \n  cds_fData = fData(cds_subset)\n  cds_exprs = merge(cds_exprs, cds_fData, by.x = \"f_id\", by.y = \"row.names\")\n  cds_exprs = merge(cds_exprs, cds_pData, by.x = \"Cell\", by.y = \"row.names\")\n  cds_exprs$adjusted_expression = log10(cds_exprs$expression)\n  \n  \n  \n  \n  if (label_by_short_name == TRUE) {\n    if (is.null(cds_exprs$gene_short_name) == FALSE) {\n      cds_exprs$feature_label = cds_exprs$gene_short_name\n      cds_exprs$feature_label[is.na(cds_exprs$feature_label)] = cds_exprs$f_id\n    }\n    else {\n      cds_exprs$feature_label = cds_exprs$f_id\n    }\n  }\n  else {\n    cds_exprs$feature_label = cds_exprs$f_id\n  }\n  if (is.null(panel_order) == FALSE) {\n    cds_exprs$feature_label = factor(cds_exprs$feature_label, \n                                     levels = panel_order)\n  }\n  q = ggplot(aes_string(x = grouping, y = \"expression\"), data = cds_exprs)\n  if (is.null(color_by) == FALSE) {\n    q = q + geom_violin(aes_string(fill = color_by))\n  }\n  else {\n    q = q + geom_violin()\n  }\n  if (plot_trend == TRUE) {\n    q = q + stat_summary(fun.data = \"mean_cl_boot\", \n                         size = 0.2)\n    q = q + stat_summary(aes_string(x = grouping, y = \"expression\", \n                                    group = color_by), fun.data = \"mean_cl_boot\", \n                         size = 0.2, geom = \"line\")\n  }\n  q = q + facet_wrap(~feature_label, nrow = nrow, \n                     ncol = ncol, scales = \"free_y\")\n  if (min_expr < 1) {\n     q = q + expand_limits(y = c(min_expr, 1))\n  }\n  \n  \n  q = q + ylab(\"Expression\") + xlab(grouping)\n  \n  if (log_scale == TRUE){\n    \n    q = q + scale_y_log10()\n  }\n  q\n}\n\n\n#' Plots expression for one or more genes as a jittered, grouped points\n#' \n#' @description Accepts a subset of a CellDataSet and an attribute to group cells by,\n#' and produces one or more ggplot2 objects that plots the level of expression for\n#' each group of cells. \n#'\n#' @param cds_subset CellDataSet for the experiment\n#' @param grouping the cell attribute (e.g. the column of pData(cds)) to group cells by on the horizontal axis\n#' @param min_expr the minimum (untransformed) expression level to use in plotted the genes.\n#' @param cell_size the size (in points) of each cell used in the plot\n#' @param nrow the number of rows used when laying out the panels for each gene's expression\n#' @param ncol the number of columns used when laying out the panels for each gene's expression\n#' @param panel_order the order in which genes should be layed out (left-to-right, top-to-bottom)\n#' @param color_by the cell attribute (e.g. the column of pData(cds)) to be used to color each cell  \n#' @param plot_trend whether to plot a trendline tracking the average expression across the horizontal axis.\n#' @param label_by_short_name label figure panels by gene_short_name (TRUE) or feature id (FALSE)\n#' @param relative_expr Whether to transform expression into relative values\n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom reshape2 melt\n#' @importFrom BiocGenerics sizeFactors\n#' @export\n#' @examples\n#' \\dontrun{\n#' data(HSMM)\n#' my_genes <- HSMM[row.names(subset(fData(HSMM), gene_short_name %in% c(\"MYOG\", \"ID1\", \"CCNB2\"))),]\n#' plot_genes_jitter(my_genes, grouping=\"Media\", ncol=2)\n#' }\nplot_genes_jitter <- function(cds_subset, \n                              grouping = \"State\", \n                              min_expr=NULL, \n                              cell_size=0.75, \n                              nrow=NULL, \n                              ncol=1, \n                              panel_order=NULL, \n                              color_by=NULL,\n                              plot_trend=FALSE,\n                              label_by_short_name=TRUE,\n                              relative_expr=TRUE){\n  \n  if (cds_subset@expressionFamily@vfamily %in% c(\"negbinomial\", \"negbinomial.size\")){\n\n    integer_expression <- TRUE\n  }else{\n    integer_expression <- FALSE\n    relative_expr <- TRUE\n  }\n  \n  if (integer_expression)\n  {\n    cds_exprs <- exprs(cds_subset)\n    if (relative_expr){\n      if (is.null(sizeFactors(cds_subset)))\n      {\n        stop(\"Error: to call this function with relative_expr=TRUE, you must call estimateSizeFactors() first\")\n      }\n      cds_exprs <- Matrix::t(Matrix::t(cds_exprs) / sizeFactors(cds_subset))\n    }\n    cds_exprs <- reshape2::melt(round(as.matrix(cds_exprs)))\n  }else{\n    cds_exprs <- exprs(cds_subset)\n    cds_exprs <- reshape2::melt(as.matrix(cds_exprs))\n  }\n  if (is.null(min_expr)){\n    min_expr <- cds_subset@lowerDetectionLimit\n  }\n  \n  colnames(cds_exprs) <- c(\"f_id\", \"Cell\", \"expression\")\n  cds_exprs$expression[cds_exprs$expression < min_expr] <- min_expr\n  cds_pData <- pData(cds_subset)\n  cds_fData <- fData(cds_subset)\n  \n  cds_exprs <- merge(cds_exprs, cds_fData, by.x=\"f_id\", by.y=\"row.names\")\n  cds_exprs <- merge(cds_exprs, cds_pData, by.x=\"Cell\", by.y=\"row.names\")\n  \n  cds_exprs$adjusted_expression <- log10(cds_exprs$expression)\n  #cds_exprs$adjusted_expression <- log10(cds_exprs$adjusted_expression + abs(rnorm(nrow(cds_exprs), min_expr, sqrt(min_expr))))\n  \n  if (label_by_short_name == TRUE){\n    if (is.null(cds_exprs$gene_short_name) == FALSE){\n      cds_exprs$feature_label <- cds_exprs$gene_short_name\n      cds_exprs$feature_label[is.na(cds_exprs$feature_label)]  <- cds_exprs$f_id\n    }else{\n      cds_exprs$feature_label <- cds_exprs$f_id\n    }\n  }else{\n    cds_exprs$feature_label <- cds_exprs$f_id\n  }\n  \n  #print (head(cds_exprs))\n  \n  if (is.null(panel_order) == FALSE)\n  {\n    cds_exprs$feature_label <- factor(cds_exprs$feature_label, levels=panel_order)\n  }\n  \n  q <- ggplot(aes_string(x=grouping, y=\"expression\"), data=cds_exprs) \n  \n  if (is.null(color_by) == FALSE){\n    q <- q + geom_jitter(aes_string(color=color_by), size=I(cell_size))\n  }else{\n    q <- q + geom_jitter(size=I(cell_size))\n  }\n  if (plot_trend == TRUE){\n    q <- q + stat_summary(aes_string(color=color_by), fun.data = \"mean_cl_boot\", size=0.35)\n    q <- q + stat_summary(aes_string(x=grouping, y=\"expression\", color=color_by, group=color_by), fun.data = \"mean_cl_boot\", size=0.35, geom=\"line\")\n  }\n  \n  q <- q + scale_y_log10() + facet_wrap(~feature_label, nrow=nrow, ncol=ncol, scales=\"free_y\")\n  \n  # Need this to guard against plotting failures caused by non-expressed genes\n  if (min_expr < 1)\n  {\n    q <- q + expand_limits(y=c(min_expr, 1))\n  }\n\n  q <- q + ylab(\"Expression\") + xlab(grouping)\n  q <- q + monocle_theme_opts()\n  q\n}\n\n#' Plots the number of cells expressing one or more genes as a barplot\n#' \n#'  @description Accetps a CellDataSet and a parameter,\"grouping\", used for dividing cells into groups.\n#'  Returns one or more bar graphs (one graph for each gene in the CellDataSet).\n#'  Each graph shows the percentage of cells that express a gene in the in the CellDataSet for\n#'  each sub-group of cells created by \"grouping\".\n#'  \n#'  Let's say the CellDataSet passed in included genes A, B, and C and the \"grouping parameter divided\n#'  all of the cells into three groups called X, Y, and Z. Then three graphs would be produced called A,\n#'  B, and C. In the A graph there would be three bars one for X, one for Y, and one for Z. So X bar in the\n#'  A graph would show the percentage of cells in the X group that express gene A.\n#'\n#' @param cds_subset CellDataSet for the experiment\n#' @param grouping the cell attribute (e.g. the column of pData(cds)) to group cells by on the horizontal axis\n#' @param min_expr the minimum (untransformed) expression level to use in plotted the genes.\n#' @param nrow the number of rows used when laying out the panels for each gene's expression\n#' @param ncol the number of columns used when laying out the panels for each gene's expression\n#' @param panel_order the order in which genes should be layed out (left-to-right, top-to-bottom)\n#' @param plot_as_fraction whether to show the percent instead of the number of cells expressing each gene \n#' @param label_by_short_name label figure panels by gene_short_name (TRUE) or feature id (FALSE)\n#' @param relative_expr Whether to transform expression into relative values\n#' @param plot_limits A pair of number specifying the limits of the y axis. If NULL, scale to the range of the data.\n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom plyr ddply\n#' @importFrom reshape2 melt\n#' @importFrom BiocGenerics sizeFactors\n#' @export\n#' @examples\n#' \\dontrun{\n#' data(HSMM)\n#' MYOG_ID1 <- HSMM[row.names(subset(fData(HSMM), gene_short_name %in% c(\"MYOG\", \"ID1\"))),]\n#' plot_genes_positive_cells(MYOG_ID1, grouping=\"Media\", ncol=2)\n#' }\nplot_genes_positive_cells <- function(cds_subset, \n                                      grouping = \"State\", \n                                      min_expr=0.1, \n                                      nrow=NULL, \n                                      ncol=1, \n                                      panel_order=NULL, \n                                      plot_as_fraction=TRUE,\n                                      label_by_short_name=TRUE,\n                                      relative_expr=TRUE,\n                                      plot_limits=c(0,100)){\n  \n  percent <- NULL\n\n  if (cds_subset@expressionFamily@vfamily %in% c(\"negbinomial\", \"negbinomial.size\")){\n    integer_expression <- TRUE\n  }else{\n    integer_expression <- FALSE\n    relative_expr <- TRUE\n  }\n  \n  if (integer_expression)\n  {\n    marker_exprs <- exprs(cds_subset)\n    if (relative_expr){\n      if (is.null(sizeFactors(cds_subset)))\n      {\n        stop(\"Error: to call this function with relative_expr=TRUE, you must call estimateSizeFactors() first\")\n      }\n      marker_exprs <- Matrix::t(Matrix::t(marker_exprs) / sizeFactors(cds_subset))\n    }\n    marker_exprs_melted <- reshape2::melt(round(as.matrix(marker_exprs)))\n  }else{\n    marker_exprs_melted <- reshape2::melt(exprs(marker_exprs))\n  }\n   \n  colnames(marker_exprs_melted) <- c(\"f_id\", \"Cell\", \"expression\")\n  \n  marker_exprs_melted <- merge(marker_exprs_melted, pData(cds_subset), by.x=\"Cell\", by.y=\"row.names\")\n  marker_exprs_melted <- merge(marker_exprs_melted, fData(cds_subset), by.x=\"f_id\", by.y=\"row.names\")\n  \n  if (label_by_short_name == TRUE){\n    if (is.null(marker_exprs_melted$gene_short_name) == FALSE){\n      marker_exprs_melted$feature_label <- marker_exprs_melted$gene_short_name\n      marker_exprs_melted$feature_label[is.na(marker_exprs_melted$feature_label)]  <- marker_exprs_melted$f_id\n    }else{\n      marker_exprs_melted$feature_label <- marker_exprs_melted$f_id\n    }    \n  }else{\n    marker_exprs_melted$feature_label <- marker_exprs_melted$f_id\n  }\n  \n  if (is.null(panel_order) == FALSE)\n  {\n    marker_exprs_melted$feature_label <- factor(marker_exprs_melted$feature_label, levels=panel_order)\n  }\n\n  marker_counts <- plyr::ddply(marker_exprs_melted, c(\"feature_label\", grouping), function(x) { \n    data.frame(target=sum(x$expression > min_expr), \n               target_fraction=sum(x$expression > min_expr)/nrow(x)) } )\n  \n  #print (head(marker_counts))\n  if (plot_as_fraction){\n    marker_counts$target_fraction <- marker_counts$target_fraction * 100\n    qp <- ggplot(aes_string(x=grouping, y=\"target_fraction\", fill=grouping), data=marker_counts) +\n      ylab(\"Cells (percent)\")\n    if (is.null(plot_limits) == FALSE)\n      qp <- qp + scale_y_continuous(limits=plot_limits) \n  }else{\n    qp <- ggplot(aes_string(x=grouping, y=\"target\", fill=grouping), data=marker_counts) +\n      ylab(\"Cells\")\n  }\n  \n  qp <- qp + facet_wrap(~feature_label, nrow=nrow, ncol=ncol, scales=\"free_y\")\n  qp <-  qp + geom_bar(stat=\"identity\") + monocle_theme_opts()\n\n  return(qp)\n}\n\n\n#' Plots expression for one or more genes as a function of pseudotime\n#' \n#' @description Plots expression for one or more genes as a function of pseudotime.\n#' Plotting allows you determine if the ordering produced by orderCells() is correct\n#' and it does not need to be flipped using the \"reverse\" flag in orderCells\n#'\n#' @param cds_subset CellDataSet for the experiment\n#' @param min_expr the minimum (untransformed) expression level to use in plotted the genes.\n#' @param cell_size the size (in points) of each cell used in the plot\n#' @param nrow the number of rows used when laying out the panels for each gene's expression\n#' @param ncol the number of columns used when laying out the panels for each gene's expression\n#' @param panel_order the order in which genes should be layed out (left-to-right, top-to-bottom)\n#' @param color_by the cell attribute (e.g. the column of pData(cds)) to be used to color each cell \n#' @param trend_formula the model formula to be used for fitting the expression trend over pseudotime \n#' @param label_by_short_name label figure panels by gene_short_name (TRUE) or feature id (FALSE)\n#' @param relative_expr Whether to transform expression into relative values\n#' @param vertical_jitter A value passed to ggplot to jitter the points in the vertical dimension. Prevents overplotting, and is particularly helpful for rounded transcript count data.\n#' @param horizontal_jitter A value passed to ggplot to jitter the points in the horizontal dimension. Prevents overplotting, and is particularly helpful for rounded transcript count data.\n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom plyr ddply .\n#' @importFrom reshape2 melt\n#' @importFrom ggplot2 Position\n#' @export\n#' @examples\n#' \\dontrun{\n#' data(HSMM)\n#' my_genes <- row.names(subset(fData(HSMM), gene_short_name %in% c(\"CDK1\", \"MEF2C\", \"MYH3\"))) \n#' cds_subset <- HSMM[my_genes,]\n#' plot_genes_in_pseudotime(cds_subset, color_by=\"Time\")\n#' }\nplot_genes_in_pseudotime <-function(cds_subset, \n                                    min_expr=NULL, \n                                    cell_size=0.75, \n                                    nrow=NULL, \n                                    ncol=1, \n                                    panel_order=NULL, \n                                    color_by=\"State\",\n                                    trend_formula=\"~ sm.ns(Pseudotime, df=3)\",\n                                    label_by_short_name=TRUE,\n                                    relative_expr=TRUE,\n                                    vertical_jitter=NULL,\n                                    horizontal_jitter=NULL){\n    \n  f_id <- NA\n  Cell <- NA\n    if (cds_subset@expressionFamily@vfamily %in% c(\"negbinomial\", \"negbinomial.size\")) {\n        integer_expression <- TRUE\n    }\n    else {\n        integer_expression <- FALSE\n        relative_expr <- TRUE\n    }\n    if (integer_expression) {\n        cds_exprs <- exprs(cds_subset)\n        if (relative_expr) {\n            if (is.null(sizeFactors(cds_subset))) {\n                stop(\"Error: to call this function with relative_expr=TRUE, you must call estimateSizeFactors() first\")\n            }\n            cds_exprs <- Matrix::t(Matrix::t(cds_exprs)/sizeFactors(cds_subset))\n        }\n        cds_exprs <- reshape2::melt(round(as.matrix(cds_exprs)))\n    }\n    else {\n        cds_exprs <- reshape2::melt(as.matrix(exprs(cds_subset)))\n    }\n    if (is.null(min_expr)) {\n        min_expr <- cds_subset@lowerDetectionLimit\n    }\n    colnames(cds_exprs) <- c(\"f_id\", \"Cell\", \"expression\")\n    cds_pData <- pData(cds_subset)\n    cds_fData <- fData(cds_subset)\n    cds_exprs <- merge(cds_exprs, cds_fData, by.x = \"f_id\", by.y = \"row.names\")\n    cds_exprs <- merge(cds_exprs, cds_pData, by.x = \"Cell\", by.y = \"row.names\")\n    #cds_exprs$f_id <- as.character(cds_exprs$f_id)\n    #cds_exprs$Cell <- as.character(cds_exprs$Cell)\n    \n    if (integer_expression) {\n        cds_exprs$adjusted_expression <- cds_exprs$expression\n    }\n    else {\n        cds_exprs$adjusted_expression <- log10(cds_exprs$expression)\n    }\n    # trend_formula <- paste(\"adjusted_expression\", trend_formula,\n    #     sep = \"\")\n    if (label_by_short_name == TRUE) {\n        if (is.null(cds_exprs$gene_short_name) == FALSE) {\n            cds_exprs$feature_label <- as.character(cds_exprs$gene_short_name)\n            cds_exprs$feature_label[is.na(cds_exprs$feature_label)] <- cds_exprs$f_id\n        }\n        else {\n            cds_exprs$feature_label <- cds_exprs$f_id\n        }\n    }\n    else {\n        cds_exprs$feature_label <- cds_exprs$f_id\n    }\n    cds_exprs$f_id <- as.character(cds_exprs$f_id)\n    cds_exprs$feature_label <- factor(cds_exprs$feature_label)\n\n    new_data <- data.frame(Pseudotime = pData(cds_subset)$Pseudotime)\n    model_expectation <- genSmoothCurves(cds_subset, cores=1, trend_formula = trend_formula,\n                        relative_expr = T, new_data = new_data)\n    colnames(model_expectation) <- colnames(cds_subset)\n    expectation <- ddply(cds_exprs, .(f_id, Cell), function(x) data.frame(\"expectation\"=model_expectation[x$f_id, x$Cell]))\n    cds_exprs <- merge(cds_exprs, expectation)\n    #cds_exprs$expectation <- expectation#apply(cds_exprs,1, function(x) model_expectation[x$f_id, x$Cell])\n\n    cds_exprs$expression[cds_exprs$expression < min_expr] <- min_expr\n    cds_exprs$expectation[cds_exprs$expectation < min_expr] <- min_expr\n    if (is.null(panel_order) == FALSE) {\n      cds_exprs$feature_label <- factor(cds_exprs$feature_label,\n            levels = panel_order)\n    }\n    q <- ggplot(aes(Pseudotime, expression), data = cds_exprs)\n    if (is.null(color_by) == FALSE) {\n        q <- q + geom_point(aes_string(color = color_by), size = I(cell_size), position=position_jitter(horizontal_jitter, vertical_jitter))\n    }\n    else {\n        q <- q + geom_point(size = I(cell_size), position=position_jitter(horizontal_jitter, vertical_jitter))\n    }\n\n    q <- q + geom_line(aes(x = Pseudotime, y = expectation), data = cds_exprs)\n\n    q <- q + scale_y_log10() + facet_wrap(~feature_label, nrow = nrow,\n        ncol = ncol, scales = \"free_y\")\n    if (min_expr < 1) {\n        q <- q + expand_limits(y = c(min_expr, 1))\n    }\n    if (relative_expr) {\n        q <- q + ylab(\"Relative Expression\")\n    }\n    else {\n        q <- q + ylab(\"Absolute Expression\")\n    }\n    q <- q + xlab(\"Pseudo-time\")\n    q <- q + monocle_theme_opts()\n    q\n}\n\n#' Plots kinetic clusters of genes.\n#'\n#' @description returns a ggplot2 object showing the shapes of the\n#' expression patterns followed by a set of pre-selected genes.\n#' The topographic lines highlight the distributions of the kinetic patterns\n#' relative to overall trend lines.\n#'\n#' @param cds CellDataSet for the experiment\n#' @param clustering a clustering object produced by clusterCells\n#' @param drawSummary whether to draw the summary line for each cluster\n#' @param sumFun whether the function used to generate the summary for each cluster\n#' @param ncol number of columns used to layout the faceted cluster panels\n#' @param nrow number of columns used to layout the faceted cluster panels\n#' @param row_samples how many genes to randomly select from the data\n#' @param callout_ids a vector of gene names or gene ids to manually render as part of the plot\n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom reshape2 melt\n#' @importFrom stringr str_join\n#' @importFrom ggplot2 Position\n#' @import grid\n#' @export\n#' @examples\n#' \\dontrun{\n#' full_model_fits <- fitModel(HSMM_filtered[sample(nrow(fData(HSMM_filtered)), 100),],  \n#'    modelFormulaStr=\"~VGAM::bs(Pseudotime)\")\n#' expression_curve_matrix <- responseMatrix(full_model_fits)\n#' clusters <- clusterGenes(expression_curve_matrix, k=4)\n#' plot_clusters(HSMM_filtered[ordering_genes,], clusters)\n#' }\nplot_clusters<-function(cds, \n                        clustering,\n                        drawSummary=TRUE, \n                        sumFun=mean_cl_boot,\n                        ncol=NULL, \n                        nrow=NULL, \n                        row_samples=NULL, \n                        callout_ids=NULL){\n  .Deprecated(\"plot_genes_heatmap\")\n  m <- as.data.frame(clustering$exprs)\n  m$ids <- rownames(clustering$exprs)\n  if (is.null(clustering$labels) == FALSE)\n  {\n    m$cluster = factor(clustering$labels[clustering$clustering], levels = levels(clustering$labels))\n  }else{\n    m$cluster <- factor(clustering$clustering)\n  }\n  \n  cluster_sizes <- as.data.frame(table(m$cluster))    \n  \n  cluster_sizes$Freq <- paste(\"(\", cluster_sizes$Freq, \")\")   \n  facet_labels <- str_join(cluster_sizes$Var1, cluster_sizes$Freq, sep=\" \") #update the function\n\n  m.melt <- melt(m, id.vars = c(\"ids\", \"cluster\"))\n  \n  m.melt <- merge(m.melt, pData(cds), by.x=\"variable\", by.y=\"row.names\")\n  \n  \n  if (is.null(row_samples) == FALSE){\n    m.melt <- m.melt[sample(nrow(m.melt), row_samples),]\n  }\n  \n  c <- ggplot(m.melt) + facet_wrap(\"cluster\", ncol=ncol, nrow=nrow, scales=\"free_y\")\n  #c <- c + stat_density2d(aes(x = Pseudotime, y = value), geom=\"polygon\", fill=\"white\", color=\"black\", size=I(0.1)) + facet_wrap(\"cluster\", ncol=ncol, nrow=nrow)\n    \n  if (drawSummary) {\n    c <- c + stat_summary(aes(x = Pseudotime, y = value, group = 1),\n                          fun.data = sumFun, color = \"red\",\n                          alpha = 0.2, size = 0.5, geom = \"smooth\")\n  }\n  \n  #cluster_medians <- subset(m.melt, ids %in% clustering$medoids)\n  \n  #c <- c + geom_line()\n  #c <- c + geom_line(aes(x=Pseudotime, y=value), data=cluster_medians, color=I(\"red\"))\n  c <- c + scale_color_hue(l = 50, h.start = 200) + theme(axis.text.x = element_text(angle = 0, \n                                                                                     hjust = 0)) + xlab(\"Pseudo-time\") + ylab(\"Expression\")\n  c <- c + theme(strip.background = element_rect(colour = 'white', fill = 'white')) + \n    theme(panel.border = element_blank()) +\n    theme(legend.position=\"none\") +\n    theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) +\n    theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank())\n  \n  #   if (draw_cluster_size){\n  #     cluster_sizes <- as.data.frame(table(m$cluster))\n  #     colnames(cluster_sizes) <- c(\"cluster\", \"Freq\")\n  #     cluster_sizes <- cbind (cluster_sizes, Pseudotime = cluster_label_text_x, value = cluster_label_text_y)\n  #     c <- c + geom_text(aes(x=Pseudotime, y=value, label=Freq), data=cluster_sizes, size=cluster_label_text_size)\n  #   }\n  \n  if (is.null(callout_ids) == FALSE)\n  {\n    callout_melt <- subset(m.melt, ids %in% callout_ids)\n    c <- c + geom_line(aes(x=Pseudotime, y=value), data=callout_melt, color=I(\"steelblue\"))\n  }\n  c <- c + monocle_theme_opts()\n  #c <- facet_wrap_labeller(c, facet_labels)\n  c\n}\n# \n# #' Plots a pseudotime-ordered, row-centered heatmap\n# #' @export \n# plot_genes_heatmap <- function(cds, \n#                                rescaling='row', \n#                                clustering='row', \n#                                labCol=FALSE, \n#                                labRow=TRUE, \n#                                logMode=TRUE, \n#                                use_vst=TRUE,\n#                                border=FALSE, \n#                                heatscale=c(low='steelblue',mid='white',high='tomato'), \n#                                heatMidpoint=0,\n#                                method=\"none\",\n#                                scaleMax=2, \n#                                scaleMin=-2, \n#                                relative_expr=TRUE, \n#                                ...){\n#   \n#   ## the function can be be viewed as a two step process\n#   ## 1. using the rehape package and other funcs the data is clustered, scaled, and reshaped\n#   ## using simple options or by a user supplied function\n#   ## 2. with the now resahped data the plot, the chosen labels and plot style are built\n#   FM <- exprs(cds)\n#   \n#   if (cds@expressionFamily@vfamily %in% c(\"negbinomial\", \"negbinomial.size\")){\n#     integer_expression <- TRUE\n#   }else{\n#     integer_expression <- FALSE\n#     relative_expr <- TRUE\n#   }\n#   \n#   if (integer_expression)\n#   {\n#     if (relative_expr){\n#       if (is.null(sizeFactors(cds)))\n#       {\n#         stop(\"Error: you must call estimateSizeFactors() first\")\n#       }\n#       FM <- Matrix::t(Matrix::t(FM) / sizeFactors(cds))\n#     }\n#     FM <- round(FM)\n#   }\n#   \n#   m=FM\n#   \n#   if (is.null(fData(cds)$gene_short_name) == FALSE){\n#     feature_labels <- fData(cds)$gene_short_name\n#     feature_labels[is.na(feature_labels)]  <- fData(cds)$f_id\n#     row.names(m) <- feature_labels\n#   }\n#   \n#   #remove genes with no expression in any condition\n#   m=m[!apply(m,1,sum)==0,]\n#   \n#   if (use_vst && is.null(cds@dispFitInfo[[\"blind\"]]$disp_func) == FALSE){\n#     m = vstExprs(cds, expr_matrix=m)\n#   }else if(logMode){\n#     m = log10(m+pseudocount)\n#   }\n#   \n#   #remove genes with no sd\n#   #m=m[!apply(m,1,sd)==0,]\n# \n#   ## you can either scale by row or column not both! \n#   ## if you wish to scale by both or use a different scale method then simply supply a scale\n#   ## function instead NB scale is a base funct\n#   \n#   ## I have supplied the default cluster and euclidean distance (JSdist) - and chose to cluster after scaling\n#   ## if you want a different distance/cluster method-- or to cluster and then scale\n#   ## then you can supply a custom function \n#   \n#   if(!is.function(method)){\n#     method = function(mat){as.dist((1 - cor(Matrix::t(mat)))/2)}\t\n#   }\n#   \n#   ## this is just reshaping into a ggplot format matrix and making a ggplot layer\n#   \n#   if(is.function(rescaling))\n#   { \n#     m=rescaling(m)\n#   } else {\n#     if(rescaling=='column'){\n#       m=m[!apply(m,2,sd)==0,]\n#       m=scale(m, center=TRUE)\n#       m[is.nan(m)] = 0\n#       m[m>scaleMax] = scaleMax\n#       m[m<scaleMin] = scaleMin\n#     }\n#     if(rescaling=='row'){ \n#       m=m[!apply(m,1,sd)==0,]\n#       m=Matrix::t(scale(Matrix::t(m),center=TRUE))\n#       m[is.nan(m)] = 0\n#       m[m>scaleMax] = scaleMax\n#       m[m<scaleMin] = scaleMin\n#     }\n#   }\n#   \n#   # If we aren't going to re-ordering the columns, order them by Pseudotime\n#   if (clustering %in% c(\"row\", \"none\"))\n#     m = m[,row.names(pData(cds)[order(-pData(cds)$Pseudotime),])]\n#   \n#   if(clustering=='row')\n#     m=m[hclust(method(m))$order, ]\n#   if(clustering=='column')  \n#     m=m[,hclust(method(Matrix::t(m)))$order]\n#   if(clustering=='both')\n#     m=m[hclust(method(m))$order ,hclust(method(Matrix::t(m)))$order]\n#   \n#   \n#   rows=dim(m)[1]\n#   cols=dim(m)[2]\n#   \n#   \n#   \n#   # if(logMode) {\n#   #   melt.m=cbind(rowInd=rep(1:rows, times=cols), colInd=rep(1:cols, each=rows), reshape2::melt( log10(m+pseudocount)))\n#   # }else{\n#   #   melt.m=cbind(rowInd=rep(1:rows, times=cols), colInd=rep(1:cols, each=rows), reshape2::melt(m))\n#   # }\n#   \n#   melt.m=cbind(rowInd=rep(1:rows, times=cols), colInd=rep(1:cols, each=rows), reshape2::melt(m))\n#   \n#   g=ggplot(data=melt.m)\n#   \n#   ## add the heat tiles with or without a white border for clarity\n#   \n#   if(border==TRUE)\n#     g2=g+geom_raster(aes(x=colInd,y=rowInd, fill=value),colour='grey')\n#   if(border==FALSE)\n#     g2=g+geom_raster(aes(x=colInd,y=rowInd,ymax=rowInd, fill=value))\n#   \n#   ## add axis labels either supplied or from the colnames rownames of the matrix\n#   \n#   if(labCol==TRUE) \n#   {\n#     g2=g2+scale_x_continuous(breaks=(1:cols)-0.5, labels=colnames(m))\n#   }\n#   if(labCol==FALSE) \n#   {\n#     g2=g2+scale_x_continuous(breaks=(1:cols)-0.5, labels=rep('',cols))\n#   }\n#   \n#   \n#   if(labRow==TRUE) \n#   {\n#     g2=g2+scale_y_continuous(breaks=(1:rows)-0.5, labels=rownames(m))\t\n#   }\n#   if(labRow==FALSE)\n#   { \n#     g2=g2+scale_y_continuous(breaks=(1:rows)-0.5, labels=rep('',rows))\t\n#   }\n#   \n#   # Get rid of the ticks, they get way too dense with lots of rows\n#   g2 <- g2 + theme(axis.ticks = element_blank()) \n#   \n#   ## get rid of grey panel background and gridlines\n#   \n#   g2=g2+theme(panel.grid.minor=element_line(colour=NA), panel.grid.major=element_line(colour=NA),\n#               panel.background=element_rect(fill=NA, colour=NA))\n#   \n#   ##adjust x-axis labels\n#   g2=g2+theme(axis.text.x=element_text(angle=-90, hjust=0))\n#   \n#   #write(paste(c(\"Length of heatscale is :\", length(heatscale))), stderr())\n#   \n#   if(is.function(rescaling))\n#   {\n#     \n#   }else{ \n#     if(rescaling=='row' || rescaling == 'column'){\n#       legendTitle <- \"Relative\\nexpression\"\n#     }else{\n#       if (logMode)\n#       {\n#         legendTitle <- bquote(paste(log[10],\" FPKM + \",.(pseudocount),sep=\"\"))\n#         #legendTitle <- paste(expression(plain(log)[10]),\" FPKM + \",pseudocount,sep=\"\")\n#       } else {\n#         legendTitle <- \"FPKM\"\n#       }\n#     }\n#   }\n#   \n#   if (length(heatscale) == 2){\n#     g2 <- g2 + scale_fill_gradient(low=heatscale[1], high=heatscale[2], name=legendTitle)\n#   } else if (length(heatscale) == 3) {\n#     if (is.null(heatMidpoint))\n#     {\n#       heatMidpoint = (max(m) + min(m)) / 2.0\n#       #write(heatMidpoint, stderr())\n#     }\n#     g2 <- g2 + theme(panel.border = element_blank())\n#     g2 <- g2 + scale_fill_gradient2(low=heatscale[1], mid=heatscale[2], high=heatscale[3], midpoint=heatMidpoint, name=legendTitle)\n#   }else {\n#     g2 <- g2 + scale_fill_gradientn(colours=heatscale, name=legendTitle)\n#   }\n#   \n#   #g2<-g2+scale_x_discrete(\"\",breaks=tracking_ids,labels=gene_short_names)\n#   \n#   g2 <- g2 + theme(axis.title.x=element_blank(), axis.title.y=element_blank())\n#   \n#   ## finally add the fill colour ramp of your choice (default is blue to red)-- and return\n#   return (g2)\n# }\n\n\nplot_genes_heatmap <- function(...){\n  .Deprecated(\"plot_pseudotime_heatmap\")\n  plot_pseudotime_heatmap(...)\n}\n\n#' Plots a pseudotime-ordered, row-centered heatmap\n#' \n#' @description The function plot_pseudotime_heatmap takes a CellDataSet object \n#' (usually containing a only subset of significant genes) and generates smooth expression \n#' curves much like plot_genes_in_pseudotime. \n#' Then, it clusters these genes and plots them using the pheatmap package. \n#' This allows you to visualize modules of genes that co-vary across pseudotime.\n#' \n#' @param cds_subset CellDataSet for the experiment (normally only the branching genes detected with branchTest)\n#' @param cluster_rows Whether to cluster the rows of the heatmap.\n#' @param hclust_method The method used by pheatmap to perform hirearchical clustering of the rows. \n#' @param num_clusters Number of clusters for the heatmap of branch genes\n#' @param hmcols The color scheme for drawing the heatmap.\n#' @param add_annotation_row Additional annotations to show for each row in the heatmap. Must be a dataframe with one row for each row in the fData table of cds_subset, with matching IDs.\n#' @param add_annotation_col Additional annotations to show for each column in the heatmap. Must be a dataframe with one row for each cell in the pData table of cds_subset, with matching IDs.\n#' @param show_rownames Whether to show the names for each row in the table.\n#' @param use_gene_short_name Whether to use the short names for each row. If FALSE, uses row IDs from the fData table.\n#' @param scale_max The maximum value (in standard deviations) to show in the heatmap. Values larger than this are set to the max.\n#' @param scale_min The minimum value (in standard deviations) to show in the heatmap. Values smaller than this are set to the min.\n#' @param norm_method Determines how to transform expression values prior to rendering\n#' @param trend_formula A formula string specifying the model used in fitting the spline curve for each gene/feature.\n#' @param return_heatmap Whether to return the pheatmap object to the user. \n#' @param cores Number of cores to use when smoothing the expression curves shown in the heatmap.\n#' @return A list of heatmap_matrix (expression matrix for the branch committment), ph (pheatmap heatmap object),\n#' annotation_row (annotation data.frame for the row), annotation_col (annotation data.frame for the column). \n#' @import pheatmap\n#' @importFrom stats sd as.dist cor cutree\n#' @export\n#'\n\nplot_pseudotime_heatmap <- function(cds_subset, \n                                    \n                                    cluster_rows = TRUE,\n                                    hclust_method = \"ward.D2\", \n                                    num_clusters = 6,\n                                    \n                                    hmcols = NULL, \n                                    \n                                    add_annotation_row = NULL,\n                                    add_annotation_col = NULL,\n                                    show_rownames = FALSE, \n                                    use_gene_short_name = TRUE,\n                                    \n                                    norm_method = c(\"log\", \"vstExprs\"), \n                                    scale_max=3, \n                                    scale_min=-3, \n                                    \n                                    trend_formula = '~sm.ns(Pseudotime, df=3)',\n                                    \n                                    return_heatmap=FALSE,\n                                    cores=1){\n  \n  pseudocount <- 1\n  newdata <- data.frame(Pseudotime = seq(min(pData(cds_subset)$Pseudotime), max(pData(cds_subset)$Pseudotime),length.out = 100)) \n  \n  m <- genSmoothCurves(cds_subset, cores=cores, trend_formula = trend_formula,  \n                       relative_expr = T, new_data = newdata)\n  \n\n  #remove genes with no expression in any condition\n  m=m[!apply(m,1,sum)==0,]\n  \n  norm_method <- match.arg(norm_method)\n  \n  # FIXME: this needs to check that vst values can even be computed. (They can only be if we're using NB as the expressionFamily)\n  if(norm_method == 'vstExprs' && is.null(cds_subset@dispFitInfo[[\"blind\"]]$disp_func) == FALSE) {\n    m = vstExprs(cds_subset, expr_matrix=m)\n  }     \n  else if(norm_method == 'log') {\n    m = log10(m+pseudocount)\n  }\n  \n  # Row-center the data.\n  m=m[!apply(m,1,sd)==0,]\n  m=Matrix::t(scale(Matrix::t(m),center=TRUE))\n  m=m[is.na(row.names(m)) == FALSE,]\n  m[is.nan(m)] = 0\n  m[m>scale_max] = scale_max\n  m[m<scale_min] = scale_min\n\n  heatmap_matrix <- m\n  \n  row_dist <- as.dist((1 - cor(Matrix::t(heatmap_matrix)))/2)\n  row_dist[is.na(row_dist)] <- 1\n  \n  if(is.null(hmcols)) {\n    bks <- seq(-3.1,3.1, by = 0.1)\n    hmcols <- blue2green2red(length(bks) - 1)\n  }\n  else {\n    bks <- seq(-3.1,3.1, length.out = length(hmcols))\n  } \n  \n  ph <- pheatmap(heatmap_matrix, \n                 useRaster = T,\n                 cluster_cols=FALSE, \n                 cluster_rows=cluster_rows, \n                 show_rownames=F, \n                 show_colnames=F, \n                 clustering_distance_rows=row_dist,\n                 clustering_method = hclust_method,\n                 cutree_rows=num_clusters,\n                 silent=TRUE,\n                 filename=NA,\n                 breaks=bks,\n                 color=hmcols)\n\n  annotation_row <- data.frame(Cluster=factor(cutree(ph$tree_row, num_clusters)))\n \n  if(!is.null(add_annotation_row)) {\n    old_colnames_length <- ncol(annotation_row)\n    annotation_row <- cbind(annotation_row, add_annotation_row[row.names(annotation_row), ])  \n    colnames(annotation_row)[(old_colnames_length+1):ncol(annotation_row)] <- colnames(add_annotation_row)\n    # annotation_row$bif_time <- add_annotation_row[as.character(fData(absolute_cds[row.names(annotation_row), ])$gene_short_name), 1]\n  }\n  \n  \n  if (use_gene_short_name == TRUE) {\n    if (is.null(fData(cds_subset)$gene_short_name) == FALSE) {\n      feature_label <- as.character(fData(cds_subset)[row.names(heatmap_matrix), 'gene_short_name'])\n      feature_label[is.na(feature_label)] <- row.names(heatmap_matrix)\n      \n      row_ann_labels <- as.character(fData(cds_subset)[row.names(annotation_row), 'gene_short_name'])\n      row_ann_labels[is.na(row_ann_labels)] <- row.names(annotation_row)\n    }\n    else {\n      feature_label <- row.names(heatmap_matrix)\n      row_ann_labels <- row.names(annotation_row)\n    }\n  }\n  else {\n    feature_label <- row.names(heatmap_matrix)\n    row_ann_labels <- row.names(annotation_row)\n  }\n  \n  row.names(heatmap_matrix) <- feature_label\n  row.names(annotation_row) <- row_ann_labels\n  \n  \n  colnames(heatmap_matrix) <- c(1:ncol(heatmap_matrix))\n  \n  ph_res <- pheatmap(heatmap_matrix[, ], #ph$tree_row$order\n                     useRaster = T,\n                     cluster_cols = FALSE, \n                     cluster_rows = cluster_rows, \n                     show_rownames=show_rownames, \n                     show_colnames=F, \n                     #scale=\"row\",\n                     clustering_distance_rows=row_dist, #row_dist\n                     clustering_method = hclust_method, #ward.D2\n                     cutree_rows=num_clusters,\n                     # cutree_cols = 2,\n                     annotation_row=annotation_row,\n                     treeheight_row = 20, \n                     breaks=bks,\n                     fontsize = 6,\n                     color=hmcols, \n                     silent=TRUE,\n                     filename=NA\n  )\n  \n  grid::grid.rect(gp=grid::gpar(\"fill\", col=NA))\n  grid::grid.draw(ph_res$gtable)\n  if (return_heatmap){\n    return(ph_res)\n  }\n}\n\n\n#' Plot the branch genes in pseduotime with separate branch curves.\n#' \n#' @description Works similarly to plot_genes_in_psuedotime esceptit shows \n#' one kinetic trend for each lineage. \n#' \n#' @details This plotting function is used to make the branching plots for a branch dependent gene goes through the progenitor state\n#' and bifurcating into two distinct branchs (Similar to the pitch-fork bifurcation in dynamic systems). In order to make the  \n#' bifurcation plot, we first duplicated the progenitor states and by default stretch each branch into maturation level 0-100.  \n#' Then we fit two nature spline curves for each branchs using VGAM package.  \n#'\n#' @param cds CellDataSet for the experiment\n#' @param branch_states The states for two branching branchs\n#' @param branch_point The ID of the branch point to analyze. Can only be used when reduceDimension is called with method = \"DDRTree\".\n#' @param branch_labels The names for each branching branch\n#' @param method The method to draw the curve for the gene expression branching pattern, either loess ('loess') or VGLM fitting ('fitting') \n#' @param min_expr The minimum (untransformed) expression level to use in plotted the genes.\n#' @param cell_size The size (in points) of each cell used in the plot\n#' @param nrow Number of columns used to layout the faceted cluster panels\n#' @param ncol Number of columns used to layout the faceted cluster panels\n#' @param panel_order The a character vector of gene short names (or IDs, if that's what you're using), specifying order in which genes should be layed out (left-to-right, top-to-bottom)\n#' @param color_by The cell attribute (e.g. the column of pData(cds)) to be used to color each cell \n#' @param expression_curve_linetype_by The cell attribute (e.g. the column of pData(cds)) to be used for the linetype of each branch curve\n#' @param trend_formula The model formula to be used for fitting the expression trend over pseudotime\n#' @param reducedModelFormulaStr A formula specifying a null model. If used, the plot shows a p value from the likelihood ratio test that uses trend_formula as the full model\n#' @param label_by_short_name Whether to label figure panels by gene_short_name (TRUE) or feature id (FALSE)\n#' @param relative_expr Whether or not the plot should use relative expression values (only relevant for CellDataSets using transcript counts)\n#' @param ... Additional arguments passed on to branchTest. Only used when reducedModelFormulaStr is not NULL.\n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom plyr ddply\n#' @importFrom reshape2 melt\n#' @importFrom BiocGenerics sizeFactors\n#' @export \nplot_genes_branched_pseudotime <- function (cds, \n                                            branch_states = NULL, \n                                            branch_point=1,\n                                            branch_labels = NULL,\n                                            method = \"fitting\", \n                                            min_expr = NULL, \n                                            cell_size = 0.75,\n                                            nrow = NULL, \n                                            ncol = 1, \n                                            panel_order = NULL, \n                                            color_by = \"State\",\n                                            expression_curve_linetype_by = \"Branch\", \n                                            trend_formula = \"~ sm.ns(Pseudotime, df=3) * Branch\", \n                                            reducedModelFormulaStr = NULL, \n                                            label_by_short_name = TRUE,\n                                            relative_expr = TRUE,\n                                            #gene_pairs = NULL,\n                                            ...)\n{\n  Branch <- NA  \n  if (is.null(reducedModelFormulaStr) == FALSE) {\n    pval_df <- branchTest(cds, \n                          branch_states=branch_states,\n                          branch_point=branch_point,\n                          fullModelFormulaStr = trend_formula,\n                          reducedModelFormulaStr = \"~ sm.ns(Pseudotime, df=3)\", \n                          ...)\n    fData(cds)[, \"pval\"] <- pval_df[row.names(cds), 'pval']\n  }\n  if(\"Branch\" %in% all.vars(terms(as.formula(trend_formula)))) { #only when Branch is in the model formula we will duplicate the \"progenitor\" cells\n    cds_subset <- buildBranchCellDataSet(cds = cds, \n                                         branch_states = branch_states, \n                                         branch_point=branch_point,\n                                         branch_labels = branch_labels, \n                                         progenitor_method = 'duplicate',\n                                         ...)\n  }\n  else {\n    cds_subset <- cds\n    pData(cds_subset)$Branch <- pData(cds_subset)$State\n  }\n  if (cds_subset@expressionFamily@vfamily %in% c(\"negbinomial\", \"negbinomial.size\")) {\n    integer_expression <- TRUE\n  }\n  else {\n    integer_expression <- FALSE\n  }\n  if (integer_expression) {\n    CM <- exprs(cds_subset)\n    if (relative_expr){\n      if (is.null(sizeFactors(cds_subset))) {\n        stop(\"Error: to call this function with relative_expr=TRUE, you must call estimateSizeFactors() first\")\n      }\n      CM <- Matrix::t(Matrix::t(CM)/sizeFactors(cds_subset))\n    }\n    cds_exprs <- reshape2::melt(round(as.matrix(CM)))\n  }\n  else {\n    cds_exprs <- reshape2::melt(exprs(cds_subset))\n  }\n  if (is.null(min_expr)) {\n    min_expr <- cds_subset@lowerDetectionLimit\n  }\n  colnames(cds_exprs) <- c(\"f_id\", \"Cell\", \"expression\")\n  cds_pData <- pData(cds_subset)\n  \n  cds_fData <- fData(cds_subset)\n  cds_exprs <- merge(cds_exprs, cds_fData, by.x = \"f_id\", by.y = \"row.names\")\n  cds_exprs <- merge(cds_exprs, cds_pData, by.x = \"Cell\", by.y = \"row.names\")\n  if (integer_expression) {\n    cds_exprs$adjusted_expression <- round(cds_exprs$expression)\n  }\n  else {\n    cds_exprs$adjusted_expression <- log10(cds_exprs$expression)\n  }\n  if (label_by_short_name == TRUE) {\n    if (is.null(cds_exprs$gene_short_name) == FALSE) {\n      cds_exprs$feature_label <- as.character(cds_exprs$gene_short_name)\n      cds_exprs$feature_label[is.na(cds_exprs$feature_label)] <- cds_exprs$f_id\n    }\n    else {\n      cds_exprs$feature_label <- cds_exprs$f_id\n    }\n  }\n  else {\n    cds_exprs$feature_label <- cds_exprs$f_id\n  }\n  cds_exprs$feature_label <- as.factor(cds_exprs$feature_label)\n  # trend_formula <- paste(\"adjusted_expression\", trend_formula,\n  #     sep = \"\")\n  cds_exprs$Branch <- as.factor(cds_exprs$Branch) \n  \n  new_data <- data.frame(Pseudotime = pData(cds_subset)$Pseudotime, Branch = pData(cds_subset)$Branch)\n  \n  full_model_expectation <- genSmoothCurves(cds_subset, cores=1, trend_formula = trend_formula, \n                                            relative_expr = T, new_data = new_data)\n  colnames(full_model_expectation) <- colnames(cds_subset)\n  \n  cds_exprs$full_model_expectation <- apply(cds_exprs,1, function(x) full_model_expectation[x[2], x[1]])\n  if(!is.null(reducedModelFormulaStr)){\n    reduced_model_expectation <- genSmoothCurves(cds_subset, cores=1, trend_formula = reducedModelFormulaStr,\n                                                 relative_expr = T, new_data = new_data)\n    colnames(reduced_model_expectation) <- colnames(cds_subset)\n    cds_exprs$reduced_model_expectation <- apply(cds_exprs,1, function(x) reduced_model_expectation[x[2], x[1]])\n  }\n  \n  # FIXME: If you want to show the bifurcation time for each gene, this function\n  # should just compute it. Passing it in as a dataframe is just too complicated\n  # and will be hard on the user. \n  # if(!is.null(bifurcation_time)){\n  #     cds_exprs$bifurcation_time <- bifurcation_time[as.vector(cds_exprs$gene_short_name)]\n  # }\n  if (method == \"loess\")\n    cds_exprs$expression <- cds_exprs$expression + cds@lowerDetectionLimit\n  if (label_by_short_name == TRUE) {\n    if (is.null(cds_exprs$gene_short_name) == FALSE) {\n      cds_exprs$feature_label <- as.character(cds_exprs$gene_short_name)\n      cds_exprs$feature_label[is.na(cds_exprs$feature_label)] <- cds_exprs$f_id\n    }\n    else {\n      cds_exprs$feature_label <- cds_exprs$f_id\n    }\n  }\n  else {\n    cds_exprs$feature_label <- cds_exprs$f_id\n  }\n  cds_exprs$feature_label <- factor(cds_exprs$feature_label)\n  if (is.null(panel_order) == FALSE) {\n    cds_exprs$feature_label <- factor(cds_exprs$feature_label,\n                                      levels = panel_order)\n  }\n  cds_exprs$expression[is.na(cds_exprs$expression)] <- min_expr\n  cds_exprs$expression[cds_exprs$expression < min_expr] <- min_expr\n  cds_exprs$full_model_expectation[is.na(cds_exprs$full_model_expectation)] <- min_expr\n  cds_exprs$full_model_expectation[cds_exprs$full_model_expectation < min_expr] <- min_expr\n  \n  if(!is.null(reducedModelFormulaStr)){\n    cds_exprs$reduced_model_expectation[is.na(cds_exprs$reduced_model_expectation)] <- min_expr\n    cds_exprs$reduced_model_expectation[cds_exprs$reduced_model_expectation < min_expr] <- min_expr\n  }\n  \n  cds_exprs$State <- as.factor(cds_exprs$State)\n  cds_exprs$Branch <- as.factor(cds_exprs$Branch)\n  \n  q <- ggplot(aes(Pseudotime, expression), data = cds_exprs)\n  # if (!is.null(bifurcation_time)) {\n  #   q <- q + geom_vline(aes(xintercept = bifurcation_time),\n  #                       color = \"black\", linetype = \"longdash\")\n  # }\n  if (is.null(color_by) == FALSE) {\n    q <- q + geom_point(aes_string(color = color_by), size = I(cell_size))\n  }\n  if (is.null(reducedModelFormulaStr) == FALSE)\n    q <- q + scale_y_log10() + facet_wrap(~feature_label +\n                                            pval, nrow = nrow, ncol = ncol, scales = \"free_y\")\n  else q <- q + scale_y_log10() + facet_wrap(~feature_label,\n                                             nrow = nrow, ncol = ncol, scales = \"free_y\")\n  if (method == \"loess\")\n    q <- q + stat_smooth(aes(fill = Branch, color = Branch),\n                         method = \"loess\")\n  else if (method == \"fitting\") {\n    q <- q + geom_line(aes_string(x = \"Pseudotime\", y = \"full_model_expectation\",\n                                  linetype = \"Branch\"), data = cds_exprs) #+ scale_color_manual(name = \"Type\", values = c(colour_cell, colour), labels = c(\"Pre-branch\", \"AT1\", \"AT2\", \"AT1\", \"AT2\")\n  }\n  \n  if(!is.null(reducedModelFormulaStr)) {\n    q <- q + geom_line(aes_string(x = \"Pseudotime\", y = \"reduced_model_expectation\"),\n                       color = 'black', linetype = 2, data =  cds_exprs)   \n  }\n  \n  q <- q + ylab(\"Expression\") + xlab(\"Pseudotime (stretched)\")\n  \n  q <- q + monocle_theme_opts()\n  q + expand_limits(y = min_expr)\n}\n\n#' Not sure we're ready to release this one quite yet:\n#' Plot the branch genes in pseduotime with separate branch curves \n#' @param cds CellDataSet for the experiment\n#' @param rowgenes Gene ids or short names to be arrayed on the vertical axis.\n#' @param colgenes Gene ids or short names to be arrayed on the horizontal axis\n#' @param relative_expr Whether to transform expression into relative values\n#' @param min_expr The minimum level of expression to show in the plot\n#' @param cell_size A number how large the cells should be in the plot\n#' @param label_by_short_name a boolean that indicates whether cells should be labeled by their short name\n#' @param show_density a boolean that indicates whether a 2D density estimation should be shown in the plot\n#' @param round_expr a boolean that indicates whether cds_expr values should be rounded or not\n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom reshape2 melt\nplot_coexpression_matrix <- function(cds, \n                                     rowgenes, \n                                     colgenes, \n                                     relative_expr=TRUE, \n                                     min_expr=NULL, \n                                     cell_size=0.85, \n                                     label_by_short_name=TRUE,\n                                     show_density=TRUE,\n                                     round_expr=FALSE){\n  \n  gene_short_name <- NA\n  f_id <- NA\n  adjusted_expression.x <- NULL\n  adjusted_expression.y <- NULL\n  ..density.. <- NULL\n  \n  \n  row_gene_ids <- row.names(subset(fData(cds), gene_short_name %in% rowgenes))\n  row_gene_ids <- union(row_gene_ids, intersect(rowgenes, row.names(fData(cds))))\n  \n  col_gene_ids <- row.names(subset(fData(cds), gene_short_name %in% colgenes))\n  col_gene_ids <- union(col_gene_ids, intersect(colgenes, row.names(fData(cds))))\n  \n  cds_subset <- cds[union(row_gene_ids, col_gene_ids),]\n  \n  if (cds_subset@expressionFamily@vfamily %in% c(\"negbinomial\", \"negbinomial.size\")){\n    integer_expression <- TRUE\n  }else{\n    integer_expression <- FALSE\n    relative_expr <- TRUE\n  }\n  \n  if (integer_expression)\n  {\n    cds_exprs <- exprs(cds_subset)\n    if (relative_expr){\n      if (is.null(sizeFactors(cds_subset)))\n      {\n        stop(\"Error: to call this function with relative_expr=TRUE, you must call estimateSizeFactors() first\")\n      }\n      cds_exprs <- Matrix::t(Matrix::t(cds_exprs) / sizeFactors(cds_subset))\n    }\n    if (round_expr){\n      cds_exprs <- reshape2::melt(round(as.matrix(cds_exprs)))\n    } else {\n      cds_exprs <- reshape2::melt(as.matrix(cds_exprs))\n    }\n      \n  }else{\n    cds_exprs <- reshape2::melt(exprs(cds_subset))\n  }\n  if (is.null(min_expr)){\n    min_expr <- cds_subset@lowerDetectionLimit\n  }\n  \n  colnames(cds_exprs) <- c(\"f_id\", \"Cell\", \"expression\")\n  cds_exprs$expression[cds_exprs$expression < min_expr] <- min_expr\n  \n  cds_pData <- pData(cds_subset)\n  cds_fData <- fData(cds_subset)\n  \n  cds_exprs <- merge(cds_exprs, cds_fData, by.x=\"f_id\", by.y=\"row.names\")\n  \n  cds_exprs$adjusted_expression <- cds_exprs$expression\n\n  #cds_exprs$adjusted_expression <- log10(cds_exprs$adjusted_expression + abs(rnorm(nrow(cds_exprs), min_expr, sqrt(min_expr))))\n  \n  if (label_by_short_name == TRUE){\n    if (is.null(cds_exprs$gene_short_name) == FALSE){\n      cds_exprs$feature_label <- as.character(cds_exprs$gene_short_name)\n      cds_exprs$feature_label[is.na(cds_exprs$feature_label)]  <- cds_exprs$f_id\n    }else{\n      cds_exprs$feature_label <- cds_exprs$f_id\n    }\n  }else{\n    cds_exprs$feature_label <- cds_exprs$f_id\n  }\n  \n  cds_exprs$feature_label <- factor(cds_exprs$feature_label)\n  \n  row_cds_exprs <- subset(cds_exprs, f_id %in% row_gene_ids)\n  col_cds_exprs <- subset(cds_exprs, f_id %in% col_gene_ids)\n  \n  joined_exprs <- merge(row_cds_exprs, col_cds_exprs, by=\"Cell\")\n  cds_exprs <- joined_exprs\n  \n  cds_exprs <- merge(cds_exprs, cds_pData, by.x=\"Cell\", by.y=\"row.names\")\n  \n  cds_exprs <- subset(cds_exprs, adjusted_expression.x > min_expr | adjusted_expression.y > min_expr)\n  \n  q <- ggplot(aes(adjusted_expression.x, adjusted_expression.y), data=cds_exprs, size=I(1))\n  \n  if (show_density){\n    q <- q + stat_density2d(geom=\"raster\", aes(fill = ..density..), contour = FALSE) + \n      scale_fill_gradient(low=\"white\", high=\"red\") \n  }\n\n  q <- q + scale_x_log10() + scale_y_log10() + \n    geom_point(color=I(\"black\"), size=I(cell_size * 1.50)) +\n    geom_point(color=I(\"white\"), size=I(cell_size)) +\n    facet_grid(feature_label.x ~ feature_label.y, scales=\"free\") \n    #scale_color_brewer(palette=\"Set1\") +\n  \n  if (min_expr < 1)\n  {\n    q <- q + expand_limits(y=c(min_expr, 1), x=c(min_expr, 1))\n  }\n  \n  #q <- q + monocle_theme_opts()\n  \n  q\n}\n\n#The following code is swipped from colorRamps package which is used to make the pallette\ntable.ramp <- function(n, mid = 0.5, sill = 0.5, base = 1, height = 1)\n{\n    x <- seq(0, 1, length.out = n)\n    y <- rep(0, length(x))\n    sill.min <- max(c(1, round((n - 1) * (mid - sill / 2)) + 1))\n    sill.max <- min(c(n, round((n - 1) * (mid + sill / 2)) + 1))\n    y[sill.min:sill.max] <- 1\n    base.min <- round((n - 1) * (mid - base / 2)) + 1\n    base.max <- round((n - 1) * (mid + base / 2)) + 1\n    xi <- base.min:sill.min\n    yi <- seq(0, 1, length.out = length(xi))\n    i <- which(xi > 0 & xi <= n)\n    y[xi[i]] <- yi[i]\n    xi <- sill.max:base.max\n    yi <- seq(1, 0, length.out = length(xi))\n    i <- which(xi > 0 & xi <= n)\n    y[xi[i]] <- yi[i]\n    height * y\n}\n\n#' @importFrom grDevices rgb\nrgb.tables <- function(n,\nred = c(0.75, 0.25, 1),\ngreen = c(0.5, 0.25, 1),\nblue = c(0.25, 0.25, 1))\n{\n    rr <- do.call(\"table.ramp\", as.list(c(n, red)))\n    gr <- do.call(\"table.ramp\", as.list(c(n, green)))\n    br <- do.call(\"table.ramp\", as.list(c(n, blue)))\n    rgb(rr, gr, br)\n}\n\nmatlab.like <- function(n) rgb.tables(n)\n\nmatlab.like2 <- function(n)\nrgb.tables(n,\nred = c(0.8, 0.2, 1),\ngreen = c(0.5, 0.4, 0.8),\nblue = c(0.2, 0.2, 1))\n\nblue2green2red <- matlab.like2\n\n#'  Create a heatmap to demonstrate the bifurcation of gene expression along two branchs\n#'  \n#'  @description returns a heatmap that shows changes in both lineages at the same time. \n#'  It also requires that you choose a branch point to inspect. \n#'  Columns are points in pseudotime, rows are genes, and the beginning of pseudotime is in the middle of the heatmap. \n#'  As you read from the middle of the heatmap to the right, you are following one lineage through pseudotime. As you read left, the other. \n#'  The genes are clustered hierarchically, so you can visualize modules of genes that have similar lineage-dependent expression patterns.\n#'\n#' @param cds_subset CellDataSet for the experiment (normally only the branching genes detected with branchTest)\n#' @param branch_point The ID of the branch point to visualize. Can only be used when reduceDimension is called with method = \"DDRTree\".\n#' @param branch_states The two states to compare in the heatmap. Mutually exclusive with branch_point. \n#' @param branch_labels The labels for the branchs. \n#' @param cluster_rows Whether to cluster the rows of the heatmap.\n#' @param hclust_method The method used by pheatmap to perform hirearchical clustering of the rows. \n#' @param num_clusters Number of clusters for the heatmap of branch genes\n#' @param hmcols The color scheme for drawing the heatmap.\n#' @param branch_colors The colors used in the annotation strip indicating the pre- and post-branch cells.\n#' @param add_annotation_row Additional annotations to show for each row in the heatmap. Must be a dataframe with one row for each row in the fData table of cds_subset, with matching IDs.\n#' @param add_annotation_col Additional annotations to show for each column in the heatmap. Must be a dataframe with one row for each cell in the pData table of cds_subset, with matching IDs.\n#' @param show_rownames Whether to show the names for each row in the table.\n#' @param use_gene_short_name Whether to use the short names for each row. If FALSE, uses row IDs from the fData table.\n#' @param scale_max The maximum value (in standard deviations) to show in the heatmap. Values larger than this are set to the max.\n#' @param scale_min The minimum value (in standard deviations) to show in the heatmap. Values smaller than this are set to the min.\n#' @param norm_method Determines how to transform expression values prior to rendering\n#' @param trend_formula A formula string specifying the model used in fitting the spline curve for each gene/feature.\n#' @param return_heatmap Whether to return the pheatmap object to the user. \n#' @param cores Number of cores to use when smoothing the expression curves shown in the heatmap.\n#' @param ... Additional arguments passed to buildBranchCellDataSet\n#' @return A list of heatmap_matrix (expression matrix for the branch committment), ph (pheatmap heatmap object),\n#' annotation_row (annotation data.frame for the row), annotation_col (annotation data.frame for the column). \n#' @import pheatmap\n#' @importFrom stats sd as.dist cor cutree\n#' @export\n#'\nplot_genes_branched_heatmap <- function(cds_subset, \n                                        \n                                        branch_point=1,\n                                        branch_states=NULL,\n                                        branch_labels = c(\"Cell fate 1\", \"Cell fate 2\"), \n                                        cluster_rows = TRUE,\n                                        hclust_method = \"ward.D2\", \n                                        num_clusters = 6,\n                                        hmcols = NULL, \n                                        branch_colors = c('#979797', '#F05662', '#7990C8'), \n                                        add_annotation_row = NULL,\n                                        add_annotation_col = NULL,\n                                        show_rownames = FALSE, \n                                        use_gene_short_name = TRUE,\n                                        scale_max=3, \n                                        scale_min=-3, \n                                        norm_method = c(\"log\", \"vstExprs\"), \n                                        \n                                        trend_formula = '~sm.ns(Pseudotime, df=3) * Branch',\n                                        \n                                        return_heatmap=FALSE,\n                                        cores = 1, ...) {\n  \n  cds <- NA\n  new_cds <- buildBranchCellDataSet(cds_subset, \n                                    branch_states=branch_states, \n                                    branch_point=branch_point, \n                                    progenitor_method = 'duplicate',\n                                    ...)\n  \n  new_cds@dispFitInfo <- cds_subset@dispFitInfo\n  \n  if(is.null(branch_states)) {\n    progenitor_state <- subset(pData(cds_subset), Pseudotime == 0)[, 'State']\n    branch_states <- setdiff(pData(cds_subset)$State, progenitor_state)\n  }\n  \n  col_gap_ind <- 101\n  # newdataA <- data.frame(Pseudotime = seq(0, 100, length.out = 100))\n  # newdataB <- data.frame(Pseudotime = seq(0, 100, length.out = 100))\n  \n  newdataA <- data.frame(Pseudotime = seq(0, 100,\n                                          length.out = 100), Branch = as.factor(unique(as.character(pData(new_cds)$Branch))[1]))   \n  newdataB <- data.frame(Pseudotime = seq(0, 100,\n                                          length.out = 100), Branch = as.factor(unique(as.character(pData(new_cds)$Branch))[2]))\n  \n  BranchAB_exprs <- genSmoothCurves(new_cds[, ], cores=cores, trend_formula = trend_formula,  \n                                    relative_expr = T, new_data = rbind(newdataA, newdataB))\n  \n  BranchA_exprs <- BranchAB_exprs[, 1:100]\n  BranchB_exprs <- BranchAB_exprs[, 101:200]\n  \n  #common_ancestor_cells <- row.names(pData(new_cds)[duplicated(pData(new_cds)$original_cell_id),])\n  common_ancestor_cells <- row.names(pData(new_cds)[pData(new_cds)$State == setdiff(pData(new_cds)$State, branch_states),])\n  BranchP_num <- (100 - floor(max(pData(new_cds)[common_ancestor_cells, 'Pseudotime'])))\n  BranchA_num <- floor(max(pData(new_cds)[common_ancestor_cells, 'Pseudotime']))\n  BranchB_num <- BranchA_num\n  \n  norm_method <- match.arg(norm_method)\n  \n  # FIXME: this needs to check that vst values can even be computed. (They can only be if we're using NB as the expressionFamily)\n  if(norm_method == 'vstExprs') {\n    BranchA_exprs <- vstExprs(new_cds, expr_matrix=BranchA_exprs)\n    BranchB_exprs <- vstExprs(new_cds, expr_matrix=BranchB_exprs)\n  }     \n  else if(norm_method == 'log') {\n    BranchA_exprs <- log10(BranchA_exprs + 1)\n    BranchB_exprs <- log10(BranchB_exprs + 1)\n  }\n  \n  heatmap_matrix <- cBind(BranchA_exprs[, (col_gap_ind - 1):1], BranchB_exprs)\n  \n  heatmap_matrix=heatmap_matrix[!apply(heatmap_matrix, 1, sd)==0,]\n  heatmap_matrix=Matrix::t(scale(Matrix::t(heatmap_matrix),center=TRUE))\n  heatmap_matrix=heatmap_matrix[is.na(row.names(heatmap_matrix)) == FALSE,]\n  heatmap_matrix[is.nan(heatmap_matrix)] = 0\n  heatmap_matrix[heatmap_matrix>scale_max] = scale_max\n  heatmap_matrix[heatmap_matrix<scale_min] = scale_min\n  \n  heatmap_matrix_ori <- heatmap_matrix\n  heatmap_matrix <- heatmap_matrix[is.finite(heatmap_matrix[, 1]) & is.finite(heatmap_matrix[, col_gap_ind]), ] #remove the NA fitting failure genes for each branch \n  \n  row_dist <- as.dist((1 - cor(Matrix::t(heatmap_matrix)))/2)\n  row_dist[is.na(row_dist)] <- 1\n  \n  exp_rng <- range(heatmap_matrix) #bks is based on the expression range\n  bks <- seq(exp_rng[1] - 0.1, exp_rng[2] + 0.1, by=0.1)\n  if(is.null(hmcols)) {\n    hmcols <- blue2green2red(length(bks) - 1)\n  }\n  \n  # prin  t(hmcols)\n  ph <- pheatmap(heatmap_matrix, \n                 useRaster = T,\n                 cluster_cols=FALSE, \n                 cluster_rows=TRUE, \n                 show_rownames=F, \n                 show_colnames=F, \n                 #scale=\"row\",\n                 clustering_distance_rows=row_dist,\n                 clustering_method = hclust_method,\n                 cutree_rows=num_clusters,\n                 silent=TRUE,\n                 filename=NA,\n                 breaks=bks,\n                 color=hmcols\n                 #color=hmcols#,\n                 # filename=\"expression_pseudotime_pheatmap.pdf\",\n  )\n  #save(heatmap_matrix, row_dist, num_clusters, hmcols, ph, branchTest_df, qval_lowest_thrsd, branch_labels, BranchA_num, BranchP_num, BranchB_num, file = 'heatmap_matrix')\n  \n  annotation_row <- data.frame(Cluster=factor(cutree(ph$tree_row, num_clusters)))\n  \n  if(!is.null(add_annotation_row)) {\n    annotation_row <- cbind(annotation_row, add_annotation_row[row.names(annotation_row), ])  \n    # annotation_row$bif_time <- add_annotation_row[as.character(fData(absolute_cds[row.names(annotation_row), ])$gene_short_name), 1]\n  }\n  \n  colnames(heatmap_matrix) <- c(1:ncol(heatmap_matrix))\n  annotation_col <- data.frame(row.names = c(1:ncol(heatmap_matrix)), \"Cell Type\" = c(rep(branch_labels[1], BranchA_num),\n                                                                                      rep(\"Pre-branch\",  2 * BranchP_num),\n                                                                                      rep(branch_labels[2], BranchB_num)))\n  \n  colnames(annotation_col) <- \"Cell Type\"  \n  \n  if(!is.null(add_annotation_col)) {\n    annotation_col <- cbind(annotation_col, add_annotation_col[fData(cds[row.names(annotation_col), ])$gene_short_name, 1])  \n  }\n  \n  names(branch_colors) <- c(\"Pre-branch\", branch_labels[1], branch_labels[2])\n  \n  annotation_colors=list(\"Cell Type\"=branch_colors)\n  \n  names(annotation_colors$`Cell Type`) = c('Pre-branch', branch_labels)\n  \n  if (use_gene_short_name == TRUE) {\n    if (is.null(fData(cds_subset)$gene_short_name) == FALSE) {\n      feature_label <- as.character(fData(cds_subset)[row.names(heatmap_matrix), 'gene_short_name'])\n      feature_label[is.na(feature_label)] <- row.names(heatmap_matrix)\n      \n      row_ann_labels <- as.character(fData(cds_subset)[row.names(annotation_row), 'gene_short_name'])\n      row_ann_labels[is.na(row_ann_labels)] <- row.names(annotation_row)\n    }\n    else {\n      feature_label <- row.names(heatmap_matrix)\n      row_ann_labels <- row.names(annotation_row)\n    }\n  }\n  else {\n    feature_label <- row.names(heatmap_matrix)\n    row_ann_labels <- row.names(annotation_row)\n  }\n  \n  row.names(heatmap_matrix) <- feature_label\n  row.names(annotation_row) <- row_ann_labels\n  \n  ph_res <- pheatmap(heatmap_matrix[, ], #ph$tree_row$order\n                     useRaster = T,\n                     cluster_cols=FALSE, \n                     cluster_rows=TRUE, \n                     show_rownames=show_rownames, \n                     show_colnames=F, \n                     #scale=\"row\",\n                     clustering_distance_rows=row_dist, #row_dist\n                     clustering_method = hclust_method, #ward.D2\n                     cutree_rows=num_clusters,\n                     # cutree_cols = 2,\n                     annotation_row=annotation_row,\n                     annotation_col=annotation_col,\n                     annotation_colors=annotation_colors,\n                     gaps_col = col_gap_ind,\n                     treeheight_row = 20, \n                     breaks=bks,\n                     fontsize = 6,\n                     color=hmcols, \n                     silent=TRUE)\n  \n  grid::grid.rect(gp=grid::gpar(\"fill\", col=NA))\n  grid::grid.draw(ph_res$gtable)\n  if (return_heatmap){\n    return(list(BranchA_exprs = BranchA_exprs, BranchB_exprs = BranchB_exprs, heatmap_matrix = heatmap_matrix, \n                heatmap_matrix_ori = heatmap_matrix_ori, ph = ph, col_gap_ind = col_gap_ind, row_dist = row_dist, hmcols = hmcols, \n                annotation_colors = annotation_colors, annotation_row = annotation_row, annotation_col = annotation_col, \n                ph_res = ph_res))\n  }\n}\n\n#' Plots genes by mean vs. dispersion, highlighting those selected for ordering\n#' \n#' Each gray point in the plot is a gene. The black dots are those that were included\n#' in the last call to setOrderingFilter. The red curve shows the mean-variance \n#' model learning by estimateDispersions().\n#' \n#' @param cds The CellDataSet to be used for the plot.\n#' @export\nplot_ordering_genes <- function(cds){\n  if(class(cds)[1] != \"CellDataSet\") {\n    stop(\"Error input object is not of type 'CellDataSet'\")\n  }\n  disp_table <- dispersionTable(cds)\n  use_for_ordering <- NA\n  mean_expression <- NA\n  dispersion_empirical <- NA\n  dispersion_fit <- NA\n  gene_id <- NA\n  ordering_genes <- row.names(subset(fData(cds), use_for_ordering == TRUE))\n  \n  g <- qplot(mean_expression, dispersion_empirical, data=disp_table, log=\"xy\", color=I(\"darkgrey\")) + \n    geom_line(aes(y=dispersion_fit), color=\"red\") \n  if (length(ordering_genes) > 0){\n    g <- g + geom_point(aes(mean_expression, dispersion_empirical), \n                        data=subset(disp_table, gene_id %in% ordering_genes), color=\"black\")\n  }\n  g <- g + monocle_theme_opts()\n  g\n}\n\n#' Plots clusters of cells .\n#'\n#' @param cds CellDataSet for the experiment\n#' @param x the column of reducedDimS(cds) to plot on the horizontal axis\n#' @param y the column of reducedDimS(cds) to plot on the vertical axis\n#' @param color_by the cell attribute (e.g. the column of pData(cds)) to map to each cell's color\n#' @param markers a gene name or gene id to use for setting the size of each cell in the plot\n#' @param show_cell_names draw the name of each cell in the plot\n#' @param cell_size The size of the point for each cell\n#' @param cell_name_size the size of cell name labels\n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom reshape2 melt\n#' @importFrom viridis scale_color_viridis\n#' @export\n#' @examples\n#' \\dontrun{\n#' data(HSMM)\n#' plot_cell_clusters(HSMM)\n#' plot_cell_clusters(HSMM, color_by=\"Pseudotime\")\n#' plot_cell_clusters(HSMM, markers=\"MYH3\")\n#' }\nplot_cell_clusters <- function(cds, \n                               x=1, \n                               y=2, \n                               color_by=\"Cluster\", \n                               markers=NULL, \n                               show_cell_names=FALSE, \n                               cell_size=1.5,\n                               cell_name_size=2, \n                               ...){\n  if (is.null(cds@reducedDimA) | length(pData(cds)$Cluster) == 0){\n    stop(\"Error: Clustering is not performed yet. Please call clusterCells() before calling this function.\")\n  }\n\n  gene_short_name <- NULL\n  sample_name <- NULL\n  data_dim_1 <- NULL\n  data_dim_2 <- NULL\n\n  #TODO: need to validate cds as ready for this plot (need mst, pseudotime, etc)\n  lib_info <- pData(cds)\n  \n  tSNE_dim_coords <- reducedDimA(cds)\n  data_df <- data.frame(t(tSNE_dim_coords[c(x,y),]))\n  colnames(data_df) <- c(\"data_dim_1\", \"data_dim_2\")\n  data_df$sample_name <- colnames(cds)\n  data_df <- merge(data_df, lib_info, by.x=\"sample_name\", by.y=\"row.names\")\n  \n  markers_exprs <- NULL\n  if (is.null(markers) == FALSE){\n    markers_fData <- subset(fData(cds), gene_short_name %in% markers)\n    if (nrow(markers_fData) >= 1){\n      markers_exprs <- reshape2::melt(as.matrix(exprs(cds[row.names(markers_fData),])))\n      colnames(markers_exprs)[1:2] <- c('feature_id','cell_id')\n      markers_exprs <- merge(markers_exprs, markers_fData, by.x = \"feature_id\", by.y=\"row.names\")\n      #print (head( markers_exprs[is.na(markers_exprs$gene_short_name) == FALSE,]))\n      markers_exprs$feature_label <- as.character(markers_exprs$gene_short_name)\n      markers_exprs$feature_label[is.na(markers_exprs$feature_label)] <- markers_exprs$Var1\n    }\n  }\n  if (is.null(markers_exprs) == FALSE && nrow(markers_exprs) > 0){\n    data_df <- merge(data_df, markers_exprs, by.x=\"sample_name\", by.y=\"cell_id\")\n\n    g <- ggplot(data=data_df, aes(x=data_dim_1, y=data_dim_2)) + facet_wrap(~feature_label) \n  }else{\n    g <- ggplot(data=data_df, aes(x=data_dim_1, y=data_dim_2)) \n  }\n  \n  # FIXME: setting size here overrides the marker expression funtionality. \n  # Don't do it!\n  if (is.null(markers_exprs) == FALSE && nrow(markers_exprs) > 0){\n    g <- g + geom_point(aes(color=log10(value + 0.1)), size=I(cell_size), na.rm = TRUE) + \n      scale_color_viridis(name = paste0(\"log10(value + 0.1)\"), ...)\n  }else {\n    g <- g + geom_point(aes_string(color = color_by), size=I(cell_size), na.rm = TRUE)\n  }\n  \n  g <- g + \n    #scale_color_brewer(palette=\"Set1\") +\n    monocle_theme_opts() + \n    xlab(paste(\"Component\", x)) + \n    ylab(paste(\"Component\", y)) +\n    theme(legend.position=\"top\", legend.key.height=grid::unit(0.35, \"in\")) +\n    #guides(color = guide_legend(label.position = \"top\")) +\n    theme(legend.key = element_blank()) +\n    theme(panel.background = element_rect(fill='white')) +\n    theme(text = element_text(size = 15))\n  g\n}\n\n#' Plots the decision map of density clusters .\n#'\n#' @param cds CellDataSet for the experiment after running clusterCells_Density_Peak\n#' @param rho_threshold The threshold of local density (rho) used to select the density peaks for plotting \n#' @param delta_threshold The threshold of local distance (delta) used to select the density peaks for plotting \n#' @export\n#' @examples\n#' \\dontrun{\n#' data(HSMM)\n#' plot_rho_delta(HSMM)\n#' }\n\nplot_rho_delta <- function(cds, rho_threshold = NULL, delta_threshold = NULL){\n    if(!is.null(cds@auxClusteringData[[\"tSNE\"]]$densityPeak) \n    & !is.null(pData(cds)$Cluster)\n    & !is.null(pData(cds)$peaks)\n    & !is.null(pData(cds)$halo)\n    & !is.null(pData(cds)$delta)\n    & !is.null(pData(cds)$rho)) {\n    rho <- NULL\n    delta <- NULL\n\n    # df <- data.frame(rho = as.numeric(levels(pData(cds)$rho))[pData(cds)$rho], \n    #   delta = as.numeric(levels(pData(cds)$delta))[pData(cds)$delta])\n    if(!is.null(rho_threshold) & !is.null(delta_threshold)){\n      peaks <- pData(cds)$rho >= rho_threshold & pData(cds)$delta >= delta_threshold\n    }\n    else\n      peaks <- pData(cds)$peaks\n\n    df <- data.frame(rho = pData(cds)$rho, delta = pData(cds)$delta, peaks = peaks)\n\n    g <- qplot(rho, delta, data = df, alpha = I(0.5), color = peaks) +  monocle_theme_opts() + \n      theme(legend.position=\"top\", legend.key.height=grid::unit(0.35, \"in\")) +\n      scale_color_manual(values=c(\"grey\",\"black\")) + \n      theme(legend.key = element_blank()) +\n      theme(panel.background = element_rect(fill='white'))\n  }\n  else {\n    stop('Please run clusterCells_Density_Peak before using this plotting function')\n  }\n  g\n}\n\n#' Plots the percentage of variance explained by the each component based on PCA from the normalized expression\n#' data using the same procedure used in reduceDimension function.\n#'\n#' @param cds CellDataSet for the experiment after running reduceDimension with reduction_method as tSNE \n#' @param max_components Maximum number of components shown in the scree plot (variance explained by each component)\n#' @param norm_method Determines how to transform expression values prior to reducing dimensionality\n#' @param residualModelFormulaStr A model formula specifying the effects to subtract from the data before clustering.\n#' @param pseudo_expr amount to increase expression values before dimensionality reduction\n#' @param return_all A logical argument to determine whether or not the variance of each component is returned\n#' @param use_existing_pc_variance Whether to plot existing results for variance explained by each PC\n#' @param verbose Whether to emit verbose output during dimensionality reduction\n#' @param ... additional arguments to pass to the dimensionality reduction function\n#' @export\n#' @examples\n#' \\dontrun{\n#' data(HSMM)\n#' plot_pc_variance_explained(HSMM)\n#' }\nplot_pc_variance_explained <- function(cds, \n                            max_components=100, \n                            # reduction_method=c(\"DDRTree\", \"ICA\", 'tSNE'),\n                            norm_method = c(\"log\", \"vstExprs\", \"none\"), \n                            residualModelFormulaStr=NULL,\n                            pseudo_expr=NULL, \n                            return_all = F, \n                            use_existing_pc_variance=FALSE,\n                            verbose=FALSE, \n                            ...){\n  set.seed(2016)\n  if(!is.null(cds@auxClusteringData[[\"tSNE\"]]$variance_explained) & use_existing_pc_variance == T){\n    prop_varex <- cds@auxClusteringData[[\"tSNE\"]]$variance_explained\n  }\n  else{\n    FM <- normalize_expr_data(cds, norm_method, pseudo_expr)\n    \n    #FM <- FM[unlist(sparseApply(FM, 1, sd, convert_to_dense=TRUE)) > 0, ]\n    xm <- Matrix::rowMeans(FM)\n    xsd <- sqrt(Matrix::rowMeans((FM - xm)^2))\n    FM <- FM[xsd > 0,]\n    \n    if (is.null(residualModelFormulaStr) == FALSE) {\n      if (verbose) \n        message(\"Removing batch effects\")\n      X.model_mat <- sparse.model.matrix(as.formula(residualModelFormulaStr), \n                                         data = pData(cds), drop.unused.levels = TRUE)\n      \n      fit <- limma::lmFit(FM, X.model_mat, ...)\n      beta <- fit$coefficients[, -1, drop = FALSE]\n      beta[is.na(beta)] <- 0\n      FM <- as.matrix(FM) - beta %*% t(X.model_mat[, -1])\n    }else{\n      X.model_mat <- NULL\n    }\n    \n    if (nrow(FM) == 0) {\n      stop(\"Error: all rows have standard deviation zero\")\n    }\n    \n    # FM <- convert2DRData(cds, norm_method = 'log') \n    # FM <- FM[rowSums(is.na(FM)) == 0, ]\n    irlba_res <- prcomp_irlba(t(FM), n = min(max_components, min(dim(FM)) - 1),\n                              center = TRUE, scale. = TRUE)\n    prop_varex <- irlba_res$sdev^2 / sum(irlba_res$sdev^2)\n    # \n    # cell_means <- Matrix::rowMeans(FM_t)\n    # cell_vars <- Matrix::rowMeans((FM_t - cell_means)^2)\n    # \n    # irlba_res <- irlba(FM,\n    #                    nv= min(max_components, min(dim(FM)) - 1), #avoid calculating components in the tail\n    #                    nu=0,\n    #                    center=cell_means,\n    #                    scale=sqrt(cell_vars),\n    #                    right_only=TRUE)\n    # prop_varex <- irlba_res$d / sum(irlba_res$d)\n    # \n    # # pca_res <- prcomp(t(FM), center = T, scale = T)\n    # # std_dev <- pca_res$sdev \n    # # pr_var <- std_dev^2\n    # prop_varex <- pr_var/sum(pr_var)\n  }\n  \n  p <- qplot(1:length(prop_varex), prop_varex, alpha = I(0.5)) +  monocle_theme_opts() + \n    theme(legend.position=\"top\", legend.key.height=grid::unit(0.35, \"in\")) +\n    theme(panel.background = element_rect(fill='white')) + xlab('components') + \n    ylab('Variance explained \\n by each component')\n  \n  cds@auxClusteringData[[\"tSNE\"]]$variance_explained <- prop_varex # update CDS slot for variance_explained \n\n  if(return_all) {\n    return(list(variance_explained = prop_varex, p = p))\n  }\n  else\n    return(p)  \n}\n\ntraverseTree <- function(g, starting_cell, end_cells){\n  distance <- shortest.paths(g, v=starting_cell, to=end_cells)\n  branchPoints <- which(degree(g) == 3)\n  path <- shortest_paths(g, from = starting_cell, end_cells)\n  \n  return(list(shortest_path = path$vpath, distance = distance, branch_points = intersect(branchPoints, unlist(path$vpath))))\n}\n\n#' Plots the minimum spanning tree on cells.\n#' @description Plots the minimum spanning tree on cells.\n#' @param cds CellDataSet for the experiment\n#' @param x the column of reducedDimS(cds) to plot on the horizontal axis\n#' @param y the column of reducedDimS(cds) to plot on the vertical axis\n#' @param root_states the state used to set as the root of the graph\n#' @param color_by the cell attribute (e.g. the column of pData(cds)) to map to each cell's color\n#' @param show_tree whether to show the links between cells connected in the minimum spanning tree\n#' @param show_backbone whether to show the diameter path of the MST used to order the cells\n#' @param backbone_color the color used to render the backbone.\n#' @param markers a gene name or gene id to use for setting the size of each cell in the plot\n#' @param show_cell_names draw the name of each cell in the plot\n#' @param cell_size The size of the point for each cell\n#' @param cell_link_size The size of the line segments connecting cells (when used with ICA) or the principal graph (when used with DDRTree)\n#' @param cell_name_size the size of cell name labels\n#' @param show_branch_points Whether to show icons for each branch point (only available when reduceDimension was called with DDRTree)\n#' @param ... Additional arguments passed to the scale_color_viridis function\n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom reshape2 melt\n#' @importFrom viridis scale_color_viridis\n#' @export\n#' @examples\n#' \\dontrun{\n#' data(HSMM)\n#' plot_cell_trajectory(HSMM)\n#' plot_cell_trajectory(HSMM, color_by=\"Pseudotime\", show_backbone=FALSE)\n#' plot_cell_trajectory(HSMM, markers=\"MYH3\")\n#' }\nplot_complex_cell_trajectory <- function(cds, \n                                         x=1, \n                                         y=2, \n                                         root_states = NULL,\n                                         color_by=\"State\", \n                                         show_tree=TRUE, \n                                         show_backbone=TRUE, \n                                         backbone_color=\"black\", \n                                         markers=NULL, \n                                         show_cell_names=FALSE, \n                                         cell_size=1.5,\n                                         cell_link_size=0.75,\n                                         cell_name_size=2,\n                                         show_branch_points=TRUE, \n                                         ...){\n  gene_short_name <- NA\n  sample_name <- NA\n  data_dim_1 <- NA\n  data_dim_2 <- NA\n  \n  #TODO: need to validate cds as ready for this plot (need mst, pseudotime, etc)\n  lib_info_with_pseudo <- pData(cds)\n  \n  if (is.null(cds@dim_reduce_type)){\n    stop(\"Error: dimensionality not yet reduced. Please call reduceDimension() before calling this function.\")\n  }\n  \n  if (cds@dim_reduce_type == \"ICA\"){\n    reduced_dim_coords <- reducedDimS(cds)\n  }else if (cds@dim_reduce_type %in% c(\"SimplePPT\", \"DDRTree\", \"SGL-tree\") ){\n    reduced_dim_coords <- reducedDimK(cds)\n    closest_vertex <- cds@auxOrderingData[[\"DDRTree\"]]$pr_graph_cell_proj_closest_vertex\n  }else {\n    stop(\"Error: unrecognized dimensionality reduction method.\")\n  }\n  \n  if (is.null(reduced_dim_coords)){\n    stop(\"You must first call reduceDimension() before using this function\")\n  }\n  \n  dp_mst <- minSpanningTree(cds)\n  \n  \n  if(is.null(root_states)) {\n    if(is.null(lib_info_with_pseudo$Pseudotime)){\n      root_cell <- row.names(lib_info_with_pseudo)[degree(dp_mst) == 1][1]\n    }\n    else\n      root_cell <- row.names(subset(lib_info_with_pseudo, Pseudotime == 0))\n    \n    if(cds@dim_reduce_type != \"ICA\")\n      root_cell <- V(dp_mst)$name[cds@auxOrderingData$DDRTree$pr_graph_cell_proj_closest_vertex[root_cell, ]] \n    \n  }\n  else {\n    candidate_root_cells <- row.names(subset(pData(cds), State %in% root_states))\n    if(cds@dim_reduce_type == \"ICA\") {\n      root_cell <- candidate_root_cells[which(degree(dp_mst, candidate_root_cells) == 1)]\n    } else {\n      Y_candidate_root_cells <- V(dp_mst)$name[cds@auxOrderingData$DDRTree$pr_graph_cell_proj_closest_vertex[candidate_root_cells, ]] \n      root_cell <- Y_candidate_root_cells[which(degree(dp_mst, Y_candidate_root_cells) == 1)]\n    }\n    \n  }\n  \n  # #root_cell <- cds@auxOrderingData[[cds@dim_reduce_type]]$root_cell\n  # root_state <- pData(cds)[root_cell,]$State\n  # #root_state <- V(pr_graph_cell_proj_mst)[root_cell,]$State\n  \n  # pr_graph_root <- subset(pData(cds), State == root_state)\n  \n  # closest_vertex <- cds@auxOrderingData[[\"DDRTree\"]]$pr_graph_cell_proj_closest_vertex\n  # root_cell_point_in_Y <- closest_vertex[row.names(pr_graph_root),]\n  tree_coords <- layout_as_tree(dp_mst, root=root_cell)\n  \n  #ica_space_df <- data.frame(Matrix::t(reduced_dim_coords[c(x,y),]))\n  ica_space_df <- data.frame(tree_coords)\n  row.names(ica_space_df) <- colnames(reduced_dim_coords)\n  colnames(ica_space_df) <- c(\"prin_graph_dim_1\", \"prin_graph_dim_2\")\n  \n  ica_space_df$sample_name <- row.names(ica_space_df)\n  #ica_space_with_state_df <- merge(ica_space_df, lib_info_with_pseudo, by.x=\"sample_name\", by.y=\"row.names\")\n  #print(ica_space_with_state_df)\n  \n  \n  if (is.null(dp_mst)){\n    stop(\"You must first call orderCells() before using this function\")\n  }\n  \n  edge_list <- as.data.frame(get.edgelist(dp_mst))\n  colnames(edge_list) <- c(\"source\", \"target\")\n  \n  edge_df <- merge(ica_space_df, edge_list, by.x=\"sample_name\", by.y=\"source\", all=TRUE)\n  #edge_df <- ica_space_df\n  edge_df <- plyr::rename(edge_df, c(\"prin_graph_dim_1\"=\"source_prin_graph_dim_1\", \"prin_graph_dim_2\"=\"source_prin_graph_dim_2\"))\n  edge_df <- merge(edge_df, ica_space_df[,c(\"sample_name\", \"prin_graph_dim_1\", \"prin_graph_dim_2\")], by.x=\"target\", by.y=\"sample_name\", all=TRUE)\n  edge_df <- plyr::rename(edge_df, c(\"prin_graph_dim_1\"=\"target_prin_graph_dim_1\", \"prin_graph_dim_2\"=\"target_prin_graph_dim_2\"))\n  \n  #S_matrix <- reducedDimS(cds)\n  #data_df <- data.frame(t(S_matrix[c(x,y),]))\n  \n  if(cds@dim_reduce_type == \"ICA\"){\n    S_matrix <- tree_coords[,] #colnames(cds)\n    \n  } else if(cds@dim_reduce_type %in% c(\"DDRTree\", \"SimplePPT\", \"SGL-tree\")){\n    S_matrix <- tree_coords[closest_vertex,]\n    closest_vertex <- cds@auxOrderingData[[\"DDRTree\"]]$pr_graph_cell_proj_closest_vertex\n  }\n  \n  data_df <- data.frame(S_matrix)\n  row.names(data_df) <- colnames(reducedDimS(cds))\n  colnames(data_df) <- c(\"data_dim_1\", \"data_dim_2\")\n  data_df$sample_name <- row.names(data_df)\n  data_df <- merge(data_df, lib_info_with_pseudo, by.x=\"sample_name\", by.y=\"row.names\")\n  \n  markers_exprs <- NULL\n  if (is.null(markers) == FALSE){\n    markers_fData <- subset(fData(cds), gene_short_name %in% markers)\n    if (nrow(markers_fData) >= 1){\n      markers_exprs <- reshape2::melt(as.matrix(exprs(cds[row.names(markers_fData),])))\n      colnames(markers_exprs)[1:2] <- c('feature_id','cell_id')\n      markers_exprs <- merge(markers_exprs, markers_fData, by.x = \"feature_id\", by.y=\"row.names\")\n      #print (head( markers_exprs[is.na(markers_exprs$gene_short_name) == FALSE,]))\n      markers_exprs$feature_label <- as.character(markers_exprs$gene_short_name)\n      markers_exprs$feature_label[is.na(markers_exprs$feature_label)] <- markers_exprs$Var1\n    }\n  }\n  if (is.null(markers_exprs) == FALSE && nrow(markers_exprs) > 0){\n    data_df <- merge(data_df, markers_exprs, by.x=\"sample_name\", by.y=\"cell_id\")\n    #print (head(edge_df))\n    g <- ggplot(data=data_df, aes(x=data_dim_1, y=data_dim_2, I(cell_size))) + facet_wrap(~feature_label)\n  }else{\n    g <- ggplot(data=data_df, aes(x=data_dim_1, y=data_dim_2)) \n  }\n  if (show_tree){\n    g <- g + geom_segment(aes_string(x=\"source_prin_graph_dim_1\", y=\"source_prin_graph_dim_2\", xend=\"target_prin_graph_dim_1\", yend=\"target_prin_graph_dim_2\"), size=cell_link_size, linetype=\"solid\", na.rm=TRUE, data=edge_df)\n  }\n  \n  # FIXME: setting size here overrides the marker expression funtionality. \n  # Don't do it!\n  if (is.null(markers_exprs) == FALSE && nrow(markers_exprs) > 0){\n    if(class(data_df[, color_by]) == 'numeric') {\n      g <- g + geom_jitter(aes_string(color = paste0(\"log10(\", color_by, \" + 0.1)\")), size=I(cell_size), na.rm = TRUE, height=5) + \n                             scale_color_viridis(name = paste0(\"log10(\", color_by, \")\"), ...)\n    } else {\n      g <- g + geom_jitter(aes_string(color = color_by), size=I(cell_size), na.rm = TRUE, height=5) \n    }\n  }else {\n    if(class(data_df[, color_by]) == 'numeric') {\n      g <- g + geom_jitter(aes_string(color = paste0(\"log10(\", color_by, \" + 0.1)\")), size=I(cell_size), na.rm = TRUE, height=5) + \n        scale_color_viridis(name = paste0(\"log10(\", color_by, \" + 0.1)\"), ...)\n    } else {\n      g <- g + geom_jitter(aes_string(color = color_by), size=I(cell_size), na.rm = TRUE, height=5)\n    }\n  }\n\n  if (show_branch_points && cds@dim_reduce_type == 'DDRTree'){\n    mst_branch_nodes <- cds@auxOrderingData[[cds@dim_reduce_type]]$branch_points\n    branch_point_df <- subset(edge_df, sample_name %in% mst_branch_nodes)[,c(\"sample_name\", \"source_prin_graph_dim_1\", \"source_prin_graph_dim_2\")]\n    branch_point_df$branch_point_idx <- match(branch_point_df$sample_name, mst_branch_nodes)\n    branch_point_df <- branch_point_df[!duplicated(branch_point_df$branch_point_idx), ]\n    \n    g <- g + geom_point(aes_string(x=\"source_prin_graph_dim_1\", y=\"source_prin_graph_dim_2\"), \n                        size=2 * cell_size, na.rm=TRUE, data=branch_point_df) +\n      geom_text(aes_string(x=\"source_prin_graph_dim_1\", y=\"source_prin_graph_dim_2\", label=\"branch_point_idx\"), \n                size=1.5 * cell_size, color=\"white\", na.rm=TRUE, data=branch_point_df)\n  }\n  if (show_cell_names){\n    g <- g +geom_text(aes(label=sample_name), size=cell_name_size)\n  }\n  g <- g + \n    #scale_color_brewer(palette=\"Set1\") +\n    theme(strip.background = element_rect(colour = 'white', fill = 'white')) +\n    theme(panel.border = element_blank()) +\n    # theme(axis.line.x = element_line(size=0.25, color=\"black\")) +\n    # theme(axis.line.y = element_line(size=0.25, color=\"black\")) +\n    theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) +\n    theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) + \n    theme(panel.background = element_rect(fill='white')) +\n    theme(legend.key=element_blank()) + \n    xlab('') + \n    ylab('') +\n    theme(legend.position=\"top\", legend.key.height=grid::unit(0.35, \"in\")) +\n    #guides(color = guide_legend(label.position = \"top\")) +\n    theme(legend.key = element_blank()) +\n    theme(panel.background = element_rect(fill='white')) + \n    theme(line = element_blank(), \n          axis.text.x = element_blank(),\n          axis.text.y = element_blank(),\n          axis.ticks = element_blank()) \n  g\n}\n\n# Modified function: Plot heatmap of 3 branches with the same coloring. Each CDS subset has to have the same set of genes.\n#'  Create a heatmap to demonstrate the bifurcation of gene expression along multiple branches\n#'\n#' @param cds CellDataSet for the experiment (normally only the branching genes detected with BEAM)\n#' @param branches The terminal branches (states) on the developmental tree you want to investigate.\n#' @param branches_name Name (for example, cell type) of branches you believe the cells on the branches are associated with. \n#' @param cluster_rows Whether to cluster the rows of the heatmap.\n#' @param hclust_method The method used by pheatmap to perform hirearchical clustering of the rows. \n#' @param num_clusters Number of clusters for the heatmap of branch genes\n#' @param hmcols The color scheme for drawing the heatmap.\n#' @param add_annotation_row Additional annotations to show for each row in the heatmap. Must be a dataframe with one row for each row in the fData table of cds_subset, with matching IDs.\n#' @param add_annotation_col Additional annotations to show for each column in the heatmap. Must be a dataframe with one row for each cell in the pData table of cds_subset, with matching IDs.\n#' @param show_rownames Whether to show the names for each row in the table.\n#' @param use_gene_short_name Whether to use the short names for each row. If FALSE, uses row IDs from the fData table.\n#' @param norm_method Determines how to transform expression values prior to rendering\n#' @param scale_max The maximum value (in standard deviations) to show in the heatmap. Values larger than this are set to the max.\n#' @param scale_min The minimum value (in standard deviations) to show in the heatmap. Values smaller than this are set to the min.\n#' @param trend_formula A formula string specifying the model used in fitting the spline curve for each gene/feature.\n#' @param return_heatmap Whether to return the pheatmap object to the user. \n#' @param cores Number of cores to use when smoothing the expression curves shown in the heatmap.\n#' @return A list of heatmap_matrix (expression matrix for the branch committment), ph (pheatmap heatmap object),\n#' annotation_row (annotation data.frame for the row), annotation_col (annotation data.frame for the column). \n#' @import pheatmap\n#' @export\n#'\nplot_multiple_branches_heatmap <- function(cds, \n                                           branches, \n                                           branches_name = NULL, \n                                           cluster_rows = TRUE,\n                                           hclust_method = \"ward.D2\", \n                                           num_clusters = 6,\n                                           \n                                           hmcols = NULL, \n                                           \n                                           add_annotation_row = NULL,\n                                           add_annotation_col = NULL,\n                                           show_rownames = FALSE, \n                                           use_gene_short_name = TRUE,\n                                           \n                                           norm_method = c(\"vstExprs\", \"log\"), \n                                           scale_max=3, \n                                           scale_min=-3, \n                                           \n                                           trend_formula = '~sm.ns(Pseudotime, df=3)',\n                                           \n                                           return_heatmap=FALSE,\n                                           cores=1){\n  pseudocount <- 1\n  if(!(all(branches %in% pData(cds)$State)) & length(branches) == 1){\n    stop('This function only allows to make multiple branch plots where branches is included in the pData')\n  }\n  \n  branch_label <- branches\n  if(!is.null(branches_name)){\n    if(length(branches) != length(branches_name)){\n      stop('branches_name should have the same length as branches')\n    }\n    branch_label <- branches_name\n  }\n  \n  #test whether or not the states passed to branches are true branches (not truncks) or there are terminal cells \n  g <- cds@minSpanningTree\n  m <- NULL\n  # branche_cell_num <- c()\n  for(branch_in in branches) {\n    branches_cells <- row.names(subset(pData(cds), State == branch_in))\n    root_state <- subset(pData(cds), Pseudotime == 0)[, 'State']\n    root_state_cells <- row.names(subset(pData(cds), State == root_state))\n    \n    if(cds@dim_reduce_type != 'ICA') {\n      root_state_cells <- unique(paste('Y_', cds@auxOrderingData$DDRTree$pr_graph_cell_proj_closest_vertex[root_state_cells, ], sep = ''))\n      branches_cells <- unique(paste('Y_', cds@auxOrderingData$DDRTree$pr_graph_cell_proj_closest_vertex[branches_cells, ], sep = ''))\n    }\n    root_cell <- root_state_cells[which(degree(g, v = root_state_cells) == 1)]\n    tip_cell <- branches_cells[which(degree(g, v = branches_cells) == 1)]\n    \n    traverse_res <- traverseTree(g, root_cell, tip_cell)\n    path_cells <- names(traverse_res$shortest_path[[1]])\n    \n    if(cds@dim_reduce_type != 'ICA') {\n      pc_ind <- cds@auxOrderingData$DDRTree$pr_graph_cell_proj_closest_vertex \n      path_cells <- row.names(pc_ind)[paste('Y_', pc_ind[, 1], sep = '') %in% path_cells]\n    }\n    \n    cds_subset <- cds[, path_cells]\n    \n    newdata <- data.frame(Pseudotime = seq(0, max(pData(cds_subset)$Pseudotime),length.out = 100)) \n    \n    tmp <- genSmoothCurves(cds_subset, cores=cores, trend_formula = trend_formula,  \n                           relative_expr = T, new_data = newdata)\n    if(is.null(m))\n      m <- tmp\n    else\n      m <- cbind(m, tmp)\n  }\n  \n  #remove genes with no expression in any condition\n  m=m[!apply(m,1,sum)==0,]\n  \n  norm_method <- match.arg(norm_method)\n  \n  # FIXME: this needs to check that vst values can even be computed. (They can only be if we're using NB as the expressionFamily)\n  if(norm_method == 'vstExprs' && is.null(cds@dispFitInfo[[\"blind\"]]$disp_func) == FALSE) {\n    m = vstExprs(cds, expr_matrix=m)\n  }     \n  else if(norm_method == 'log') {\n    m = log10(m+pseudocount)\n  }\n  \n  # Row-center the data.\n  m=m[!apply(m,1,sd)==0,]\n  m=Matrix::t(scale(Matrix::t(m),center=TRUE))\n  m=m[is.na(row.names(m)) == FALSE,]\n  m[is.nan(m)] = 0\n  m[m>scale_max] = scale_max\n  m[m<scale_min] = scale_min\n  \n  heatmap_matrix <- m\n  \n  row_dist <- as.dist((1 - cor(Matrix::t(heatmap_matrix)))/2)\n  row_dist[is.na(row_dist)] <- 1\n  \n  if(is.null(hmcols)) {\n    bks <- seq(-3.1,3.1, by = 0.1)\n    hmcols <- blue2green2red(length(bks) - 1)\n  }\n  else {\n    bks <- seq(-3.1,3.1, length.out = length(hmcols))\n  } \n  \n  ph <- pheatmap(heatmap_matrix, \n                 useRaster = T,\n                 cluster_cols=FALSE, \n                 cluster_rows=T, \n                 show_rownames=F, \n                 show_colnames=F, \n                 clustering_distance_rows=row_dist,\n                 clustering_method = hclust_method,\n                 cutree_rows=num_clusters,\n                 silent=TRUE,\n                 filename=NA,\n                 breaks=bks,\n                 color=hmcols)\n  \n  annotation_col <- data.frame(Branch=factor(rep(rep(branch_label, each = 100))))\n  annotation_row <- data.frame(Cluster=factor(cutree(ph$tree_row, num_clusters)))\n  col_gaps_ind <- c(1:(length(branches) - 1)) * 100\n  \n  if(!is.null(add_annotation_row)) {\n    old_colnames_length <- ncol(annotation_row)\n    annotation_row <- cbind(annotation_row, add_annotation_row[row.names(annotation_row), ])  \n    colnames(annotation_row)[(old_colnames_length+1):ncol(annotation_row)] <- colnames(add_annotation_row)\n    # annotation_row$bif_time <- add_annotation_row[as.character(fData(absolute_cds[row.names(annotation_row), ])$gene_short_name), 1]\n  }\n  \n  \n  if (use_gene_short_name == TRUE) {\n    if (is.null(fData(cds)$gene_short_name) == FALSE) {\n      feature_label <- as.character(fData(cds)[row.names(heatmap_matrix), 'gene_short_name'])\n      feature_label[is.na(feature_label)] <- row.names(heatmap_matrix)\n      \n      row_ann_labels <- as.character(fData(cds)[row.names(annotation_row), 'gene_short_name'])\n      row_ann_labels[is.na(row_ann_labels)] <- row.names(annotation_row)\n    }\n    else {\n      feature_label <- row.names(heatmap_matrix)\n      row_ann_labels <- row.names(annotation_row)\n    }\n  }\n  else {\n    feature_label <- row.names(heatmap_matrix)\n    row_ann_labels <- row.names(annotation_row)\n  }\n  \n  row.names(heatmap_matrix) <- feature_label\n  row.names(annotation_row) <- row_ann_labels\n  \n  \n  colnames(heatmap_matrix) <- c(1:ncol(heatmap_matrix))\n  \n  if(!(cluster_rows)) {\n    annotation_row <- NA\n  }\n  \n  ph_res <- pheatmap(heatmap_matrix[, ], #ph$tree_row$order\n                     useRaster = T,\n                     cluster_cols = FALSE, \n                     cluster_rows = cluster_rows, \n                     show_rownames=show_rownames, \n                     show_colnames=F, \n                     #scale=\"row\",\n                     clustering_distance_rows=row_dist, #row_dist\n                     clustering_method = hclust_method, #ward.D2\n                     cutree_rows=num_clusters,\n                     # cutree_cols = 2,\n                     annotation_row=annotation_row,\n                     annotation_col=annotation_col,\n                     gaps_col = col_gaps_ind,\n                     treeheight_row = 20, \n                     breaks=bks,\n                     fontsize = 12,\n                     color=hmcols, \n                     silent=TRUE,\n                     filename=NA\n  )\n  \n  grid::grid.rect(gp=grid::gpar(\"fill\", col=NA))\n  grid::grid.draw(ph_res$gtable)\n  if (return_heatmap){\n    return(ph_res)\n  }\n}\n\n#'  Create a kinetic curves to demonstrate the bifurcation of gene expression along multiple branches\n#'\n#' @param cds CellDataSet for the experiment (normally only the branching genes detected with BEAM)\n#' @param branches The terminal branches (states) on the developmental tree you want to investigate. \n#' @param branches_name Name (for example, cell type) of branches you believe the cells on the branches are associated with. \n#' @param min_expr The minimum level of expression to show in the plot\n#' @param cell_size A number how large the cells should be in the plot \n#' @param norm_method Determines how to transform expression values prior to rendering\n#' @param nrow the number of rows used when laying out the panels for each gene's expression\n#' @param ncol the number of columns used when laying out the panels for each gene's expression\n#' @param panel_order the order in which genes should be layed out (left-to-right, top-to-bottom)\n#' @param color_by the cell attribute (e.g. the column of pData(cds)) to be used to color each cell  \n#' @param trend_formula the model formula to be used for fitting the expression trend over pseudotime \n#' @param label_by_short_name label figure panels by gene_short_name (TRUE) or feature id (FALSE)\n#' @param TPM Whether to convert the expression value into TPM values. \n#' @param cores Number of cores to use when smoothing the expression curves shown in the heatmap.\n#' @return a ggplot2 plot object\n#' @export\n#'\nplot_multiple_branches_pseudotime <- function(cds, \n                                              branches, \n                                              branches_name = NULL, \n                                              \n                                              min_expr = NULL,                                     \n                                              cell_size = 0.75,                                           \n                                              norm_method = c(\"vstExprs\", \"log\"), \n                                              nrow = NULL, \n                                              ncol = 1, \n                                              panel_order = NULL, \n                                              color_by = \"Branch\",\n                                              \n                                              trend_formula = '~sm.ns(Pseudotime, df=3)',\n                                              label_by_short_name = TRUE,\n                                              TPM = FALSE, \n                                              cores=1){\n    \n    \n    if(TPM) {\n        exprs(cds) <- esApply(cds, 2, function(x) x / sum(x) * 1e6)\n    }\n    \n    if(!(all(branches %in% pData(cds)$State)) & length(branches) == 1){\n        stop('This function only allows to make multiple branch plots where branches is included in the pData')\n    }\n    \n    branch_label <- branches\n    if(!is.null(branches_name)){\n        if(length(branches) != length(branches_name)){\n            stop('branches_name should have the same length as branches')\n        }\n        branch_label <- branches_name\n    }\n    \n    #test whether or not the states passed to branches are true branches (not truncks) or there are terminal cells \n    g <- cds@minSpanningTree\n    m <- NULL\n    cds_exprs <- NULL \n    # branche_cell_num <- c()\n    for(branch_in in branches) {\n        branches_cells <- row.names(subset(pData(cds), State == branch_in))\n        root_state <- subset(pData(cds), Pseudotime == 0)[, 'State']\n        root_state_cells <- row.names(subset(pData(cds), State == root_state))\n        \n        if(cds@dim_reduce_type != 'ICA') {\n            root_state_cells <- unique(paste('Y_', cds@auxOrderingData$DDRTree$pr_graph_cell_proj_closest_vertex[root_state_cells, ], sep = ''))\n            branches_cells <- unique(paste('Y_', cds@auxOrderingData$DDRTree$pr_graph_cell_proj_closest_vertex[branches_cells, ], sep = ''))\n        }\n        root_cell <- root_state_cells[which(degree(g, v = root_state_cells) == 1)]\n        tip_cell <- branches_cells[which(degree(g, v = branches_cells) == 1)]\n        \n        traverse_res <- traverseTree(g, root_cell, tip_cell)\n        path_cells <- names(traverse_res$shortest_path[[1]])\n        \n        if(cds@dim_reduce_type != 'ICA') {\n            pc_ind <- cds@auxOrderingData$DDRTree$pr_graph_cell_proj_closest_vertex \n            path_cells <- row.names(pc_ind)[paste('Y_', pc_ind[, 1], sep = '') %in% path_cells]\n        }\n        \n        #if(is.null(pData(cds)$no_expression)) {\n        cds_subset <- cds[, path_cells]      \n        # } else {\n        #     cds_subset <- cds[, path_cells %in% colnames(cds)[!pData(cds)$no_expression]]      \n        # }\n        \n        newdata <- data.frame(Pseudotime = pData(cds_subset)$Pseudotime, row.names = colnames(cds_subset))\n        \n        tmp <- t(esApply(cds_subset, 1, function(x) lowess(x[order(pData(cds_subset)$Pseudotime)])$y))\n        # tmp <- t(esApply(cds_subset, 1, function(x) {\n        #   x <- x[order(pData(cds_subset)$Pseudotime)]\n        #   c(smooth::sma(x, order = 100, h = 1, silent=\"all\")$fitted)}) #, x[length(x)]\n        # )\n        \n        \n        colnames(tmp) <- colnames(cds_subset)[order(pData(cds_subset)$Pseudotime)]\n        # tmp <- genSmoothCurves(cds_subset, cores=cores, trend_formula = trend_formula,  \n        #                        relative_expr = T, new_data = newdata)\n        \n        cds_exprs_tmp <- reshape2::melt(log2(tmp + 1))\n        cds_exprs_tmp <- reshape2::melt(tmp)\n        colnames(cds_exprs_tmp) <- c(\"f_id\", \"Cell\", \"expression\")\n        cds_exprs_tmp$Branch <- branch_label[which(branches == branch_in)]\n        \n        if(is.null(cds_exprs))\n            cds_exprs <- cds_exprs_tmp\n        else\n            cds_exprs <- rbind(cds_exprs, cds_exprs_tmp)\n        \n        if(is.null(m))\n            m <- tmp\n        else\n            m <- cbind(m, tmp)\n    }\n    \n    #remove genes with no expression in any condition\n    m=m[!apply(m,1,sum)==0,]\n    \n    norm_method <- match.arg(norm_method)\n    \n    # FIXME: this needs to check that vst values can even be computed. (They can only be if we're using NB as the expressionFamily)\n    if(norm_method == 'vstExprs' && is.null(cds@dispFitInfo[[\"blind\"]]$disp_func) == FALSE) {\n        m = vstExprs(cds, expr_matrix=m)\n    }     \n    else if(norm_method == 'log') {\n        m = log10(m+pseudocount)\n    }\n    \n    if (is.null(min_expr)) {\n        min_expr <- cds@lowerDetectionLimit\n    }\n    \n    cds_pData <- pData(cds)\n    \n    cds_fData <- fData(cds)\n    cds_exprs <- merge(cds_exprs, cds_fData, by.x = \"f_id\", by.y = \"row.names\")\n    cds_exprs <- merge(cds_exprs, cds_pData, by.x = \"Cell\", by.y = \"row.names\")\n    \n    cds_exprs <- plyr::ddply(cds_exprs, .(Branch), mutate, Pseudotime = (Pseudotime - min(Pseudotime)) * 100 / (max(Pseudotime) - min(Pseudotime)) )\n    \n    # if (integer_expression) {\n    #   cds_exprs$adjusted_expression <- round(cds_exprs$expression)\n    # }\n    # else {\n    #   cds_exprs$adjusted_expression <- log10(cds_exprs$expression)\n    # }\n    if (label_by_short_name == TRUE) {\n        if (is.null(cds_exprs$gene_short_name) == FALSE) {\n            cds_exprs$feature_label <- as.character(cds_exprs$gene_short_name)\n            cds_exprs$feature_label[is.na(cds_exprs$feature_label)] <- cds_exprs$f_id\n        }\n        else {\n            cds_exprs$feature_label <- cds_exprs$f_id\n        }\n    }\n    else {\n        cds_exprs$feature_label <- cds_exprs$f_id\n    }\n    cds_exprs$feature_label <- as.factor(cds_exprs$feature_label)\n    # trend_formula <- paste(\"adjusted_expression\", trend_formula,\n    #     sep = \"\")\n    cds_exprs$Branch <- as.factor(cds_exprs$Branch) \n    \n    # new_data <- data.frame(Pseudotime = pData(cds_subset)$Pseudotime, Branch = pData(cds_subset)$Branch)\n    \n    # full_model_expectation <- genSmoothCurves(cds_subset, cores=1, trend_formula = trend_formula, \n    #                                           relative_expr = T, new_data = new_data)\n    # colnames(full_model_expectation) <- colnames(cds_subset)\n    \n    # cds_exprs$full_model_expectation <- apply(cds_exprs,1, function(x) full_model_expectation[x[2], x[1]])\n    # if(!is.null(reducedModelFormulaStr)){\n    #   reduced_model_expectation <- genSmoothCurves(cds_subset, cores=1, trend_formula = reducedModelFormulaStr,\n    #                                                relative_expr = T, new_data = new_data)\n    #   colnames(reduced_model_expectation) <- colnames(cds_subset)\n    #   cds_exprs$reduced_model_expectation <- apply(cds_exprs,1, function(x) reduced_model_expectation[x[2], x[1]])\n    # }\n    \n    # # FIXME: If you want to show the bifurcation time for each gene, this function\n    # # should just compute it. Passing it in as a dataframe is just too complicated\n    # # and will be hard on the user. \n    # # if(!is.null(bifurcation_time)){\n    # #     cds_exprs$bifurcation_time <- bifurcation_time[as.vector(cds_exprs$gene_short_name)]\n    # # }\n    # if (method == \"loess\")\n    #   cds_exprs$expression <- cds_exprs$expression + cds@lowerDetectionLimit\n    # if (label_by_short_name == TRUE) {\n    #   if (is.null(cds_exprs$gene_short_name) == FALSE) {\n    #     cds_exprs$feature_label <- as.character(cds_exprs$gene_short_name)\n    #     cds_exprs$feature_label[is.na(cds_exprs$feature_label)] <- cds_exprs$f_id\n    #   }\n    #   else {\n    #     cds_exprs$feature_label <- cds_exprs$f_id\n    #   }\n    # }\n    # else {\n    #   cds_exprs$feature_label <- cds_exprs$f_id\n    # }\n    # cds_exprs$feature_label <- factor(cds_exprs$feature_label)\n    # if (is.null(panel_order) == FALSE) {\n    #   cds_exprs$feature_label <- factor(cds_exprs$feature_label,\n    #                                     levels = panel_order)\n    # }\n    # cds_exprs$expression[is.na(cds_exprs$expression)] <- min_expr\n    # cds_exprs$expression[cds_exprs$expression < min_expr] <- min_expr\n    # cds_exprs$full_model_expectation[is.na(cds_exprs$full_model_expectation)] <- min_expr\n    # cds_exprs$full_model_expectation[cds_exprs$full_model_expectation < min_expr] <- min_expr\n    \n    # if(!is.null(reducedModelFormulaStr)){\n    #   cds_exprs$reduced_model_expectation[is.na(cds_exprs$reduced_model_expectation)] <- min_expr\n    #   cds_exprs$reduced_model_expectation[cds_exprs$reduced_model_expectation < min_expr] <- min_expr\n    # }\n    \n    cds_exprs$State <- as.factor(cds_exprs$State)\n    cds_exprs$Branch <- as.factor(cds_exprs$Branch)\n    \n    q <- ggplot(aes(Pseudotime, expression), data = cds_exprs)\n    # if (!is.null(bifurcation_time)) {\n    #   q <- q + geom_vline(aes(xintercept = bifurcation_time),\n    #                       color = \"black\", linetype = \"longdash\")\n    # }\n    if (is.null(color_by) == FALSE) {\n        q <- q + geom_line(aes_string(color = color_by), size = I(cell_size))\n    }\n    #if (is.null(reducedModelFormulaStr) == FALSE)\n    q <- q + facet_wrap(~feature_label, nrow = nrow, ncol = ncol, scales = \"free_y\") #+ scale_y_log10() \n    #else q <- q + scale_y_log10() + facet_wrap(~feature_label,\n    #                                           nrow = nrow, ncol = ncol, scales = \"free_y\")\n    #if (method == \"loess\")\n    #  q <- q + stat_smooth(aes(fill = Branch, color = Branch),\n    #                       method = \"loess\")\n    #else if (method == \"fitting\") {\n    #  q <- q + geom_line(aes_string(x = \"Pseudotime\", y = \"full_model_expectation\",\n    #                                linetype = \"Branch\"), data = cds_exprs) #+ scale_color_manual(name = \"Type\", values = c(colour_cell, colour), labels = c(\"Pre-branch\", \"AT1\", \"AT2\", \"AT1\", \"AT2\")\n    #}\n    \n    #if(!is.null(reducedModelFormulaStr)) {\n    #  q <- q + geom_line(aes_string(x = \"Pseudotime\", y = \"reduced_model_expectation\"),\n    #                     color = 'black', linetype = 2, data =  cds_exprs)   \n    #}\n    \n    q <- q + ylab(\"Expression\") + xlab(\"Pseudotime (stretched)\")\n    \n    q <- q + monocle_theme_opts()\n    q + expand_limits(y = min_expr)\n}\n",
    "created" : 1508265681540.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2676575500",
    "id" : "99ADC32",
    "lastKnownWriteTime" : 1508265767,
    "last_content_update" : 1508265767633,
    "path" : "~/Dropbox (Personal)/Projects/monocle-dev/R/plotting.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 17,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}