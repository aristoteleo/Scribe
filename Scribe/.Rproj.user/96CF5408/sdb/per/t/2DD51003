{
    "collab_server" : "",
    "contents" : "# ver 0.1; code review and documentation at Oct 2, 2017\n\n# library(RColorBrewer)\n#' \n#' Plot the scatterplot for gene pairs across different cells. \n#' \n#' This plot function is the commomly used approach to visualize the relationship between gene pairs.\n#' Please check other plots, including plot_gene_pairs_in_pseudotime, plot_gene_pairs_branched_pseudotime, plot_lagged_drevi, plot_cross_map, plot_gene_pairs_causality, plot_comb_logic,  \n#' This function accepts a matrix where each row is the gene pair and the first column is the hypothetical source \n#' or regulator while the second column represents the hypothetical target. The name in this matrix should match \n#' the name in the gene_short_name column of the cds_subset object.\n#' \n#' @param cds_subset CellDataSet for the experiment\n#' @param gene_pairs_mat A matrix where each row is the gene pair and the first column is the hypothetical source or regulator while the second column represents the hypothetical target. The name in this matrix should match the name in the gene_short_name column of the cds_subset object. \n#' @param n_row number of columns used to layout the faceted cluster panels\n#' @param n_col number of columns used to layout the faceted cluster panels\n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @export\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' gene_pairs_mat <- matrix(c('H19', 'Ccnd2', 'Ccnd2', 'Scnn1g'), ncol = 2)\n#' plot_gene_pairs_scatter(lung, gene_pairs_mat)\n#' }\n#' @export\n#' \nplot_gene_pairs_scatter <- function(cds_subset,\n                            gene_pairs_mat,\n                            n_row = NULL,\n                            n_col = 1) { #, h = 1\n  \n  gene_id <- row.names(subset(fData(cds_subset), gene_short_name %in% gene_pairs_mat[i, ]))\n\n  buylrd = c(\"#313695\", \"#4575B4\", \"#74ADD1\", \"#ABD9E9\", \"#E0F3F8\", \"#FFFFBF\",\n             \"#FEE090\", \"#FDAE61\", \"#F46D43\", \"#D73027\", \"#A50026\")\n  \n  if(ncol(gene_pairs_mat) != 2) {\n    stop('Please provide a matrix for pairs of genes you want to infer causality.')\n  }\n  if(length(gene_id) == 0) {\n    stop('Please make sure all genes you provided in gene_pairs_mat exist in your data.')\n  }\n\n  if(nrow(gene_pairs_mat) == 1) {\n    exprs_res <- t(exprs(cds_subset)[gene_id, ])\n  }\n  else {\n    exprs_res <- NULL\n    for(i in 1:nrow(gene_pairs_mat)) {\n      exprs_res <- cbind(exprs_res, exprs(cds_subset)[gene_id, ])\n    }\n  }\n  exprs_res_df <- as.data.frame(t(exprs_res))\n  colnames(exprs_res_df) <- c('V1', 'V2')\n  exprs_res_df$pair <- rep(apply(gene_pairs_mat, 1, function(x) paste(x[1], x[2], sep = \"_\")), each = ncol(cds_subset))\n\n  p <- qplot(V1, V2, data = exprs_res_df, geom = 'point', log = 'xy', size = I(1), size = 2) +\n    stat_density2d(geom = \"tile\", aes(fill = ..density..), contour = FALSE) + xlab('') + ylab('') +\n    geom_point(color = I(\"darkgray\"), size = I(0.85)) + scale_fill_gradientn(colours = buylrd) +\n    monocle:::monocle_theme_opts() + facet_wrap(~pair, nrow = n_row, ncol = n_col)\n\n  return(p)\n}\n\n# plot_gene_pairs(lung, gene_pairs_mat = t(matrix(row.names(lung)[2:3])))\n#\n# mi(exprs(lung)[2, ], exprs(lung)[3, ], k = 5)\n# test <- rbind(t(matrix(row.names(lung)[2:3])), t(matrix(row.names(lung)[3:4])))\n# plot_gene_pairs(lung, gene_pairs_mat = test)\n# mi(exprs(lung)[2, ], exprs(lung)[3, ], k = 5)\n\n# #add the principial curves:\n# # ini_path <- exprs_data[sort(pData(data)$Pseudotime, index.return = T)$ix, ] #from the MST/pc tree\n# # ini_path <- loess(exprs_data[, 1] ~ exprs_data[, 2])#from the lowess curve\n# ini_path <- lowess(exprs_data[, 1], exprs_data[, 2]); ini_path <- as.matrix(data.frame(x = ini_path$x, y = ini_path$y))\n#\n# gene_pair_pc <- principal.curve(as.matrix(exprs_data), start = ini_path)\n\n# geom_path(aes(gene_pair_pc$s[gene_pair_pc$tag, 1], gene_pair_pc$s[gene_pair_pc$tag, 2]), color = 'black') +\n# theme(strip.background = element_rect(colour = \"white\",\n#                                       fill = \"white\")) + theme(panel.border = element_blank(),\n#                                                                axis.line = element_line()) + theme(legend.position = \"none\") +\n#   theme(axis.title.y = element_text(size = 10)) + theme(axis.title.x = element_text(size = 10)) +\n#   theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) +\n#   theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank())\n# \n# # make MI, CMI plot: (use the shiny app?)\n# \n\n# use loess to make the plot \n\n#' Plot the expression dynamics for gene pairs in pseduotime with one separate kinetic curve for each gene.\n#'\n#' This plotting function is used to make kinetic plots for gene pairs along the pseudotime. It accepts a matrix where each \n#' row is the gene pair and the first column is the hypothetical source or regulator while the second column represents the hypothetical \n#' target. The name in this matrix should match the name in the gene_short_name column of the cds_subset object. Two vertical lines will \n#' be added which indicate the estimated inflection points of the two kinetic curves. The distance between the two curves implies \n#' the potential time delay betweeen two genes. Since Scribe doesn't consider the continous value of the pseudotime but merely the \n#' ordering of the cells along the pseudotime, the x-axis of this plot also only includes the ordering information. Also note that \n#' this function allow you to pass a matrix where genes are used across different rows. \n#'\n#' @param cds_subset CellDataSet for the experiment\n#' @param gene_pairs_mat A matrix where each row is the gene pair and the first column is the hypothetical source or regulator while the second column represents the hypothetical target. The name in this matrix should match the name in the gene_short_name column of the cds_subset object. \n#' @param min_expr the minimum (untransformed) expression level to use in plotted the genes.\n#' @param cell_size the size (in points) of each cell used in the plot\n#' @param n_row number of columns used to layout the faceted cluster panels\n#' @param n_col number of columns used to layout the faceted cluster panels\n#' @param color_by the cell attribute (e.g. the column of pData(cds_subset)) to be used to color each cell\n#' @param trend_formula the model formula to be used for fitting the expression trend over pseudotime\n#' @param label_by_short_name label figure panels by gene_short_name (TRUE) or feature id (FALSE)\n#' @param relative_expr A logic flag to determine whether or not we should use the relative expression values\n#' @param fitting_type The type of fitting procedure used to plot the gene expression dynamics curve, either loess (default) or spline curves.  \n#' @param log A logic flag to determine whether or not you want to log your data (or y-axis is in log scale)  \n#' @param turning_point A logic flag to determine whether or not you want to add two lines indicating the turning point for each gene. \n#' @param data_points A logic flag to determine whether or not you want to plot the raw data points\n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom plyr ddply\n#' @importFrom reshape2 melt\n#' @export\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' gene_pairs_mat <- matrix(c('H19', 'Ccnd2', 'Ccnd2', 'Scnn1g'), ncol = 2)\n#' plot_gene_pairs_in_pseudotime(lung, gene_pairs_mat)\n#' }\nplot_gene_pairs_in_pseudotime <- function(cds_subset, \n                              gene_pairs_mat, \n                              min_expr=NULL, \n                              cell_size=1.5, \n                              n_row=NULL, \n                              n_col=1, \n                              # panel_order=NULL, \n                              color_by=\"State\",\n                              trend_formula=\"~ sm.ns(Pseudotime, df=3)\",\n                              label_by_short_name=TRUE,\n                              relative_expr=TRUE,\n                              vertical_jitter=NULL,\n                              horizontal_jitter=NULL,\n                              fitting_type = c('loess', 'spline'), \n                              log = TRUE,\n                              turning_point = FALSE,\n                              data_points = FALSE) {\n\n  all_genes_in_pair <- as.vector(gene_pairs_mat)\n  if(! all(all_genes_in_pair %in% fData(cds_subset)$gene_short_name)) {\n    stop(\"cds_subset doesn't include all genes in gene_pairs_mat Make sure all genes are included in gene_short_name column of the cds\")\n  }\n\n  cds_subset <- cds_subset[row.names(subset(fData(cds_subset), gene_short_name %in% as.vector(gene_pairs_mat))), ]\n\n  # for(gene_name in unique(row.names(cds_subset))) {\n  #   data <- subset(pData(cds_subset), gene_id == gene_name)\n  #   \n  #   data$Pseudotime <- order(data$Pseudotime)\n    pData(cds_subset)[, 'Pseudotime'] <- order(pData(cds_subset)[, 'Pseudotime'])\n  # }\n  \n  f_id <- NA\n  Cell <- NA\n    if (cds_subset@expressionFamily@vfamily %in% c(\"negbinomial\", \"negbinomial.size\")) {\n        integer_expression <- TRUE\n    }\n    else {\n        integer_expression <- FALSE\n        relative_expr <- TRUE\n    }\n    if (integer_expression) {\n        cds_exprs <- exprs(cds_subset)\n        if (relative_expr) {\n            if (is.null(sizeFactors(cds_subset))) {\n                stop(\"Error: to call this function with relative_expr=TRUE, you must call estimateSizeFactors() first\")\n            }\n            cds_exprs <- Matrix::t(Matrix::t(cds_exprs)/sizeFactors(cds_subset))\n        }\n        cds_exprs <- reshape2::melt(round(as.matrix(cds_exprs)))\n    }\n    else {\n        cds_exprs <- reshape2::melt(as.matrix(exprs(cds_subset)))\n    }\n    if (is.null(min_expr)) {\n        min_expr <- cds_subset@lowerDetectionLimit\n    }\n    colnames(cds_exprs) <- c(\"f_id\", \"Cell\", \"expression\")\n    cds_pData <- pData(cds_subset)\n    cds_fData <- fData(cds_subset)\n    cds_exprs <- merge(cds_exprs, cds_fData, by.x = \"f_id\", by.y = \"row.names\")\n    cds_exprs <- merge(cds_exprs, cds_pData, by.x = \"Cell\", by.y = \"row.names\")\n    #cds_exprs$f_id <- as.character(cds_exprs$f_id)\n    #cds_exprs$Cell <- as.character(cds_exprs$Cell)\n    \n    if (integer_expression) {\n        cds_exprs$adjusted_expression <- cds_exprs$expression\n    }\n    else {\n      if(log)\n        cds_exprs$adjusted_expression <- log10(cds_exprs$expression)\n      else\n        cds_exprs$adjusted_expression <- cds_exprs$expression\n    }\n    # trend_formula <- paste(\"adjusted_expression\", trend_formula,\n    #     sep = \"\")\n    if (label_by_short_name == TRUE) {\n        if (is.null(cds_exprs$gene_short_name) == FALSE) {\n            cds_exprs$feature_label <- as.character(cds_exprs$gene_short_name)\n            cds_exprs$feature_label[is.na(cds_exprs$feature_label)] <- cds_exprs$f_id\n        }\n        else {\n            cds_exprs$feature_label <- cds_exprs$f_id\n        }\n    }\n    else {\n        cds_exprs$feature_label <- cds_exprs$f_id\n    }\n    cds_exprs$f_id <- as.character(cds_exprs$f_id)\n    cds_exprs$feature_label <- factor(cds_exprs$feature_label)\n\n    new_data <- data.frame(Pseudotime = pData(cds_subset)$Pseudotime)\n    model_expectation <- genSmoothCurves(cds_subset, cores=1, trend_formula = trend_formula,\n                        relative_expr = T, new_data = new_data)\n    colnames(model_expectation) <- colnames(cds_subset)\n    expectation <- ddply(cds_exprs, .(f_id, Cell), function(x) data.frame(\"expectation\"=model_expectation[x$f_id, x$Cell]))\n    cds_exprs <- merge(cds_exprs, expectation)\n    #cds_exprs$expectation <- expectation#apply(cds_exprs,1, function(x) model_expectation[x$f_id, x$Cell])\n\n    cds_exprs$expression[cds_exprs$expression < min_expr] <- min_expr\n    cds_exprs$expectation[cds_exprs$expectation < min_expr] <- min_expr\n    # if (is.null(panel_order) == FALSE) {\n    #     cds_subset$feature_label <- factor(cds_subset$feature_label,\n    #         levels = panel_order)\n    # }\n\n    # add inflection point here: \n    cds_exprs$inflection_point <- 0\n    for(gene_name in unique(cds_exprs$f_id)) {\n      data <- subset(cds_exprs, f_id == gene_name)\n      \n      # message('gene_name is ', gene_name)\n      inflection_point <- bede(data$Pseudotime, data$expectation, 0)\n      if(!is.finite(inflection_point$iplast))\n        inflection_point <- bede(data$Pseudotime, data$expectation, 1)\n      # inflection_point <- tryCatch(bede(data$Pseudotime, data$expectation, 0), error = function() \n      #   message('Running inflection point detection in the mode of convex/concave failed, trying concave/convex mode instead'), \n      #   bede(data$Pseudotime, data$expectation, 1))\n      # message('inflection_point is ', inflection_point$iplast)\n      cds_exprs[row.names(data), 'inflection_point'] <- inflection_point$iplast\n    }\n    \n    # enable us to plot two genes together for visualizing RDI \n    \n    cds_exprs$pairs <- \"None\"\n    cds_exprs$source <- F\n    for(i in 1:nrow(gene_pairs_mat)) {\n      x <- gene_pairs_mat[i, ]\n      current_gene_feature_ind <- which(cds_exprs$feature_label %in% x) #index: is belong to the current gene pair? \n      current_gene_pairs_bool <- cds_exprs$pairs[current_gene_feature_ind] == \"None\" # did the pairs column already set? \n      \n      cds_exprs$pairs[current_gene_feature_ind[current_gene_pairs_bool]] <- paste0(x[1], ' -> ', x[2]) # now set the element in pairs column (currently NA values) \n      cds_exprs$source[current_gene_feature_ind[current_gene_pairs_bool]] <- cds_exprs$feature_label[current_gene_feature_ind[current_gene_pairs_bool]] == x[1] #   \n      \n      dup_cds_subset <- cds_exprs[current_gene_feature_ind[!current_gene_pairs_bool], ] # \n      \n      if(nrow(dup_cds_subset) > 1)\n      {  \n        dup_cds_subset$pairs <- paste0(x[1], ' -> ', x[2]) # \n        dup_cds_subset$source[dup_cds_subset$feature_label == x[1]] <- T # \n        dup_cds_subset$source[dup_cds_subset$feature_label != x[1]] <- F # \n        \n        cds_exprs <- rbind(cds_exprs, dup_cds_subset) # \n      }\n    }\n    \n    q <- ggplot(aes(Pseudotime, expression), data = cds_exprs)\n    if(data_points) {\n      if (is.null(color_by) == FALSE) {\n        q <- q + geom_point(aes_string(color = color_by, shape = \"source\"), size = I(cell_size), position=position_jitter(horizontal_jitter, vertical_jitter))\n      } else {\n        q <- q + geom_point(size = I(cell_size), aes(shape = source), position=position_jitter(horizontal_jitter, vertical_jitter))\n      }\n    }\n    \n    if(fitting_type == 'loess') {\n      q <- q + geom_smooth(aes(color = source))\n    } else if(fitting_type == 'spline'){\n      q <- q + geom_line(aes(x = Pseudotime, y = expectation, color = source), data = cds_exprs)\n    } else {\n      warning('fitting type, ', fitting_type, ' is not supported yet! default to loess')\n      q <- q + geom_smooth(aes(color = source))\n    }\n    \n    if(log)\n      q <- q + facet_wrap(~pairs, nrow = n_row, ncol = n_col, scales = \"free_y\") + scale_y_log10() \n    else\n      q <- q + facet_wrap(~pairs, nrow = n_row, ncol = n_col, scales = \"free_y\") \n    if (min_expr < 1) {\n      q <- q + expand_limits(y = c(min_expr, 1))\n    }\n    if (relative_expr) {\n      q <- q + ylab(\"Relative Expression\")\n    } else {\n      q <- q + ylab(\"Absolute Expression\")\n    }\n    q <- q + xlab(\"Pseudo-time\")\n    if(turning_point)\n      q <- q + monocle:::monocle_theme_opts() + geom_vline(aes(xintercept = inflection_point, linetype = source))\n    else\n      q <- q + monocle:::monocle_theme_opts() \n    q \n}\n\n#' Plot the expression dynamics for a pair of genes in pseduotime with separate kinetic curves across two different lineages.\n#'\n#' This plotting function is used to make kinetic plots for pairs of genes along the pseudotime in each of branches defined with\n#' the branch point. So each pair of genes has two panels each represents a different branch. This function accepts a matrix where each \n#' row is the gene pair and the first column is the hypothetical source or regulator while the second column represents the hypothetical \n#' target. The name in this matrix should match the name in the gene_short_name column of the cds_subset object. Two vertical lines will \n#' be added which indicate the estimated inflection points of the two kinetic curves. The distance between the two curves implies \n#' the potential time delay betweeen two genes. Since Scribe doesn't consider the continous value of the pseudotime but merely the \n#' ordering of the cells along the pseudotime, the x-axis of this plot also only includes the ordering information. Also note that \n#' this function allow you to pass a matrix where genes are used across different rows. \n#' \n#' @param cds_subset CellDataSet for the experiment\n#' @param gene_pairs_mat A matrix where each row is the gene pair and the first column is the hypothetical source or regulator while the second column represents the hypothetical target. The name in this matrix should match the name in the gene_short_name column of the cds_subset object. \n#' @param min_expr the minimum (untransformed) expression level to use in plotted the genes.\n#' @param cell_size the size (in points) of each cell used in the plot\n#' @param n_row number of columns used to layout the faceted cluster panels\n#' @param n_col number of columns used to layout the faceted cluster panels\n#' @param color_by the cell attribute (e.g. the column of pData(cds_subset)) to be used to color each cell\n#' @param trend_formula the model formula to be used for fitting the expression trend over pseudotime\n#' @param label_by_short_name label figure panels by gene_short_name (TRUE) or feature id (FALSE)\n#' @param relative_expr A logic flag to determine whether or not we should use the relative expression values\n#' @param fitting_type The type of fitting procedure used to plot the gene expression dynamics curve, either loess (default) or spline curves.  \n#' @param log A logic flag to determine whether or not you want to log your data (or y-axis is in log scale)  \n#' @param data_points A logic flag to determine whether or not you want to plot the raw data points\n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom plyr ddply\n#' @importFrom reshape2 melt\n#' @export\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' gene_pairs_mat <- matrix(c('H19', 'Ccnd2', 'Ccnd2', 'Scnn1g'), ncol = 2)\n#' plot_gene_pairs_branched_pseudotime(lung, gene_pairs_mat)\n#' }\nplot_gene_pairs_branched_pseudotime <- function(cds_subset, \n                                    gene_pairs_mat = NULL,\n                                    branch_states = NULL, \n                                    branch_point=1,\n                                    branch_labels = NULL,\n                                    method = \"fitting\", \n                                    min_expr = NULL, \n                                    cell_size = 0.75,\n                                    n_row = NULL, \n                                    n_col = 2, \n                                    panel_order = NULL, \n                                    color_by = \"State\",\n                                    expression_curve_linetype_by = \"Branch\", \n                                    trend_formula = \"~ sm.ns(Pseudotime, df=3) * Branch\", \n                                    reducedModelFormulaStr = NULL, \n                                    label_by_short_name = TRUE,\n                                    relative_expr = TRUE,\n                                    fitting_type = c('loess', 'spline'), \n                                    log = TRUE,\n                                    data_points = FALSE,\n                                    ...)\n{\n\n  all_genes_in_pair <- as.vector(gene_pairs_mat)\n  if(! all(all_genes_in_pair %in% fData(cds_subset)$gene_short_name)) {\n    stop(\"cds_subset doesn't include all genes in gene_pairs_mat. Make sure all genes are included in gene_short_name column of the cds_subset\")\n  }\n\n  cds_subset <- cds_subset[row.names(subset(fData(cds_subset), gene_short_name %in% as.vector(gene_pairs_mat))), ]\n\n  Branch <- NA  \n  if (is.null(reducedModelFormulaStr) == FALSE) {\n    pval_df <- branchTest(cds_subset, \n                          branch_states=branch_states,\n                          branch_point=branch_point,\n                          fullModelFormulaStr = trend_formula,\n                          reducedModelFormulaStr = \"~ sm.ns(Pseudotime, df=3)\", \n                          ...)\n    fData(cds_subset)[, \"pval\"] <- pval_df[row.names(cds_subset), 'pval']\n  }\n  if(\"Branch\" %in% all.vars(terms(as.formula(trend_formula)))) { #only when Branch is in the model formula we will duplicate the \"progenitor\" cells\n    cds_subset <- monocle::buildBranchCellDataSet(cds_subset, \n                                         branch_states = branch_states, \n                                         branch_point=branch_point,\n                                         branch_labels = branch_labels, \n                                         progenitor_method = 'duplicate',\n                                         ...)\n  }\n  else {\n    pData(cds_subset)$Branch <- pData(cds_subset)$State\n  }\n  if (cds_subset@expressionFamily@vfamily %in% c(\"negbinomial\", \"negbinomial.size\")) {\n    integer_expression <- TRUE\n  }\n  else {\n    integer_expression <- FALSE\n  }\n  if (integer_expression) {\n    CM <- exprs(cds_subset)\n    if (relative_expr){\n      if (is.null(sizeFactors(cds_subset))) {\n        stop(\"Error: to call this function with relative_expr=TRUE, you must call estimateSizeFactors() first\")\n      }\n      CM <- Matrix::t(Matrix::t(CM)/sizeFactors(cds_subset))\n    }\n    cds_exprs <- reshape2::melt(round(as.matrix(CM)))\n  }\n  else {\n    cds_exprs <- reshape2::melt(exprs(cds_subset))\n  }\n  if (is.null(min_expr)) {\n    min_expr <- cds_subset@lowerDetectionLimit\n  }\n  colnames(cds_exprs) <- c(\"f_id\", \"Cell\", \"expression\")\n  cds_pData <- pData(cds_subset)\n  \n  cds_fData <- fData(cds_subset)\n  cds_exprs <- merge(cds_exprs, cds_fData, by.x = \"f_id\", by.y = \"row.names\")\n  cds_exprs <- merge(cds_exprs, cds_pData, by.x = \"Cell\", by.y = \"row.names\")\n  if (integer_expression) {\n    cds_exprs$adjusted_expression <- round(cds_exprs$expression)\n  }\n  else {\n    cds_exprs$adjusted_expression <- log10(cds_exprs$expression)\n  }\n  if (label_by_short_name == TRUE) {\n    if (is.null(cds_exprs$gene_short_name) == FALSE) {\n      cds_exprs$feature_label <- as.character(cds_exprs$gene_short_name)\n      cds_exprs$feature_label[is.na(cds_exprs$feature_label)] <- cds_exprs$f_id\n    }\n    else {\n      cds_exprs$feature_label <- cds_exprs$f_id\n    }\n  }\n  else {\n    cds_exprs$feature_label <- cds_exprs$f_id\n  }\n  cds_exprs$feature_label <- as.factor(cds_exprs$feature_label)\n  # trend_formula <- paste(\"adjusted_expression\", trend_formula,\n  #     sep = \"\")\n  cds_exprs$Branch <- as.factor(cds_exprs$Branch) \n  \n  new_data <- data.frame(Pseudotime = pData(cds_subset)$Pseudotime, Branch = pData(cds_subset)$Branch)\n  \n  full_model_expectation <- genSmoothCurves(cds_subset, cores=1, trend_formula = trend_formula, \n                                            relative_expr = T, new_data = new_data)\n  colnames(full_model_expectation) <- colnames(cds_subset)\n  \n  cds_exprs$full_model_expectation <- apply(cds_exprs,1, function(x) full_model_expectation[x[2], x[1]])\n  if(!is.null(reducedModelFormulaStr)){\n    reduced_model_expectation <- genSmoothCurves(cds_subset, cores=1, trend_formula = reducedModelFormulaStr,\n                                                 relative_expr = T, new_data = new_data)\n    colnames(reduced_model_expectation) <- colnames(cds_subset)\n    cds_exprs$reduced_model_expectation <- apply(cds_exprs,1, function(x) reduced_model_expectation[x[2], x[1]])\n  }\n  \n  # FIXME: If you want to show the bifurcation time for each gene, this function\n  # should just compute it. Passing it in as a dataframe is just too complicated\n  # and will be hard on the user. \n  # if(!is.null(bifurcation_time)){\n  #     cds_exprs$bifurcation_time <- bifurcation_time[as.vector(cds_exprs$gene_short_name)]\n  # }\n  if (fitting_type == \"loess\")\n    cds_exprs$expression <- cds_exprs$expression + cds_subset@lowerDetectionLimit\n  if (label_by_short_name == TRUE) {\n    if (is.null(cds_exprs$gene_short_name) == FALSE) {\n      cds_exprs$feature_label <- as.character(cds_exprs$gene_short_name)\n      cds_exprs$feature_label[is.na(cds_exprs$feature_label)] <- cds_exprs$f_id\n    }\n    else {\n      cds_exprs$feature_label <- cds_exprs$f_id\n    }\n  }\n  else {\n    cds_exprs$feature_label <- cds_exprs$f_id\n  }\n  cds_exprs$feature_label <- factor(cds_exprs$feature_label)\n  if (is.null(panel_order) == FALSE) {\n    cds_exprs$feature_label <- factor(cds_exprs$feature_label,\n                                      levels = panel_order)\n  }\n  cds_exprs$expression[is.na(cds_exprs$expression)] <- min_expr\n  cds_exprs$expression[cds_exprs$expression < min_expr] <- min_expr\n  cds_exprs$full_model_expectation[is.na(cds_exprs$full_model_expectation)] <- min_expr\n  cds_exprs$full_model_expectation[cds_exprs$full_model_expectation < min_expr] <- min_expr\n  \n  if(!is.null(reducedModelFormulaStr)){\n    cds_exprs$reduced_model_expectation[is.na(cds_exprs$reduced_model_expectation)] <- min_expr\n    cds_exprs$reduced_model_expectation[cds_exprs$reduced_model_expectation < min_expr] <- min_expr\n  }\n  \n  cds_exprs$State <- as.factor(cds_exprs$State)\n  cds_exprs$Branch <- as.factor(cds_exprs$Branch)\n  \n  cds_exprs$pairs <- \"None\"\n  cds_exprs$source <- F\n  for(i in 1:nrow(gene_pairs_mat)) {\n    x <- gene_pairs_mat[i, ]\n    current_gene_feature_ind <- which(cds_exprs$feature_label %in% x) #index: is belong to the current gene pair? \n    current_gene_pairs_bool <- cds_exprs$pairs[current_gene_feature_ind] == \"None\" # did the pairs column already set? \n    \n    cds_exprs$pairs[current_gene_feature_ind[current_gene_pairs_bool]] <- paste0(x[1], ' -> ', x[2]) # now set the element in pairs column (currently NA values) \n    cds_exprs$source[current_gene_feature_ind[current_gene_pairs_bool]] <- cds_exprs$feature_label[current_gene_feature_ind[current_gene_pairs_bool]] == x[1] #   \n    \n    dup_cds_subset <- cds_exprs[current_gene_feature_ind[!current_gene_pairs_bool], ] # \n    \n    if(nrow(dup_cds_subset) > 1)\n    {  \n      dup_cds_subset$pairs <- paste0(x[1], ' -> ', x[2]) # \n      dup_cds_subset$source[dup_cds_subset$feature_label == x[1]] <- T # \n      dup_cds_subset$source[dup_cds_subset$feature_label != x[1]] <- F # \n      \n      cds_exprs <- rbind(cds_exprs, dup_cds_subset) # \n    }\n  }\n  \n  q <- ggplot(aes(Pseudotime, expression), data = cds_exprs)\n  # if (!is.null(bifurcation_time)) {\n  #   q <- q + geom_vline(aes(xintercept = bifurcation_time),\n  #                       color = \"black\", linetype = \"longdash\")\n  # }\n  if(data_points) {\n    if (is.null(color_by) == FALSE) {\n      q <- q + geom_point(aes_string(color = color_by, shape = \"feature_label\"), size = I(cell_size))\n    }\n  }\n  if (is.null(reducedModelFormulaStr) == FALSE) {\n    if(log) {\n      q <- q + scale_y_log10() + facet_wrap(~pairs + Branch + \n                                              pval, nrow = n_row, ncol = n_col, scales = \"free_y\")\n    } else {\n      q <- q + facet_wrap(~pairs + Branch + \n                                              pval, nrow = n_row, ncol = n_col, scales = \"free_y\")      \n    }\n  } else {\n    if(log) {\n      q <- q + scale_y_log10() + facet_wrap(~pairs + Branch,\n                                                 nrow = n_row, ncol = n_col, scales = \"free_y\")\n    } else {\n      q <- q + facet_wrap(~pairs + Branch , nrow = n_row, ncol = n_col, scales = \"free_y\")      \n    }\n  }\n  if (fitting_type == \"loess\") {\n    q <- q + stat_smooth(aes(fill = Branch, color = Branch), \n                         method = \"loess\")\n  } else if (fitting_type == \"spline\") {\n    q <- q + geom_line(aes_string(x = \"Pseudotime\", y = \"full_model_expectation\",\n                                  color = \"source\"), data = cds_exprs) #+ scale_color_manual(name = \"Type\", values = c(colour_cell, colour), labels = c(\"Pre-branch\", \"AT1\", \"AT2\", \"AT1\", \"AT2\")\n  } else {\n      warning('fitting type, ', fitting_type, ' is not supported yet! default to loess')\n      q <- q + geom_smooth(aes(color = source))\n    }\n  \n  if(!is.null(reducedModelFormulaStr)) {\n    q <- q + geom_line(aes_string(x = \"Pseudotime\", y = \"reduced_model_expectation\"),\n                       color = 'black', linetype = 2, data =  cds_exprs)   \n  }\n  \n  q <- q + ylab(\"Expression\") + xlab(\"Pseudotime (stretched)\")\n  \n  q <- q + monocle:::monocle_theme_opts()\n  q + expand_limits(y = min_expr)\n  \n}\n\n# implement the support for multiple runs (run_vec) \n\n#' Plot the scatterplot formed by the space of x_{t - \\mu}, y_t as well as y_{t - 1} for a single pair of genes. \n#' \n#' This plot function is used to visualize the space formed by x_{t - \\mu}, y_t as well as y_{t - 1} which is \n#' used to calculate the RDI score I(x_t -> Y_t) = CMI(x_{t - \\mu}, y_t | y_{t - 1}). Please check other ploting\n#' functions (plot_gene_pairs_in_pseudotime, plot_gene_pairs_branched_pseudotime, plot_lagged_drevi, plot_cross_map, plot_gene_pairs_causality, plot_comb_logic) for more intuitive \n#' visualization. \n#' \n#' @param cds_subset CellDataSet for the experiment\n#' @param gene_pair A character vector consists of two gene short names while the first name is the hypothetical source and the second is the target. \n#' @param d The time delay between the source and the target gene \n#' @param run_vec A numeric vector of length equal to number of columns (cells) in the cds_subset, encoding the runs (or replicates) id for each experiment. \n#' @return a plotly object\n#' @import plotly\n#' @export\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' gene_pairs_mat <- matrix(c('H19', 'Ccnd2', 'Ccnd2', 'Scnn1g'), ncol = 2)\n#' plot_gene_pairs_scatter3D(lung, gene_pairs_mat[1, ], d = 5)\n#' }\n#' @export\nplot_gene_pairs_scatter3D <- function(cds_subset, gene_pair, d = 1, run_vec = NULL){\n  gene_id_1 <- row.names(subset(fData(cds_subset), gene_short_name %in% gene_pair[1]))\n  gene_id_2 <- row.names(subset(fData(cds_subset), gene_short_name %in% gene_pair[2]))\n  \n  if(length(gene_id_1) == 0 | length(gene_id_2) == 0)\n    stop('Please make sure all genes you provided in gene_pairs_mat exist in your data.')\n  \n  x <- exprs(cds_subset)[gene_id_1, ]\n  y <- exprs(cds_subset)[gene_id_2, ]\n  \n  if (is.numeric(x))\n    x <- as.matrix(x)\n  if (is.numeric(y))\n    y <- as.matrix(y)\n  if (nrow(x) != nrow(y))\n    stop(\"The number of time samples has to be the same for X and Y\")\n  \n  plot_ly(type = 'scatter3d', x = x[1:(nrow(x) - d), ], y = y[-(1:d), ], z = y[d:(nrow(y) - 1), ], mode = 'markers')\n}\n\n# This function need to rewrite which should starts from calculatin the temporal RDI before creating the heatmap plot \n#' Plot the scatterplot for two genes across different cells. \n#' \n#' This plot function is the commomly used approach to visualize the relationship between a gene pair.\n#' Please check other plots for plot_gene_pairs_in_pseudotime, plot_gene_pairs_branched_pseudotime, plot_lagged_drevi, plot_cross_map, plot_gene_pairs_causality, plot_comb_logic,  \n#' This function accepts a matrix where each row is the gene pair and the first column is the hypothetical source \n#' or regulator while the second column represents the hypothetical target. The name in this matrix should match \n#' the name in the gene_short_name column of the cds_subset object.\n#' \n#' @param cds_subset CellDataSet for the experiment\n#' @param gene_pairs_mat A matrix where each row is the gene pair and the first column is the hypothetical source or regulator while the second column represents the hypothetical target. The name in this matrix should match the name in the gene_short_name column of the cds_subset object. \n#' @param n_row number of columns used to layout the faceted cluster panels\n#' @param n_col number of columns used to layout the faceted cluster panels\n#' @return a pheatmap plot object\n#' @importFrom pheatmap pheatmap\n#' @export\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' gene_pairs_mat <- matrix(c('H19', 'Ccnd2', 'Ccnd2', 'Scnn1g'), ncol = 2)\n#' plot_regulation_over_time(lung, gene_pairs_mat)\n#' }\n#' @export\n#' \nplot_regulation_over_time <- function(res, gene_name_vec) {\n  dim(res) <- c(dim(res)[1], dim(res)[2] * dim(res)[2])\n  \n  all_cmbns <- expand.grid(gene_name_vec, gene_name_vec)\n  valid_all_cmbns_df <- data.frame(pair = paste(tolower(all_cmbns$Var1), tolower(all_cmbns$Var2), sep = '_'), pval = 0)\n  row.names(valid_all_cmbns_df) <- valid_all_cmbns_df$pair\n  colnames(res) <- valid_all_cmbns_df$pair\n  res <- apply(res, 1, function(x) (x - min(x)) / (max(x) - min(x)) ) # normalize by the maximal value\n  pheatmap::pheatmap(res, cluster_rows = F, cluster_cols = T, annotation_names_col = T)\n}\n\n# sparse network visualization (Hive / cico plot )\n# http://www.vesnam.com/Rblog/viznets3/\n# https://en.wikipedia.org/wiki/Gephi\n# end the paper with a hive plot (showing different network for all blood different cell type)  \n# hierarchical edge bundling\n# the layout from ISB \n# https://bost.ocks.org/mike/miserables/\n# BioFabric\n# http://www.diva-portal.org/smash/get/diva2:1034015/FULLTEXT01.pdf\n\n#' Plot the lagged DREVI plot pairs of genes across pseudotime. \n#' \n#' This plotting function builds on the original idea of DREVI plot but is extended in the context for causal network.  \n#' It considers the time delay between the hypothetical regulators to the target genes which is parametered by `d`. \n#' Lagged DREVI plot first estimate the joint density (P(x_{t - d}, y_t)) for variables x_{t - d} and y_t, then it divides the joint density by the \n#' marginal density P(x_{t - d}) to get the conditional density estimate (P(x_{t - d}, y_t | x_{x - d})). \n#' We then calculate the z-score normalizing each column of conditional density. Note that this plot tries to demonstrate the potential influence\n#' between two variables instead of the factual influence. A red line corresponding to the point with maximal density on each x value is plot which \n#' indicates the maximal possible point for y_t give the value of x_{t - d}. The 2-d density is estimated through the kde2d function from MASS package. \n#' \n#' @param cds_subset CellDataSet for the experiment\n#' @param gene_pairs_mat A matrix where each row is the gene pair and the first column is the hypothetical source or regulator while the second column represents the hypothetical target. The name in this matrix should match the name in the gene_short_name column of the cds_subset object. \n#' @param log A logic argument used to determine whether or not you should perform log transformation (using log(expression + 1)) before calculating density estimates, default to be TRUE. \n#' @param d The time delay between the source and target gene. \n#' @param grids The number of grid when creating the lagged DREVI plot.\n#' @param n_row number of columns used to layout the faceted cluster panels\n#' @param n_col number of columns used to layout the faceted cluster panels\n#' @param scales The character string passed to facet function, determines whether or not the scale is fixed or free in different dimensions.\n#' @param verbose A logic argument to determine whether or not we should print the detailed running information. \n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom plyr ddply\n#' @importFrom MASS kde2d\n#' @export\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' gene_pairs_mat <- matrix(c('H19', 'Ccnd2', 'Ccnd2', 'Scnn1g'), ncol = 2)\n#' plot_lagged_drevi(lung, gene_pairs_mat)\n#' }\n#' @references Krishnaswamy, Smita, et al. \"Conditional density-based analysis of T cell signaling in single-cell data.\" Science 346.6213 (2014): 1250689.\n#' @export\n#' \nplot_lagged_drevi <- function(cds_subset, gene_pairs_mat, \n                           log = TRUE,\n                           # nConBins = 4, \n                           d = 1,\n                           grids = NULL,\n                           n_row = NULL,\n                           n_col = 1,\n                           scales = \"free\",\n                           verbose = FALSE) {\n\n  gene_pairs_mat <- as.matrix(gene_pairs_mat)\n  all_genes_in_pair <- as.vector(gene_pairs_mat)\n  if(! all(all_genes_in_pair %in% fData(cds_subset)$gene_short_name)) {\n    stop(\"cds_subset doesn't include all genes in gene_pairs_mat. Make sure all genes are included in gene_short_name column of the cds_subset\")\n  }\n\n  cds_subset <- cds_subset[row.names(subset(fData(cds_subset), gene_short_name %in% all_genes_in_pair)), ]\n  \n  if(is.null(grids))\n    dim_val <- (round((ncol(cds_subset) - d) / 4))\n  else\n    dim_val <- grids\n  \n  flat_res <- as.data.frame(matrix(0, nrow = dim_val^2  * nrow(gene_pairs_mat), ncol = 4))\n  ridge_curve <- as.data.frame(matrix(0, nrow = dim_val * nrow(gene_pairs_mat), ncol = 3))\n  colnames(flat_res) <- c(\"x\", \"y\", \"den\", \"type\")\n  colnames(ridge_curve) <- c(\"x\", \"y\", \"type\")\n  xy <- data.frame()\n\n  id <- 0\n  for(gene_pairs_ind in 1:nrow(gene_pairs_mat))  {\n    # gene_pairs_ind <- 1\n    if(verbose)\n      message(\"current gene pair is \", gene_pairs_mat[gene_pairs_ind, 1], \" -> \",  gene_pairs_mat[gene_pairs_ind, 2])\n    \n    gene_pairs <- gene_pairs_mat[gene_pairs_ind, ]\n    f_ini_ind <- dim_val^2 * id #flat_res (normalized density results)\n    r_ini_ind <- dim_val * id #ridge_curve \n    \n    gene_pair_name <- paste(gene_pairs[1], gene_pairs[2], sep = ' -> ')\n\n    x <- matrix(exprs(cds_subset)[row.names(subset(fData(cds_subset), gene_short_name %in% gene_pairs[1])), ], ncol = 1)\n    y_ori <- matrix(exprs(cds_subset)[row.names(subset(fData(cds_subset), gene_short_name %in% gene_pairs[2])), ], ncol = 1)\n    \n    if(log) {\n      x <- log(x + 1)\n      y_ori <- log(y_ori + 1)\n    }\n    \n    if(d != 0) {\n      x  <- matrix(x[1:(nrow(x) - d), ], ncol = 1)\n      y <- matrix(y_ori[-(1:d), ], ncol = 1)\n      z <- y_ori[d:(nrow(y_ori) - 1), ]\n    }\n    else {\n      x  <- matrix(x, ncol = 1)\n      y <- matrix(y_ori, ncol = 1)\n      z <- y_ori\n    }\n    \n    exprs_res <- expression(paste(\"Target (\", \"y\", phantom()[{\n      paste(\"t\")\n    }], \")\", \"\"))\n    \n    if(length(unique(x)) < dim_val | length(unique(y)) < dim_val) {\n      # stop(paste0(\"Genes \", gene_pairs, \"are required to express in at least \", dim_val, \" cells\"))\n      # x <- x + rnorm(length(x), sd = 1e-10)\n    }\n    # # avoid the Error in MASS::kde2d(x, y, n = c(dim_val, dim_val), lims = c(min(x), max(x),:   bandwidths must be strictly positive\n    # if(length(unique(x)) < dim_val | length(unique(y)) < dim_val) {\n    #   stop(paste0(\"Genes \", gene_pairs, \"are required to express in at least \", dim_val, \" cells\"))\n    #   x <- x + rnorm(length(x), sd = 1e-10)\n    # }\n    # if(length(unique(y)) < dim_val)\n    #   y <- y + rnorm(length(y), sd = 1e-10)\n    # \n      bandwidth <- c(MASS::bandwidth.nrd(x), MASS::bandwidth.nrd(y))\n      if(any(bandwidth == 0)) {\n        max_vec <- c(max(x), max(y))\n        bandwidth[bandwidth == 0] <- max_vec[bandwidth == 0] / dim_val\n      }\n      den_xy <- MASS::kde2d(x, y, n = c(dim_val, dim_val), lims = c(min(x), max(x), min(y), max(y)), h = bandwidth)\n      den_res <- as.data.frame(den_xy$z)\n      # dimnames(den_res) <- list(paste0(\"x_\", as.character(den_xy$x)), paste0(\"y_\", as.character(den_xy$y)))\n      # den_x_res <- density(x, n = round(length(x))/ 4, from = min(x), to = max(x))\n      # den_x <- den_x_res$y\n      den_x <- rowSums(den_res) # just calculate the sum for each column\n\n      x_meshgrid <- den_xy$x\n      y_meshgrid <- den_xy$y\n    # }\n    \n    max_ind <- 1\n    \n    for(i in 1:length(x_meshgrid)) {\n      max_val <- max(den_res[i, ] / den_x[i]); min_val <- 0 #min(den_res[i, ] / den_x[i]) # \n\n      # print(den_x)\n      if(den_x[i] == 0) {\n      }\n      else {\n        max_ind <- which.max(den_res[i, ] / den_x[i]) \n      }\n       # message(\"i is \", i, \"j is \", j, \"vector is \", c(x_meshgrid[i], y_meshgrid[max_ind], gene_pair_name))\n      ridge_curve[i + r_ini_ind, ] <- c(x_meshgrid[i], y_meshgrid[max_ind], gene_pair_name)\n      \n      for(j in 1:length(y_meshgrid)) {\n        rescaled_val <- (den_res[i, j] / den_x[i] - min_val) / (max_val - min_val)\n        flat_res[(i - 1) * length(x_meshgrid) + j + f_ini_ind, ] <- c(x_meshgrid[i], y_meshgrid[j], rescaled_val, gene_pair_name)\n      }\n    }\n    xy_tmp <- data.frame(x = x, y = y, 'type' = gene_pair_name)\n    xy <- rbind(xy, xy_tmp)    \n    \n    id <- id + 1\n  }\n\n  # ridge_curve\n  colnames(xy) <- c('x', 'y', 'type')\n  flat_res[, 1:3] <- as.matrix(flat_res[, 1:3])\n  ggplot(aes(as.numeric(x), as.numeric(y)), data = flat_res) +  geom_raster(aes(fill = as.numeric(den)), interpolate=TRUE) + \n    scale_fill_gradientn(\"Density\", colours = terrain.colors(10)) + \n    geom_rug(aes(as.numeric(x), as.numeric(y)), data = xy, col=\"darkred\",alpha=.1) + \n    geom_path(aes(as.numeric(x), as.numeric(y)), data  = ridge_curve, color = 'red') + facet_wrap(~type, scales = scales, nrow = n_row, ncol = n_col) + \n    xlab( expression(paste(\"Source (\", \"x\", phantom()[{\n      paste(\"t\", phantom() - phantom(), d)\n    }], \")\", \"\"))) + \n    ylab(exprs_res) + monocle:::monocle_theme_opts()\n}\n\n# \n# lung <- load_lung()\n# plot_rdi_drevi(log2(exprs(lung)[3, ] + 1), log2(exprs(lung)[27, ] + 1), x_label = as.character(fData(lung)$gene_short_name[3]), y_label = as.character(fData(lung)$gene_short_name[27]))\n# \n# lung_gene_vec <- c(\"Cdk1\", \"Pdpn\", \"Ccnd2\",  \"Ccnd1\")\n# lung_gene_vec_ensemble <- row.names(subset(fData(lung), gene_short_name %in% lung_gene_vec))\n# \n# gene_pairs_mat <- matrix(lung_gene_vec, nrow = 2)\n# plot_rdi_pairs(lung, t(gene_pairs_mat), d = 20)\n\n# LPS_gene_vec <- c(\"Stat1\", \"Hhex\", \"Stat2\", \"Rbl1\")\n# gene_pairs_mat <- matrix(LPS_gene_vec, nrow = 2)\n# plot_rdi_pairs(Shalek_abs_subset_ko_LPS_new, t(gene_pairs_mat), d = 20)\n# # \n# load('/Users/xqiu/Dropbox (Personal)/Projects/Causal_network/causal_network/RData/analysis_scRNA_seq_Olsson.RData')\n# Olsson_gene_vec <- c('Irf8', \"Gfi1\", 'Zeb2', 'Ets1', 'Irf5', \"Irf8\")\n# \n# Olsson_gene_vec <- c('Zeb2', \"Ets1\")\n# gene_pairs_mat <- matrix(Olsson_gene_vec, nrow = 2)\n# plot_rdi_pairs(Olsson_granulocyte_cds, t(gene_pairs_mat), d = 1)\n\nplot_gene_pair_delay <- function() {\n  \n}\n\n# \n#' Plot the taylor diagram for the RDI, mutual information values. \n#' \n#' This plot function is the commomly used approach to visualize the relationship between a gene pair.\n#' Please check other plots for plot_lagged_drevi, plot_cross_map, plot_gene_pairs_causality, plot_comb_logic,  \n#' This function accepts a matrix where each row is the gene pair and the first column is the hypothetical source \n#' or regulator while the second column represents the hypothetical target. The name in this matrix should match \n#' the name in the gene_short_name column of the cds_subset object.\n#' \n#' @param cds_subset CellDataSet for the experiment\n#' @param gene_pairs_mat A matrix where each row is the gene pair and the first column is the hypothetical source or regulator while the second column represents the hypothetical target. The name in this matrix should match the name in the gene_short_name column of the cds_subset object. \n#' @param n_row number of columns used to layout the faceted cluster panels\n#' @param n_col number of columns used to layout the faceted cluster panels\n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom plyr ddply\n#' @importFrom reshape2 melt\n#' @export\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' gene_pairs_mat <- matrix(c('H19', 'Ccnd2', 'Ccnd2', 'Scnn1g'), ncol = 2)\n#' plot_taylor_diagram(cds_exprs[1, ], seq(0, 1, length.out = 100), MI = seq(2, 3, length.out = 100), Entropy = seq(4, 5, length.out = 1))\n#' }\n#' @references \n#' @export\n#' \n# this function modifies the taylor.diagram function from plotrix package \nplot_taylor_diagram <- function (ref, RDI, MI, Reference, add = FALSE, col = \"red\", pch = 19, pos.cor = TRUE, \n                            xlab = \"Entropy\", ylab = \"MI\", main = \"RDI Taylor Diagram\", show.gamma = TRUE, \n                            ngamma = 3, gamma.col = 8, sd.arcs = 0, ref.sd = FALSE, sd.method = \"sample\", \n                            grad.corr.lines = c(0.2, 0.4, 0.6, 0.8, 0.9), pcex = 1, cex.axis = 1, \n                            normalize = FALSE, mar = c(5, 4, 6, 6), text = NULL, ...) \n{\n  grad.corr.full <- c(0, 0.2, 0.4, 0.6, 0.8, 0.9, 0.95, 0.99, \n                      1)\n  \n  R <- RDI\n  sd.f <- MI\n  sd.r <- Reference \n  \n  # R <- cor(ref, model, use = \"pairwise\")\n  # if (is.list(ref)) \n  #   ref <- unlist(ref)\n  # if (is.list(model)) \n  #   ref <- unlist(model)\n  # SD <- function(x, subn) {\n  #   meanx <- mean(x, na.rm = TRUE)\n  #   devx <- x - meanx\n  #   ssd <- sqrt(sum(devx * devx, na.rm = TRUE)/(length(x[!is.na(x)]) - \n  #                                                 subn))\n  #   return(ssd)\n  # }\n  # subn <- sd.method != \"sample\"\n  # sd.r <- SD(ref, subn)\n  # sd.f <- SD(model, subn)\n  # if (normalize) {\n  #   sd.f <- sd.f/sd.r\n  #   sd.r <- 1\n  # }\n  maxsd <- 1.5 * max(sd.f, sd.r)\n  oldpar <- par(\"mar\", \"xpd\", \"xaxs\", \"yaxs\")\n  if (!add) {\n    if (pos.cor) {\n      if (nchar(ylab) == 0) \n        ylab = \"Standard deviation\"\n      par(mar = mar)\n      plot(0, xlim = c(0, maxsd), ylim = c(0, maxsd), xaxs = \"i\", \n           yaxs = \"i\", axes = FALSE, main = main, xlab = xlab, \n           ylab = ylab, type = \"n\", cex = cex.axis, ...)\n      if (grad.corr.lines[1]) {\n        for (gcl in grad.corr.lines) lines(c(0, maxsd * \n                                               gcl), c(0, maxsd * sqrt(1 - gcl^2)), lty = 3)\n      }\n      segments(c(0, 0), c(0, 0), c(0, maxsd), c(maxsd, \n                                                0))\n      axis.ticks <- pretty(c(0, maxsd))\n      axis.ticks <- axis.ticks[axis.ticks <= maxsd]\n      axis(1, at = axis.ticks, cex.axis = cex.axis)\n      axis(2, at = axis.ticks, cex.axis = cex.axis)\n      if (sd.arcs[1]) {\n        if (length(sd.arcs) == 1) \n          sd.arcs <- axis.ticks\n        for (sdarc in sd.arcs) {\n          xcurve <- cos(seq(0, pi/2, by = 0.03)) * sdarc\n          ycurve <- sin(seq(0, pi/2, by = 0.03)) * sdarc\n          lines(xcurve, ycurve, col = \"blue\", lty = 3)\n        }\n      }\n      if (show.gamma[1]) {\n        if (length(show.gamma) > 1) \n          gamma <- show.gamma\n        else gamma <- pretty(c(0, maxsd), n = ngamma)[-1]\n        if (gamma[length(gamma)] > maxsd) \n          gamma <- gamma[-length(gamma)]\n        labelpos <- seq(45, 70, length.out = length(gamma))\n        for (gindex in 1:length(gamma)) {\n          xcurve <- cos(seq(0, pi, by = 0.03)) * gamma[gindex] + \n            sd.r\n          endcurve <- which(xcurve < 0)\n          endcurve <- ifelse(length(endcurve), min(endcurve) - \n                               1, 105)\n          ycurve <- sin(seq(0, pi, by = 0.03)) * gamma[gindex]\n          maxcurve <- xcurve * xcurve + ycurve * ycurve\n          startcurve <- which(maxcurve > maxsd * maxsd)\n          startcurve <- ifelse(length(startcurve), max(startcurve) + \n                                 1, 0)\n          lines(xcurve[startcurve:endcurve], ycurve[startcurve:endcurve], \n                col = gamma.col)\n          if (xcurve[labelpos[gindex]] > 0) \n            boxed.labels(xcurve[labelpos[gindex]], ycurve[labelpos[gindex]], \n                         gamma[gindex], border = FALSE)\n        }\n      }\n      xcurve <- cos(seq(0, pi/2, by = 0.01)) * maxsd\n      ycurve <- sin(seq(0, pi/2, by = 0.01)) * maxsd\n      lines(xcurve, ycurve)\n      bigtickangles <- acos(seq(0.1, 0.9, by = 0.1))\n      medtickangles <- acos(seq(0.05, 0.95, by = 0.1))\n      smltickangles <- acos(seq(0.91, 0.99, by = 0.01))\n      segments(cos(bigtickangles) * maxsd, sin(bigtickangles) * \n                 maxsd, cos(bigtickangles) * 0.97 * maxsd, sin(bigtickangles) * \n                 0.97 * maxsd)\n      par(xpd = TRUE)\n      if (ref.sd) {\n        xcurve <- cos(seq(0, pi/2, by = 0.01)) * sd.r\n        ycurve <- sin(seq(0, pi/2, by = 0.01)) * sd.r\n        lines(xcurve, ycurve)\n      }\n      points(sd.r, 0, cex = pcex)\n      text(cos(c(bigtickangles, acos(c(0.95, 0.99)))) * \n             1.05 * maxsd, sin(c(bigtickangles, acos(c(0.95, \n                                                       0.99)))) * 1.05 * maxsd, c(seq(0.1, 0.9, by = 0.1), \n                                                                                  0.95, 0.99))\n      text(maxsd * 0.8, maxsd * 0.8, \"RDI\", srt = 315)\n      segments(cos(medtickangles) * maxsd, sin(medtickangles) * \n                 maxsd, cos(medtickangles) * 0.98 * maxsd, sin(medtickangles) * \n                 0.98 * maxsd)\n      segments(cos(smltickangles) * maxsd, sin(smltickangles) * \n                 maxsd, cos(smltickangles) * 0.99 * maxsd, sin(smltickangles) * \n                 0.99 * maxsd)\n    }\n    else {\n      # x <- ref\n      # y <- model\n      # R <- cor(x, y, use = \"pairwise.complete.obs\")\n      # E <- mean(x, na.rm = TRUE) - mean(y, na.rm = TRUE)\n      # xprime <- x - mean(x, na.rm = TRUE)\n      # yprime <- y - mean(y, na.rm = TRUE)\n      # sumofsquares <- (xprime - yprime)^2\n      # Eprime <- sqrt(sum(sumofsquares)/length(complete.cases(x)))\n      # E2 <- E^2 + Eprime^2\n      # if (add == FALSE) {\n      #   maxray <- 1.5 * max(sd.f, sd.r)\n      #   plot(c(-maxray, maxray), c(0, maxray), type = \"n\", \n      #        asp = 1, bty = \"n\", xaxt = \"n\", yaxt = \"n\", \n      #        xlab = xlab, ylab = ylab, main = main, cex = cex.axis)\n      #   discrete <- seq(180, 0, by = -1)\n      #   listepoints <- NULL\n      #   for (i in discrete) {\n      #     listepoints <- cbind(listepoints, maxray * \n      #                            cos(i * pi/180), maxray * sin(i * pi/180))\n      #   }\n      #   listepoints <- matrix(listepoints, 2, length(listepoints)/2)\n      #   listepoints <- t(listepoints)\n      #   lines(listepoints[, 1], listepoints[, 2])\n      #   lines(c(-maxray, maxray), c(0, 0))\n      #   lines(c(0, 0), c(0, maxray))\n      #   for (i in grad.corr.lines) {\n      #     lines(c(0, maxray * i), c(0, maxray * sqrt(1 - \n      #                                                  i^2)), lty = 3)\n      #     lines(c(0, -maxray * i), c(0, maxray * sqrt(1 - \n      #                                                   i^2)), lty = 3)\n      #   }\n      #   for (i in grad.corr.full) {\n      #     text(1.05 * maxray * i, 1.05 * maxray * sqrt(1 - \n      #                                                    i^2), i, cex = 0.6)\n      #     text(-1.05 * maxray * i, 1.05 * maxray * sqrt(1 - \n      #                                                     i^2), -i, cex = 0.6)\n      #   }\n      #   seq.sd <- seq.int(0, 2 * maxray, by = (maxray/10))[-1]\n      #   for (i in seq.sd) {\n      #     xcircle <- sd.r + (cos(discrete * pi/180) * \n      #                          i)\n      #     ycircle <- sin(discrete * pi/180) * i\n      #     for (j in 1:length(xcircle)) {\n      #       if ((xcircle[j]^2 + ycircle[j]^2) < (maxray^2)) {\n      #         points(xcircle[j], ycircle[j], col = \"darkgreen\", \n      #                pch = \".\")\n      #         if (j == 10) \n      #           text(xcircle[j], ycircle[j], signif(i, \n      #                                               2), cex = 0.5, col = \"darkgreen\")\n      #       }\n      #     }\n      #   }\n      #   seq.sd <- seq.int(0, maxray, length.out = 5)\n      #   for (i in seq.sd) {\n      #     xcircle <- (cos(discrete * pi/180) * i)\n      #     ycircle <- sin(discrete * pi/180) * i\n      #     if (i) \n      #       lines(xcircle, ycircle, lty = 3, col = \"blue\")\n      #     text(min(xcircle), -0.03 * maxray, signif(i, \n      #                                               2), cex = 0.5, col = \"blue\")\n      #     text(max(xcircle), -0.03 * maxray, signif(i, \n      #                                               2), cex = 0.5, col = \"blue\")\n      #   }\n      #   text(0, -0.08 * maxray, \"Standard Deviation\", \n      #        cex = 0.7, col = \"blue\")\n      #   text(0, -0.12 * maxray, \"Centered RMS Difference\", \n      #        cex = 0.7, col = \"darkgreen\")\n      #   points(sd.r, 0, pch = 22, bg = \"darkgreen\", cex = 1.1)\n      #   text(0, 1.1 * maxray, \"Correlation Coefficient\", \n      #        cex = 0.7)\n      # }\n      # S <- (2 * (1 + R))/(sd.f + (1/sd.f))^2\n    }\n  }\n  points(sd.f * R, sd.f * sin(acos(R)), pch = pch, col = col,\n         cex = pcex)\n  \n  if(! is.null(text)) {\n    text(sd.f * R, sd.f * sin(acos(R)),  #the line to add\n         labels=text, cex = pcex, pos=3) #You can change the pos argument to your liking\n  }\n  \n  invisible(oldpar)\n}\n\n#' Plot a heatmap to demonstrate the hypothetical time delay between any two genes \n#' \n#' This plot function uses the estimated turning_point for each gene in the cds_subset to estimate the time delay between any gene pairs. \n#' It then plots the time delay using a heatmap. \n#' \n#' @param cds_subset CellDataSet for the experiment\n#' @param gene_pairs_mat A matrix where each row is the gene pair and the first column is the hypothetical source or regulator while \n#' the second column represents the hypothetical target. The name in this matrix should match the name in the gene_short_name column \n#' of the cds_subset object. \n#' @param n_row number of columns used to layout the faceted cluster panels\n#' @param n_col number of columns used to layout the faceted cluster panels\n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom plyr ddply\n#' @importFrom reshape2 melt\n#' @export\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' gene_pairs_mat <- matrix(c('H19', 'Ccnd2', 'Ccnd2', 'Scnn1g'), ncol = 2)\n#' plot_time_delay(lung, gene_pairs_mat)\n#' }\n#' @export\n#' \n# function to plot the time delay between each gene: \nplot_time_delay <- function(cds_subset, use_gene_short_name = TRUE, cluster_row = TRUE, cluster_cols = TRUE) {\n  if(!(\"turning_point\" %in% colnames(fData(cds_subset)))) \n    stop('Please first run the xxx function before running this function')\n  \n  turning_point <- fData(cds_subset)[, c('gene_short_name', 'turning_point')] \n  \n  if(use_gene_short_name) {\n    if(any(duplicated(turning_point$gene_short_name)))\n      stop('gene_short_name column in fData has duplicated points!')\n    \n    row.names(turning_point) <- turning_point$gene_short_name\n  }\n  \n  time_delay_mat <- matrix(nrow = nrow(turning_point), ncol = nrow(turning_point), \n                           dimnames = list(row.names(turning_point), row.names(turning_point)))\n  for(gene_i in row.names(turning_point)) {\n    for(gene_j in row.names(turning_point)) {\n      time_delay_mat[gene_i, gene_j] <- abs(abs(turning_point[gene_i, 'turning_point']) - abs(turning_point[gene_j, 'turning_point']))\n    }\n  }\n  \n  if(any(!is.finite(time_delay_mat))) {\n    message('There is NA values in turining points calculated, the time delay is set to 0 by default')\n    \n    time_delay_mat[!is.finite(time_delay_mat)] <- 0\n  }\n  \n  ph_res <- pheatmap::pheatmap(time_delay_mat[, ], #ph$tree_row$order\n                               useRaster = T,\n                               cluster_cols=cluster_row, \n                               cluster_rows=cluster_row, \n                               show_rownames=T, \n                               show_colnames=T, \n                               #scale=\"row\",\n                               # clustering_distance_rows=row_dist, #row_dist\n                               clustering_method = \"ward.D2\", #\n                               # cutree_rows=num_clusters,\n                               # cutree_cols = 2,\n                               # annotation_row=annotation_row,\n                               # annotation_col=annotation_col,\n                               # annotation_colors=annotation_colors,\n                               # gaps_col = col_gap_ind,\n                               treeheight_row = 20, \n                               # breaks=bks,\n                               fontsize = 6,\n                               # color=hmcols, \n                               silent=TRUE)\n  \n  grid::grid.rect(gp=grid::gpar(\"fill\", col=NA))\n  grid::grid.draw(ph_res$gtable)\n}\n\n#' Plot the shadow mainfold from the lagged coordinates from a single variable. \n#' \n#' This plot function uses time lagged coordinates of a single variable (gene) x, (x_{t}, x_{t - d}, x_{t - 2d}) to reconstruct a shadow manifold. In CCM (cross-convergence mapping), this manifold can \n#' be used for detecting causality.  \n#' \n#' @param cds_subset CellDataSet for the experiment\n#' @param gene_name The name for gene used to reconstruct the shadow manifold. The gene name should appear in the gene_short_name column of the cds_subset object. \n#' @param d The time delay between the source and target gene. \n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom plyr ddply\n#' @importFrom reshape2 melt\n#' @export\n#' @examples\n#' \\dontrun{\n#' x_1 <- all_cell_simulation[1, , 1]\n#' x_2 <- all_cell_simulation[2, , 1]\n#' x_3 <- all_cell_simulation[3, , 1]\n#' \n#' plot_ly(type = 'scatter3d', x = x_1, y = x_2, z = x_3, mode = 'markers', color = 1:length(x_1))\n#' lung <- load_lung() \n#' gene_pairs_mat <- matrix(c('H19', 'Ccnd2', 'Ccnd2', 'Scnn1g'), ncol = 2)\n#' plot_shadow_manifold(lung, gene_pairs_mat[1])\n#' }\n#' @references Sugihara, George, et al. \"Detecting causality in complex ecosystems.\" science 338.6106 (2012): 496-500.\n#' @export\nplot_shadow_manifold <- function(cds_subset, gene_name, d = 1){\n  gene_id <- row.names(subset(fData(cds_subset), gene_short_name %in% gene_name))\n\n  if(length(gene_id) == 0)\n    stop('Please make sure the gene name you provided in gene_pairs_mat exist in your data.')\n  \n  if (is.numeric(x))\n    x <- as.matrix(x)\n  \n  x_1 <- x[seq(1, length(x) - 2 * d, by = 1)]\n  x_2 <- x[seq(1 + d, length(x) - d, by = 1)]\n  x_3 <- x[seq(1 + 2 * d, length(x), by = 1)]\n  # return(cmi(x[1:(nrow(x) - d), ], y[-(1:d), ], y[d:(nrow(y) - 1), ]))\n\n  plot_ly(type = 'scatter3d', x = x_1, y = x_2, z = x_3, color = 1:length(x_1), mode = 'markers')\n  \n}\n\n#' Plot the relationship between the predicted value (\\hat{x}(t) | M_y) and the observed x(t). \n#' \n#' This plotting function uses the simplex projection from the shadow manifold to estimate the source gene's value and then \n#' plot against the observe value. If there is a true causality from x to y, the predicted point should match up with \n#' the observed value pretty well. It also supports to plot the predicted value and the weighted target values based on \n#' the nearest neighbors used in the simplex projection. This two different plots are controlled by the type argument, \n#' where \"Prediction\" and \"Relationship\" corresponds to first and second plot respectively. This function accepts a matrix \n#' where each row is the gene pair and the first column is the hypothetical source or regulator while the second column \n#' represents the hypothetical target. The name in this matrix should match the name in the gene_short_name column of the \n#' cds_subset object.\n#' \n#' @param cds_subset CellDataSet for the experiment\n#' @param gene_pairs_mat A matrix where each row is the gene pair and the first column is the hypothetical source or regulator while the second column represents the hypothetical target. The name in this matrix should match the name in the gene_short_name column of the cds_subset object. \n#' @param tau the lag to use for time delay embedding (same as in the ccm function from the rEDM package)\n#' @param E the embedding dimensions to use for time delay embedding\n#' @param Type \n#' @param verbose whether or not to print the warning messages to the R console\n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom plyr ddply\n#' @importFrom reshape2 melt\n#' @export\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' gene_pairs_mat <- matrix(c('H19', 'Ccnd2', 'Ccnd2', 'Scnn1g'), ncol = 2)\n#' plot_cross_map(lung, gene_pairs_mat)\n#' }\n#' @export\n#' \nplot_cross_map <-function(cds_subset, gene_pairs_mat, tau = 1, E = 2, Type = c(\"Prediction\", \"Relationship\"), verbose = FALSE, return_all = FALSE) \n{\n  gene_pairs_mat <- as.matrix(gene_pairs_mat)\n  all_genes_in_pair <- as.vector(gene_pairs_mat)\n  if(! all(all_genes_in_pair %in% fData(cds_subset)$gene_short_name)) {\n    stop(\"cds_subset doesn't include all genes in gene_pairs_mat. Make sure all genes are included in gene_short_name column of the cds_subset\")\n  }\n  \n  cds_subset <- cds_subset[row.names(subset(fData(cds_subset), gene_short_name %in% all_genes_in_pair)), ]\n  \n  Time <- ncol(cds_subset)\n  n_shadow <- Time - (E - 1)*tau # maximal number of points for shadow manifold \n  \n  flat_res <- as.data.frame(matrix(0, nrow = n_shadow * 2 * nrow(gene_pairs_mat), ncol = 4))\n  colnames(flat_res) <- c(\"Observations\", \"Predictions\", \"Weighted_source\", \"Pair\")\n  \n  id <- 0\n  for(gene_pairs_ind in 1:nrow(gene_pairs_mat))  {\n    # gene_pairs_ind <- 1\n    if(verbose)\n      message(\"current gene pair is \", gene_pairs_mat[gene_pairs_ind, 1], \" -> \",  gene_pairs_mat[gene_pairs_ind, 2])\n    \n    gene_pairs <- gene_pairs_mat[gene_pairs_ind, ]\n    X <- as.numeric(exprs(cds_subset)[row.names(subset(fData(cds_subset), gene_short_name %in% gene_pairs[1])), ])# as.numeric(exprs(cds_subset)[gene_pairs[1], ])\n    Y <- as.numeric(exprs(cds_subset)[row.names(subset(fData(cds_subset), gene_short_name %in% gene_pairs[2])), ])\n    \n    laggedX<-gen_lagged_vec(X=X,E=E,tau=tau)\n    laggedY<-gen_lagged_vec(X=Y,E=E,tau=tau)\n    dists_x_all <- as.matrix(dist(laggedX$x))\n    dists_y_all <- as.matrix(dist(laggedY$x))\n    max_shadow <- dim(dists_x_all)[1]\n    # cor_x <- numeric(Time)\n    # cor_y <- numeric(Time)\n    \n    # for(L in (5+(E-1)*tau):Time) # why 5 + (E - 1) * tau here? \n    # {   \n    L = Time\n    n_shadow <- L-(E-1)*tau\n    pred_x <- numeric(n_shadow)\n    pred_y <- numeric(n_shadow)\n    actual_x <- numeric(n_shadow)\n    actual_y <- numeric(n_shadow) \n    \n    source_x <- numeric(n_shadow)\n    source_y <- numeric(n_shadow)\n    \n    # cor_x_tmp <- numeric(reps)\n    # cor_y_tmp <- numeric(reps)\n    \n    start <- 1\n    # if(randomWindow)\n    #     start <- sample(1:(max_shadow-n_shadow+1),1)\n    window <- start:(start+n_shadow-1)\n    \n    dists_x <- dists_x_all[window,window]\n    dists_y <- dists_y_all[window,window]\n    \n    x=laggedX$x[window,]\n    y=laggedY$x[window,]\n    nn_x <- get_nn(x,dists_x)\n    nn_y <- get_nn(y,dists_y)\n    \n    \n    for(i in 1:n_shadow)\n    {\n      ww <- calc_weights(x=x,dists=dists_x,index=i,nn=nn_x)\n      pred_y[i] <- predict_y(y=y,wt=ww)\n      actual_y[i] <- y[i,1]\n      source_x[i] <- predict_y(y=x,wt=ww)\n      \n      ww <- calc_weights(x=y,dists=dists_y,index=i,nn=nn_y)\n      pred_x[i] <- predict_y(y=x,wt=ww)\n      actual_x[i] <- x[i,1] \n      source_y[i] <- predict_y(y=y,wt=ww)\n    }      \n    \n    # cor_x[L] <- cor(pred_x,actual_x)\n    # cor_y[L] <- cor(pred_y,actual_y)\n    \n    # cat(L,'\\t',cor_x[L],'\\t',cor_y[L],'\\n')\n    \n    data <- data.frame(Observations = c(actual_x, actual_y), Predictions = c(pred_x, pred_y), \n                       Weighted_source = c(source_y, source_x), \n                       Pair = c(rep(paste0(gene_pairs[2], ' xmap ', gene_pairs[1]), n_shadow), \n                                rep(paste0(gene_pairs[1], ' xmap ', gene_pairs[2]), n_shadow)), stringsAsFactors = FALSE)\n    \n    flat_res[(id + 1):(id + 2 * n_shadow), ] <- data\n    \n    id <- id + 2 * n_shadow\n  }\n  \n  flat_res$Pair <- factor(flat_res$Pair, levels = unique(flat_res$Pair))\n  \n  if(Type == 'Prediction')\n    g <- qplot(Observations, Predictions, data = flat_res, geom = 'point', log = 'xy', size = I(1), size = 2) +\n    xlab('') + ylab('') + geom_point(color = I(\"black\"), size = I(0.85)) + geom_smooth(method = 'lm') + \n    monocle:::monocle_theme_opts() + facet_wrap(~Pair, ncol = 2, scales = 'free') + geom_abline(color = 'red')\n  else if(Type == 'Relationship')\n    g <- qplot(Predictions, Weighted_source, data = res$res, geom = 'point', log = 'xy', size = I(1), size = 2) +\n    xlab('') + ylab('') + geom_point(color = I(\"black\"), size = I(0.85)) + geom_smooth(method = 'loess') + \n    monocle:::monocle_theme_opts() + facet_wrap(~Pair, ncol = 2, scales = 'free') + geom_abline(color = 'red')\n  \n  if(return_all) {\n    return(list(res = flat_res, g = g))\n  } else {\n    return(g)\n  }\n}\n\nmeshgrid <- function (x, y = x) {\n  if (!is.numeric(x) || !is.numeric(y)) \n    stop(\"Arguments 'x' and 'y' must be numeric vectors.\")\n  x <- c(x)\n  y <- c(y)\n  n <- length(x)\n  m <- length(y)\n  X <- matrix(rep(x, each = m), nrow = m, ncol = n)\n  Y <- matrix(rep(y, times = n), nrow = m, ncol = n)\n  return(list(X = X, Y = Y))\n}\n\n# add the functionality to normalize either row or column for the data \n#' Plot the heatmap for the expected value y(t) given x(t - d) and y(t - 1). \n#' \n#' This plotting function tries to intuitively visualize the informatioin transfer from x(t - d) to y(t) given y(t)'s previous state y(t - 1).\n#' Firstly, we divide the expression space for x(t - d) to y(t - 1) based on grid_num and then we estimate the k-nearest neighbor for each of the\n#' grid. We then use a Gaussian kernel to estimate the expected value for y(t). It is then displayed in two dimension with x(t - d) and y(t - 1)\n#' as two axis and the color represents the expected value of y(t) give x(t - d) and y(t - 1). This function accepts a matrix where each row is the gene pair and the \n#' first column is the hypothetical source or regulator while the second column represents the hypothetical target. The name in this matrix should \n#' match the name in the gene_short_name column of the cds_subset object.\n#' \n#' @param cds_subset CellDataSet for the experiment\n#' @param gene_pairs_mat A matrix where each row is the gene pair and the first column is the hypothetical source or regulator while the second column represents the hypothetical target. The name in this matrix should match the name in the gene_short_name column of the cds_subset object. \n#' @param log A logic argument to determine whether or not we should log the data before we perform density estimation.\n#' @param d The time delay between the source gene and the target gene. \n#' @param k The number of the nearest neighbors used in calculating the expectation value of y(t). \n#' @param grid_num The number of grids used in estimating density. \n#' @param n_row number of columns used to layout the faceted cluster panels\n#' @param n_col number of columns used to layout the faceted cluster panels\n#' @param scales \n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom RANN nn2\n#' @export\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' gene_pairs_mat <- matrix(c('H19', 'Ccnd2', 'Ccnd2', 'Scnn1g'), ncol = 2)\n#' plot_gene_pair_causality(lung, gene_pairs_mat)\n#' }\n#' @export\n#' \n# create the heatmap for the rdi value: \nplot_gene_pairs_causality <- function(cds_subset, gene_pairs_mat, \n                                   log = FALSE, \n                                   d = 1, \n                                   k = 5, \n                                   grid_num = 25,\n                                   n_row = NULL,\n                                   n_col = 1,\n                                   scales = \"free\",\n                                   verbose = FALSE) {\n  \n  gene_pairs_mat <- as.matrix(gene_pairs_mat)\n  all_genes_in_pair <- as.vector(gene_pairs_mat)\n  if(! all(all_genes_in_pair %in% fData(cds_subset)$gene_short_name)) {\n    stop(\"cds_subset doesn't include all genes in gene_pairs_mat Make sure all genes are included in gene_short_name column of the cds_subset.\")\n  }\n  \n  cds_subset <- cds_subset[row.names(subset(fData(cds_subset), gene_short_name %in% all_genes_in_pair)), ]\n  \n  flat_res <- as.data.frame(matrix(0, nrow = grid_num^2  * nrow(gene_pairs_mat), ncol = 4))\n  colnames(flat_res) <- c(\"x\", \"z\", \"expected_y\", \"pair\")\n  # xy <- data.frame()\n  \n  id <- 0\n  for(gene_pairs_ind in 1:nrow(gene_pairs_mat))  {\n    # gene_pairs_ind <- 1\n    if(verbose)\n      message(\"current gene pair is \", gene_pairs_mat[gene_pairs_ind, 1], \" -> \",  gene_pairs_mat[gene_pairs_ind, 2])\n    \n    gene_pairs <- gene_pairs_mat[gene_pairs_ind, ]\n    f_ini_ind <- grid_num^2 * id #flat_res (normalized density results)\n    \n    gene_pair_name <- paste(gene_pairs[1], gene_pairs[2], sep = ' -> ')\n    \n    x <- matrix(exprs(cds_subset)[row.names(subset(fData(cds_subset), gene_short_name %in% gene_pairs[1])), ], ncol = 1)\n    y_ori <- matrix(exprs(cds_subset)[row.names(subset(fData(cds_subset), gene_short_name %in% gene_pairs[2])), ], ncol = 1)\n    \n    if(log) {\n      x <- log(x + 1)\n      y_ori <- log(y_ori + 1)\n    }\n    \n    if(d != 0) {\n      x  <- matrix(x[1:(nrow(x) - d), ], ncol = 1)\n      y <- matrix(y_ori[-(1:d), ], ncol = 1)\n      z <- y_ori[d:(nrow(y_ori) - 1), ]\n    }\n    else {\n      x  <- matrix(x, ncol = 1)\n      y <- matrix(y_ori, ncol = 1)\n      z <- y_ori\n    }\n    \n    if(length(unique(x)) < grid_num | length(unique(y)) < grid_num) {\n      # stop(paste0(\"Genes \", gene_pairs, \"are required to express in at least \", grid_num, \" cells\"))\n      # x <- x + rnorm(length(x), sd = 1e-10)\n    }\n    \n    data <- data.frame(x = x, y = y, z = z)\n    \n    rng_x <- range(x)\n    rng_z <- range(z)\n    x_meshgrid <- seq(rng_x[1], rng_x[2], length.out = grid_num)\n    z_meshgrid <- seq(rng_z[1], rng_z[2], length.out = grid_num)\n    \n    xz_meshgrid <- meshgrid(x_meshgrid, z_meshgrid)\n    xz_query <- matrix(c(as.vector(xz_meshgrid$X), as.vector(xz_meshgrid$Y)), ncol = 2)\n    \n    knn_res <- RANN::nn2(data[, 1:2], query = xz_query, k = k + 1)\n    \n    dist_mat <- apply(knn_res$nn.idx, 1, function(x) {\n      abs(data[x[-1], 2] - data[x[1], 2])\n    })\n    dist_mat <- knn_res$nn.dists\n    \n    for(index in 1:nrow(dist_mat)) {\n      u <- exp(-dist_mat[index, -1]/ min(dist_mat[index, -1]))\n      w <- u / sum(u)\n      \n      subset_dat <- data[knn_res$nn.idx[index, -1], 2]\n      tmp <- sum(w * subset_dat)\n      flat_res[f_ini_ind + index, ] <- c(xz_query[index, ], tmp, gene_pair_name)\n    }\n    \n    # row-scale the data \n    vals <- as.numeric(flat_res[c(f_ini_ind + 1):c(f_ini_ind + nrow(dist_mat)), 3])\n    max_val <- max(vals, na.rm = T) \n    if(!is.finite(max_val))\n      max_val <- 1e10\n    \n    # print(max_val)\n    for(index in 1:nrow(dist_mat)) {\n      flat_res[f_ini_ind + index, 3] <- as.numeric(flat_res[f_ini_ind + index, 3])  / max_val\n    }\n    \n    id <- id + 1\n  }\n  \n  flat_res[, 1:3] <- as.matrix(flat_res[, 1:3])\n  flat_res[, 4] <- factor(flat_res[, 4], levels = unique(flat_res[, 4]))\n  ggplot(aes(as.numeric(x), as.numeric(z)), data = flat_res) +  geom_raster(aes(fill = as.numeric(expected_y)), interpolate=TRUE) + \n    scale_fill_gradientn(expression(paste(\"Expection (\", \"y\", phantom()[{\n      paste(\"t\")\n    }], \")\", \"\")), colours = terrain.colors(10)) + \n    # geom_rug(aes(as.numeric(x), as.numeric(y)), data = xy, col=\"darkred\",alpha=.1) + \n    # geom_path(aes(as.numeric(x), as.numeric(y)), data  = ridge_curve, color = 'red') + \n    facet_wrap(~pair, scales = scales, nrow = n_row, ncol = n_col) + \n    xlab( expression(paste(\"Source (\", \"x\", phantom()[{\n      paste(\"t\", phantom() - phantom(), d)\n    }], \")\", \"\"))) + \n    ylab(expression(paste(\"Target (\", \"y\", phantom()[{\n      paste(\"t\", phantom() - phantom(), \"1\")\n    }], \")\", \"\"))) + monocle:::monocle_theme_opts()\n}\n\n# add the \n#' Plot the combinatorial influence of two genes x, y to the target z. \n#' \n#' This plotting function tries to intuitively visualize the influence from genes x and y to the target z. \n#' Firstly, we divide the expression space for x and y based on grid_num and then we estimate the k-nearest neighbor for each of the\n#' grid. We then use a Gaussian kernel to estimate the expected value for z. It is then displayed in two dimension with x and y\n#' as two axis and the color represents the value of the expected of z. This function accepts a matrix where each row is the gene pair\n#' and the target genes for this pair. The first column is the first hypothetical source or regulator, the second column represents \n#' the second hypothetical target while the third column represents the hypothetical target gene. The name in this matrix should match \n#' the name in the gene_short_name column of the cds_subset object.\n#'  \n#' @param cds_subset CellDataSet for the experiment\n#' @param gene_pairs_mat A matrix where each row is the gene pair and the first column is the hypothetical source or regulator while the second column represents the hypothetical target. The name in this matrix should match the name in the gene_short_name column of the cds_subset object. \n#' @param n_row number of columns used to layout the faceted cluster panels\n#' @param n_col number of columns used to layout the faceted cluster panels\n#' @param k number of nearest points used in estimate the expected value \n#' @return a ggplot2 plot object\n#' @import ggplot2\n#' @importFrom RANN nn2\n#' @export\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' gene_pairs_mat <- matrix(c('H19', 'Ccnd2', 'Ccnd2', 'Scnn1g'), ncol = 2)\n#' plot_comb_logic(lung, gene_pairs_mat)\n#' }\n#' @export\n#' \nplot_comb_logic <- function(cds_subset, gene_pairs_target_mat, \n                                    log = FALSE, \n                                    d = 1,\n                                    grid_num = 25,\n                                    n_row = NULL,\n                                    n_col = 1,\n                                    normalized = TRUE,\n                                    scales = \"free\",\n                                    k = 5, \n                                    verbose = FALSE) {\n  \n  gene_pairs_target_mat <- as.matrix(gene_pairs_target_mat)\n  all_genes_in_pair <- as.vector(gene_pairs_target_mat)\n  if(! all(all_genes_in_pair %in% fData(cds_subset)$gene_short_name)) {\n    stop(\"cds_subset doesn't include all genes in gene_pairs_target_mat Make sure all genes are included in gene_short_name column of the cds_subset\")\n  }\n  \n  cds_subset <- cds_subset[row.names(subset(fData(cds_subset), gene_short_name %in% all_genes_in_pair)), ]\n  \n  flat_res <- as.data.frame(matrix(0, nrow = grid_num^2  * nrow(gene_pairs_target_mat), ncol = 4))\n  colnames(flat_res) <- c(\"x\", \"y\", \"expected_z\", \"pair\")\n  # xy <- data.frame()\n  \n  id <- 0\n  for(gene_pairs_ind in 1:nrow(gene_pairs_target_mat))  {\n    # gene_pairs_ind <- 1\n    if(verbose)\n      message(\"current gene pair is \",  paste0(gene_pairs[1], \" : \", gene_pairs[2], \" -> \", gene_pairs[3]))\n    \n    gene_pairs <- gene_pairs_target_mat[gene_pairs_ind, ]\n    f_ini_ind <- grid_num^2 * id #flat_res (normalized density results)\n    \n    gene_pair_name <- paste0(gene_pairs[1], \" : \", gene_pairs[2], \" -> \", gene_pairs[3])\n    \n    x <- matrix(exprs(cds_subset)[row.names(subset(fData(cds_subset), gene_short_name %in% gene_pairs[1])), ], ncol = 1)\n    y <- matrix(exprs(cds_subset)[row.names(subset(fData(cds_subset), gene_short_name %in% gene_pairs[2])), ], ncol = 1)\n    z <- matrix(exprs(cds_subset)[row.names(subset(fData(cds_subset), gene_short_name %in% gene_pairs[3])), ], ncol = 1)\n    \n    if(log) {\n      x <- log(x + 1)\n      y <- log(y + 1)\n      z <- log(z + 1)\n    }\n    \n    data <- data.frame(x = x, y = y, z = z)\n    \n    rng_x <- range(x)\n    rng_y <- range(y)\n    x_meshgrid <- seq(rng_x[1], rng_x[2], length.out = grid_num)\n    y_meshgrid <- seq(rng_y[1], rng_y[2], length.out = grid_num)\n    \n    xy_meshgrid <- meshgrid(x_meshgrid, y_meshgrid)\n    xy_query <- matrix(c(as.vector(xy_meshgrid$X), as.vector(xy_meshgrid$Y)), ncol = 2)\n    \n    knn_res <- RANN::nn2(data[, 1:2], query = xy_query, k = k + 1)\n    \n    dist_mat <- apply(knn_res$nn.idx, 1, function(x) {\n      abs(data[x[-1], 3] - data[x[1], 3])\n    })\n    dist_mat <- knn_res$nn.dists\n    \n    for(index in 1:nrow(dist_mat)) {\n      u <- exp(-dist_mat[index, -1]/ min(dist_mat[index, -1]))\n      w <- u / sum(u)\n      \n      subset_dat <- data[knn_res$nn.idx[index, -1], 3]\n      tmp <- sum(w * subset_dat)\n      flat_res[f_ini_ind + index, ] <- c(xy_query[index, ], tmp, gene_pair_name)\n    }\n    \n    # row-scale the data \n    if(normalized) {\n      vals <- as.numeric(flat_res[c(f_ini_ind + 1):c(f_ini_ind + nrow(dist_mat)), 3])\n      max_val <- max(vals, na.rm = T) \n      if(!is.finite(max_val))\n        max_val <- 1e10\n      \n      # print(max_val)\n      for(index in 1:nrow(dist_mat)) {\n        flat_res[f_ini_ind + index, 3] <- as.numeric(flat_res[f_ini_ind + index, 3])  / max_val\n      }\n    }\n    \n    id <- id + 1\n  }\n  \n  flat_res[, 1:3] <- as.matrix(flat_res[, 1:3])\n  flat_res[, 4] <- factor(flat_res[, 4], levels = unique(flat_res[, 4]))\n  ggplot(aes(as.numeric(x), as.numeric(y)), data = flat_res) +  geom_raster(aes(fill = as.numeric(expected_z)), interpolate=TRUE) + \n    scale_fill_gradientn(expression(paste(\"Expection (\", \"z\", phantom()[{\n      paste(\"t\")\n    }], \")\", \"\")), colours = terrain.colors(10)) + \n    # geom_rug(aes(as.numeric(x), as.numeric(y)), data = xy, col=\"darkred\",alpha=.1) + \n    # geom_path(aes(as.numeric(x), as.numeric(y)), data  = ridge_curve, color = 'red') + \n    facet_wrap(~pair, scales = scales, nrow = n_row, ncol = n_col) + \n    xlab( expression(paste(\"Source (\", \"x\", \")\", \"\"))) + \n    ylab(expression(paste(\"Source (\", \"y\", \")\", \"\"))) + monocle:::monocle_theme_opts()\n}\n\n\n#' Plot the causal network inferred by Scribe \n#' \n#' This plot function uses state-of-art graph visualization tool (including plot, hiearchy plot and arc diagram) to visualize the causal network, identified by Scribe. \n#' See also the plot_hive_network for making beautiful Hive plots. \n#' \n#' @param graph A igraph object describing inferred causal network \n#' @param type A character describing which type of the plot will be used for making the network plot  \n#' @param layout A layout function which will only be used when we set type = 'igraph'. \n#' @return a plot object\n#' @import igraph, hiveR\n#' @importFrom netbiov level.plot\n#' @importFrom arcdiagram arcplot\n#' @export\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' gene_pairs_mat <- matrix(c('H19', 'Ccnd2', 'Ccnd2', 'Scnn1g'), ncol = 2)\n#' plot_causal_network(lung, gene_pairs_mat)\n#' }\n#' @references Hive plot, hiearchy plot and arc diagram plot, etc. \n#' @export\n#' \n# plot_time_delay_heatmap(lung, use_gene_short_name = F)\nplot_causal_network <- function(graph, type = c('igraph', 'hiearchy', 'arcdiagram'), layout = NULL, ...) {\n  if(class(graph) != 'igraph' | length(E(graph)) == 0)\n    stop('Please pass an igraph object for the graph object and make sure it has at least one edge')\n  \n  if(type == 'igraph') {\n    if(!is.null(layout)) {\n      if(!is.function(layout)) {\n        stop(\"Please make sure layout is a supported FUNCTION from igraph or customized layout FUNCTION\")\n      } else {\n        layout_coord = layout(graph)\n      }\n    }\n    \n    plot(graph, layout = layout_coord) #, vertex.size=2, vertex.label=NA, vertex.color = 'black'        \n  }\n  else if(type == 'hiearchy') {\n    res <- level.plot(graph) # create the hiearchical plot \n    \n    cus_layout <- res$layout\n    master_regulator_id <- cus_layout[, 2] %in% min(unique(cus_layout[, 2])) #1:2 #\n    direct_target_id <- cus_layout[, 2] %in% unique(cus_layout[, 2])[order(unique(cus_layout[, 2])) == 2]\n    secondary_target_id <- cus_layout[, 2] %in% max(unique(cus_layout[, 2]))\n    \n    cus_layout[master_regulator_id, 1]\n    cus_layout[master_regulator_id, 1] <- c(-10, 10)\n    cus_layout[direct_target_id, 1] <- cus_layout[direct_target_id, 1] * 1.5 #order(cus_layout[direct_target_id, 1]) * 2  - length(cus_layout[direct_target_id, 1]) * 20\n    cus_layout[secondary_target_id, 1] <- cus_layout[secondary_target_id, 1] * 1#order(cus_layout[secondary_target_id, 1]) * 10 - length(cus_layout[secondary_target_id, 1])  * 5\n    \n    v_size <- rep(res$vertex.size, nrow(cus_layout))\n    v_size[master_regulator_id] <- 12\n    v_size[direct_target_id] <- 4#v_size[direct_target_id] * 1.5\n    v_size[secondary_target_id] <- 2.5\n    \n    cus_layout[master_regulator_id, 2] <- 0\n    cus_layout[direct_target_id, 2] <- -1\n    cus_layout[secondary_target_id, 2] <- -2\n    \n    res$vertex.label.cex <- rep(0.25, length(v_size))\n    res$vertex.label.cex[1:2] <- 1\n    res$layout <- cus_layout\n    res$bg <- 'white'\n    res$vertex.size <- v_size\n    \n    res$vertex.label <- V(res$g)$name\n    res$lab.color <- 'black'\n    \n    res$vertex.color[1:2] <- c('#BCA0CC')\n    res$vertex.color[direct_target_id] <- '#77CCD2'\n    res$vertex.color[res$vertex.color == 'orange2'] <- '#7EB044'\n    \n    secondary_layer_degree <- degree(res$g, v = V(res$g)$name[cus_layout[, 2] == -1], mode = c(\"out\"),\n                                     loops = TRUE, normalized = FALSE)\n    res$vertex.color[which(cus_layout[, 2] == -1)[secondary_layer_degree == 0]] <- '#F3756C'\n    # secondary_layer <- degree(res$g, v = V(res$g)$name[cus_layout[, 2] == -1], mode = c(\"out\"),\n    #                           loops = TRUE, normalized = FALSE)\n    \n    res$vertex.frame.color <- res$vertex.color\n    res$vertex.label <- c(res$vertex.label[1:2], rep('', length(res$vertex.label) - 2))\n    \n    netbiov::plot.netbiov(res)\n  }\n  else if(type == 'arcdiagram') {\n    edge <- get.edgelist(graph)\n    \n    arcplot(edge, ordering=sort(unique(c(edge[, 1], edge[, 2]))), \n            horizontal=TRUE,\n            #labels=paste(\"node\",1:10,sep=\"-\"),\n            #lwd.arcs=4*runif(10,.5,2), \n            col.arcs=hsv(runif(9,0.6,0.8),alpha=0.4),\n            show.nodes=TRUE, pch.nodes=21, cex.nodes=runif(10,1,3), \n            col.nodes=\"gray80\", bg.nodes=\"gray90\", lwd.nodes=2)\n    \n    # # create the figure according the hiearchical plot \n    # arcplot(edge, ordering=unique(c(edge[, 1], edge[, 2])), horizontal=TRUE,\n    #         #labels=paste(\"node\",1:10,sep=\"-\"),\n    #         #lwd.arcs=4*runif(10,.5,2), \n    #         col.arcs=hsv(abs(cus_layout) / max(abs(cus_layout)),alpha=0.4),\n    #         show.nodes=TRUE, pch.nodes=21, cex.nodes=runif(10,1,3), \n    #         col.nodes=\"gray80\", bg.nodes=\"gray90\", lwd.nodes=2)\n  }\n}\n\nplot_temporal_causality <- function(temp_causality_list, type = c('rdi', 'crdi') ) {\n  rdi_crdi_pseudotime_res_list <- rdi_crdi_pseudotime(t(exprs(na_sim_cds)[1:12, 1:200]), window_size = 50) #13 mature gives Na values\n\n  rdi_res <- rdi_crdi_pseudotime_res_list$rdi_res\n  crdi_res <- rdi_crdi_pseudotime_res_list$crdi_res\n\n  dim(rdi_res) <- c(dim(rdi_res)[1], dim(rdi_res)[2] * dim(rdi_res)[2])\n\n  all_cmbns <- expand.grid(gene_name_vec[1:12], gene_name_vec[1:12])\n  valid_all_cmbns_df <- data.frame(pair = paste((all_cmbns$Var1), (all_cmbns$Var2), sep = ' -> '), pval = 0)\n\n  row.names(valid_all_cmbns_df) <- valid_all_cmbns_df$pair\n  rdi_res <- as.data.frame(rdi_res)\n  colnames(rdi_res) <- valid_all_cmbns_df$pair\n\n  valid_all_cmbns_df <- data.frame(pair = paste((as.character(neuron_network[, 1])), (as.character(neuron_network[, 2])), sep = ' -> '), pval = 0)\n  valid_rdi_res <- rdi_res[, as.character(valid_all_cmbns_df$pair)]\n  norm_valid_rdi_res <- apply(valid_rdi_res, 2, function(x) (x - min(x)) / (max(x) - min(x)))\n  pheatmap::pheatmap(t(norm_valid_rdi_res[, ]), cluster_rows = F, cluster_cols = F, annotation_names_row = T, border_color = NA)\n\n  valid_all_cmbns_df_back <- data.frame(pair = paste((as.character(neuron_network[, 1])), (as.character(neuron_network[, 2])), sep = ' -> '), pval = 0)\n  valid_rdi_res_back <- rdi_res[, as.character(valid_all_cmbns_df_back$pair)]\n  norm_valid_rdi_res_back <- apply(valid_rdi_res_back, 2, function(x) (x - min(x)) / (max(x) - min(x)))\n  pheatmap::pheatmap(t(norm_valid_rdi_res_back[, ]), cluster_rows = F, cluster_cols = F, annotation_names_row = T, border_color = NA)\n}\n\n#' Make a hive plot \n#' \n#' This function creates a HiveR plot with the genes names, list of causality score matrix for each dataset (cell types), each cell dataset and \n#' name of each cell datasets and the color to visualize each dataset. It is based on the HiveR package. \n#' \n#' @param gene_names A vector of gene names whose length should match up with the dimensions of the matrix in the casuality_mat_list. \n#' @param casuality_mat_list A list of square matrix of the casuality score (either RDI or cRDI, etc.).  \n#' @param cds_list A list of cell dataset objects correspond to the each of the casuality score matrix. \n#' @param group_names A vector of group names correspond to the data in the list, which will be used to label the axis on the Hive plot. \n#' @param group_color A vector of color correspond to the data in the list, which will be used to color the edges for each group of data.   \n#' @param top_edge_num Number of top edges you would like to select from each dataset to visualize. Default to be 100.  \n#' @param axLab.gpar (Same argument in plotHive function) A list of name - value pairs acceptable to gpar. These control the label and arrow displays.\n#' @param bkgnd (Same argument in plotHive function) Any valid color specification. Used for the background color for plotHive.\n#' @param return_hive_plot_data A logic flag to determine whether or not you would like to return the Hive plot object\n#' @param verbose A logic flag to determine whether or not you would like to see detailed running information \n#' @param ... Other arguments passed into the plotHive function. \n#' @return a plot plot object\n#' @import HiveR\n#' @importFrom plotHive HiveR\n#' @export\n#' @examples\n#' \\dontrun{\n#' gene_list <- c(positive_score_genes, negtive_score_genes)\n#' cell_type_list <- c(\"Erythrocyte\", \"Megakaryocyte\", \"Monocyte\", \"Neutrophil\", 'Basophil / Eosinophil', 'Dendritic cell')\n#' cell_type_color <- c(\"#E41A1C\", \"#377EB8\", \"#4DAF4A\", \"#984EA3\", \"#FF7F00\", \"#6A3D9A\", \"#A65628\", \"#F781BF\")\n#'\n#' rdi_list <- list(Ery_list$max_rdi_value, MK_list$max_rdi_value, Mono_list$max_rdi_value, Neu_list$max_rdi_value, BE_list$max_rdi_value, DC_list$max_rdi_value)\n#' cds_list <- list(Ery_cds, MK_cds, Mono_cds, Neu_cds, BE_cds, DC_cds)\n#' plot_hive_network(gene_list, rdi_list, cds_list, cell_type_list, top_edge_num = 25)\n#' }\n#' @export\n#' \nplot_hive_network <- function(gene_names, casuality_mat_list, cds_list, group_names, \n                                 data_group_color =  c(\"#E41A1C\", \"#377EB8\", \"#4DAF4A\", \"#984EA3\", \"#FF7F00\", \"#6A3D9A\", \"#A65628\", \"#F781BF\"), \n                                 top_edge_num = 100, \n                                 axLab.gpar = gpar(col = \"black\", fontsize = 6, lwd = 0.5), \n                                 bkgnd = \"white\",\n                                 return_hive_plot_data = FALSE, \n                                 verbose = FALSE,\n                                 ...) {\n  gene_num <- length(gene_names)\n  \n  if(length(casuality_mat_list) != length(cds_list) | length(casuality_mat_list) != length(group_names)) {\n    stop('Make sure your data include the same number of groups for casuality_mat_list, cds_list, group_names!')\n  }\n  \n  for(i in 1:length(casuality_mat_list)) {\n    mat_dim <- dim(casuality_mat_list[[i]])\n    cds_dim <- dim(cds_list[[i]])\n  \n    mat_names <- dimnames(casuality_mat_list[[i]])\n    \n    if(!(all(gene_names %in% mat_names[[1]])) | mat_dim[[1]] != mat_dim[[2]] | ! (all(dimnames(casuality_mat_list[[1]])[[1]] == dimnames(casuality_mat_list[[1]])[[2]] )) | !(mat_names[[1]] %in% row.names(cds_list[[i]])) )\n      stop(\"Make sure casuality_mat_list include all genes from gene_names and it is a square matrix with the row names and column names are the same; the cds should also include all the genes from the casuality matrix!\")\n  }\n  \n  nodes2 <- c()\n  edges2 <- c()\n  \n  group_num <- length(casuality_mat_list)\n  \n  for(group_ind in 1:group_num) {\n    if(verbose)\n      message('current group_ind is ', group_ind)\n    \n    nodes_tmp <- data.frame(id = 1:gene_num, lab = gene_names, vals = 1:gene_num, radius = (1:gene_num) * (100 / gene_num), \n                            axis = group_ind, size = 1, color = \"#00000000\", stringsAsFactors = F)\n    \n    tmp <- expand.grid(1:gene_num, 1:gene_num, stringsAsFactors = F)\n    super_graph <- tmp[tmp[, 1] != tmp[, 2], ]\n    max_rdi_value <- casuality_mat_list[[group_ind]]\n    \n    weight_vec <- apply(super_graph, 1, function(x) \n    {\n      max_rdi_value[gene_names[x[1]], gene_names[x[2]]]\n    })\n    \n    if(length(weight_vec) < top_edge_num) {\n      stop('top_edge_num should be less than or equal to all possible non self-regulating edges.')\n    }\n    \n    valid_edge_id <- which(weight_vec >= sort(weight_vec, decreasing = T)[top_edge_num])\n    weight_vec <- weight_vec[valid_edge_id]   # take only the top 100 edges\n    weight_vec <- 2 * (weight_vec - min(weight_vec)) / (max(weight_vec) - min(weight_vec))  \n    edges_tmp <- data.frame(id1 = super_graph[valid_edge_id, 1], id2 = super_graph[valid_edge_id, 2], \n                            weight = weight_vec, color = data_group_color[group_ind], stringsAsFactors = F)\n    \n    if(group_ind == 1) {\n      nodes_tmp$id <- as.integer(nodes_tmp$id)\n      \n      edges_tmp$id1 <- as.integer(edges_tmp$id1)\n      edges_tmp$id2 <- as.integer(edges_tmp$id2 + (group_num - 1) * gene_num)\n      # \n      # edges_tmp$id1 <- as.integer(edges_tmp$id1 + group_num * gene_num)\n      # edges_tmp$id2 <- as.integer(edges_tmp$id2)\n      \n      nodes2 <- nodes_tmp\n      edges2 <- edges_tmp\n    } else {\n      nodes_tmp$id <- as.integer(nodes_tmp$id + (group_ind - 1) * gene_num)\n      \n      edges_tmp$id1 <- as.integer(edges_tmp$id1 + (group_ind - 1) * gene_num)\n      edges_tmp$id2 <- as.integer(edges_tmp$id2 + (group_ind - 2) * gene_num)\n      \n      nodes2 <- rbind(nodes2, nodes_tmp)\n      edges2 <- rbind(edges2, edges_tmp)\n    }\n  }\n  \n  hpd = list()\n  hpd$nodes = nodes2\n  hpd$edges = edges2\n  hpd$type = \"2D\"\n  hpd$desc = \"Paul\"\n  hpd$axis.cols = rep('#ffffff', 6) # make invisible\n  hpd$axLabs = group_names #,\"colour\",\"clarity\")\n  class(hpd) = \"HivePlotData\"\n  \n  # Check data correctly formatted\n  \n  chkHPD(hpd, confirm = TRUE)\n  \n  if(return_hive_plot_data) {\n    return(hpd)\n  }\n  else {\n    plotHive(hpd, axLabs = hpd$axLabs, axLab.gpar = axLab.gpar, bkgnd = bkgnd, ...)\n  }\n}\n",
    "created" : 1507158420116.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "129483608",
    "id" : "2DD51003",
    "lastKnownWriteTime" : 1507861551,
    "last_content_update" : 1507861551,
    "path" : "~/Dropbox (Personal)/Projects/Causal_network/causal_network/Cpp/Real_deal/Scribe/Scribe/R/plotting.R",
    "project_path" : "R/plotting.R",
    "properties" : {
    },
    "relative_order" : 11,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}