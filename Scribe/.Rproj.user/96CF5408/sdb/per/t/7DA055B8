{
    "collab_server" : "",
    "contents" : "#' Causal network inference limitted to the interaction between informative transcription factors and those to other informative target genes. \n#' \n#' This function implements a procedure to build a causal network based on some prior information of the transcription factors (TFs). It calculates the information \n#' transfer from TFs to the targets as well as the information transfer between transcription factors while avoiding the calculation of information transfer between \n#' the targets and from targets to the TFs. This function accepts a vector for the gene short names for all the transcription factors and another vector for the \n#' informative genes selected through BEAM or methods.\n#' \n#' @param cds CellDataSet for the experiment\n#' @param TF A vector of the gene short names for all the transcription factors. \n#' @param informative_genes A vector of the informative genes used for network inference, which is identified through BEAM or other methods. It should include some TFs and normally other target genes.  \n#' @param delays A vector of time delays used during information transfer estimation between genes \n#' @param include_conditioning A logic argument to determine whether or not we should also calculate the conditioning RDI values \n#' @param smoothing A logic argument to determine whether or not we should also smooth the data using loess before we calculate the RDI values \n#' @param cluster_TFs A logic value to determine whether or not we should cluster the TFs' expression (for either the group of TFs or targets) before estimating the RDI/cRDI value. \n#' @param cluster_targets A logic value to determine whether or not we should cluster the target genes' expression (for either the group of TFs or targets) before estimating the RDI/cRDI value. \n#' @param cluster_TFs_num Number of TF clusters you will use for estimating the information transfer.  \n#' @param cluster_targets_num Number of target clusters you will use for estimating the information transfer.  \n#' @param cluster_num_method Which method you will use to determine the proper number of cluster for either the TFs or the targets. \n#' Options include NULL (default, don't use any method), mcclust (model-based optimal number of clusters: TF) and finally pamk (number of clusters estimated by optimum average silhouette width). \n#' @param hclust_method Which cluster method in hclust you will use. Default to be ward.D2.\n#' @param norm_method Determines how to transform expression values prior to estimate information transfer\n#' @param scale Determine whether or not to scale data prior to estimate information transfer\n#' @param scale_max The maximum value (in standard deviations) to show in the heatmap. Values larger than this are set to the max.\n#' @param scale_min The minimum value (in standard deviations) to show in the heatmap. Values smaller than this are set to the min.\n#' @return a matrix storing the RDI values for interactions from TFs to the targets as well as between transcription factors.\n#' @importFrom Mclust mclust\n#' @importFrom pamk fpc\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' TF <- c('H19', 'Ccnd2', 'Ccnd2', 'Scnn1g'); TF_id <- row.names(subset(fData(lung), gene_short_name %in% TF))\n#' informative_genes_id <- row.names(lung)\n#' wired(lung, TF_id, informative_genes_id)\n#' }\n#' @export\n#' \nwired <- function(cds, TF, informative_genes, \n                    delays = c(1, 10, 15), \n                    include_conditioning = FALSE,\n                    smoothing = FALSE, \n                    cluster_TFs = FALSE,\n                    cluster_targets = FALSE, \n                    cluster_TFs_num = 3,\n                    cluster_targets_num = 6, \n                    cluster_num_method = c(NULL, \"mcclust\", \"pamk\"),\n                    hclust_method = \"ward.D2\",\n                    norm_method = c('log', 'vstExprs'),\n                    scale = FALSE,\n                    scale_max = 3, \n                    scale_min = -3,\n                    ...) {\n  \n  pseudocount <- 1 \n\n  # 1. read in the TF list\n  TF_vec_names <- intersect(TF, informative_genes)\n  target_vec_names <- setdiff(informative_genes, TF)\n  \n  unique_gene <- unique(c(TF, informative_genes))\n  gene_name_ids <- intersect(row.names(cds), unique_gene)\n\n  if(length(unique_gene) != length(gene_name_ids)) {\n    stop(\"The cds you provided doesn't include all genes from the TF and informative_genes vector!\")\n  }\n\n  cds_subset <- cds[gene_name_ids, ]\n  pData(cds_subset)$Pseudotime <- order(pData(cds_subset)$Pseudotime)\n\n  exprs_data <- exprs(cds_subset)[, pData(cds_subset)$Pseudotime] # get the expression matrix \n  \n  # FIXME: this needs to check that vst values can even be computed. (They can only be if we're using NB as the expressionFamily)\n  if(norm_method == 'vstExprs' && is.null(cds_subset@dispFitInfo[[\"blind\"]]$disp_func) == FALSE) {\n    exprs_data = vstExprs(cds_subset, expr_matrix=exprs_data)\n  }     \n  else if(norm_method == 'log') {\n    exprs_data = log10(exprs_data+pseudocount)\n  }\n  \n  annotation_TF_cluster = NULL\n  annotation_target_cluster = NULL\n  cRDI <- NULL \n\n  if(cluster_TFs | cluster_targets) {\n    if(smoothing) {\n      for(i in 1:ncol(exprs_data)) {\n        df <- data.frame(Pseudotime = 1:ncol(exprs_data), Expression = exprs_data[i, ])\n        test <- loess(Expression ~ Pseudotime, df)\n        exprs_data[i, ] <-  predict(test)\n      }\n    }\n\n    exprs(cds_subset) <- exprs_data # change the cds to smoothed exprs_data \n\n    # Row-center the data.\n    m <- exprs_data\n    m=m[!apply(m,1,sd)==0,]\n    if(scale) {\n      m=Matrix::t(scale(Matrix::t(m),center=TRUE))\n      m=m[is.na(row.names(m)) == FALSE,]\n      m[is.nan(m)] = 0\n      m[m>scale_max] = scale_max\n      m[m<scale_min] = scale_min\n    }\n    \n    TF_vec_names <- intersect(TF_vec_names, row.names(m))\n    target_vec_names <- intersect(target_vec_names, row.names(m))\n    \n    m_tfs <- m[TF_vec_names, ]\n    m_targets <- m[target_vec_names, ]\n\n    if(cluster_num_method == 'mcclust') {\n      clust_num_check_tfs <- mclust::Mclust(t(m_tfs), G=1:min(10, length(TF_vec_names) / 2)) #(round(length(m_tfs) / 2))\n      cluster_TFs_num <- dim(clust_num_check_tfs$z)[2]\n\n      clust_num_check_targets <- mclust::Mclust(t(m_targets), G=1:min(10, length(target_vec_names) / 2))\n      cluster_targets_num <- dim(clust_num_check_targets$z)[2]\n\n      cat(\"model-based optimal number of clusters: TF: \", cluster_TFs_num, \", targets: \", cluster_targets_num, \"\\n\")\n    } else if(cluster_num_method == 'pamk') {\n      dissimilarity_mat_tfs <- 1 - cor(t(m_tfs)); \n      dissimilarity_mat_targets <- 1 - cor(t(m_targets));      \n\n      clust_num_check_tfs <- fpc::pamk(dissimilarity_mat_tfs, diss = T)\n      clust_num_check_targets <- fpc::pamk(dissimilarity_mat_targets, diss = T)\n\n      cluster_TFs_num <- clust_num_check_tfs$nc      \n      cluster_targets_num <- clust_num_check_targets$nc\n      \n      cat(\"number of clusters estimated by optimum average silhouette width: TF: \", cluster_TFs_num, \", targets: \", cluster_targets_num, \"\\n\")\n    }\n    # cluster TFs\n    if(cluster_TFs) {\n      row_dist <- as.dist((1 - cor(Matrix::t(m_tfs)))/2)\n      row_dist[is.na(row_dist)] <- 1\n      \n      m_hclust <- hclust(row_dist, method = hclust_method) # $order, ]\n      \n      annotation_TF_cluster <- data.frame(Cluster=factor(cutree(m_hclust, cluster_TFs_num)), row.names = row.names(m_tfs)) \n\n      # calculate the average of gene expression for each cluster and then run RDI between the TFs and the target.  \n      m_TFs_clusters <- matrix(nrow = ncol(cds_subset), ncol = cluster_TFs_num)\n      for(cluster_ind in 1:cluster_TFs_num) {\n        gene_inds <- annotation_TF_cluster$Cluster == cluster_ind\n        m_TFs_clusters[, cluster_ind] <- colMeans(m_tfs[gene_inds, ])\n      }\n\n      colnames(m_TFs_clusters) <- paste0(\"TFs_\", 1:cluster_TFs_num)\n    } else {\n      m_TFs_clusters <- m_tfs\n    }\n    # cluster TFs\n    if(cluster_targets) {\n      row_dist <- as.dist((1 - cor(Matrix::t(m_targets)))/2)\n      row_dist[is.na(row_dist)] <- 1\n      \n      m_hclust <- hclust(row_dist, method = hclust_method) # $order, ]\n      \n      annotation_target_cluster <- data.frame(Cluster=factor(cutree(m_hclust, cluster_targets_num)), row.names = row.names(m_targets)) \n\n      # calculate the average of gene expression for each cluster and then run RDI between the TFs and the target.  \n      m_targets_clusters <- matrix(nrow = ncol(cds_subset), ncol = cluster_targets_num)\n      for(cluster_ind in 1:cluster_targets_num) {\n        gene_inds <- annotation_target_cluster$Cluster == cluster_ind\n        m_targets_clusters[, cluster_ind] <- colMeans(m_targets[gene_inds, ])\n      }\n\n      colnames(m_targets_clusters) <- paste0(\"target_\", 1:cluster_targets_num)\n    } else {\n      m_targets_clusters <- m_targets\n    }\n    # 2. build the super-graph:\n\n    TF_vec_names <- colnames(m_TFs_clusters)\n    target_vec_names <- colnames(m_targets_clusters)\n\n    exprs_data <- cbind(m_TFs_clusters, m_targets_clusters) # RDI requires row: cells; column: genes\n\n    TF_pair <- expand.grid(TF_vec_names, TF_vec_names, stringsAsFactors = F) # between TFs \n    TF_target_pair <- expand.grid(TF_vec_names, target_vec_names, stringsAsFactors = F) # from TFs to the targets \n\n    tmp <- rbind(TF_pair, TF_target_pair)\n    \n    tmp[, 1] <- match(tmp[, 1], colnames(exprs_data))\n    tmp[, 2] <- match(tmp[, 2], colnames(exprs_data))\n    \n    all_pairwise_gene <- tmp[tmp[, 1] != tmp[, 2], ] - 1 # convert to C++ index\n\n    RDI_res <- calculate_rdi_cpp_wrap(as.matrix(exprs_data), delays = delays, super_graph = as.matrix(all_pairwise_gene), turning_points = 0, method = 1, uniformalize = F) # run RDI \n    \n    if(include_conditioning)\n      cRDI_res <- calculate_conditioned_rdi_cpp_wrap(as.matrix(exprs_data), super_graph = as.matrix(all_pairwise_gene), \n                                                     max_rdi_value = RDI_res$max_rdi_value, max_rdi_delays = RDI_res$max_rdi_delays, k = 1, uniformalize = FALSE) # run cRDI \n\n  } else {\n    # 2. build the super-graph:\n    exprs(cds_subset) <- exprs_data # change the cds to smoothed exprs_data \n    exprs_data <- t(exprs_data) \n    \n    TF_pair <- expand.grid(TF_vec_names, TF_vec_names, stringsAsFactors = F) # between TFs \n    TF_target_pair <- expand.grid(TF_vec_names, target_vec_names, stringsAsFactors = F) # from TFs to the targets \n\n    tmp <- rbind(TF_pair, TF_target_pair)\n    \n    tmp[, 1] <- match(tmp[, 1], colnames(exprs_data))\n    tmp[, 2] <- match(tmp[, 2], colnames(exprs_data))\n    \n    all_pairwise_gene <- tmp[tmp[, 1] != tmp[, 2], ] - 1 # convert to C++ index\n\n    RDI_res <- calculate_rdi(cds_subset, delays = delays, super_graph = all_pairwise_gene, log = FALSE, ...) # run RDI \n  \n    if(include_conditioning)\n      cRDI_res <- calculate_conditioned_rdi(exprs_data, rdi_list = RDI_res, ...) # run cRDI \n  }\n\n  return(list(RDI_res = RDI_res, \n    cRDI = cRDI,\n    annotation_TF_cluster = annotation_TF_cluster, \n    annotation_target_cluster = annotation_target_cluster))\n}\n",
    "created" : 1507668734634.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3665025445",
    "id" : "7DA055B8",
    "lastKnownWriteTime" : 1507679221,
    "last_content_update" : 1507679221,
    "path" : "~/Dropbox (Personal)/Projects/Causal_network/causal_network/Cpp/Real_deal/Scribe/Scribe/R/wired.R",
    "project_path" : "R/wired.R",
    "properties" : {
    },
    "relative_order" : 14,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}