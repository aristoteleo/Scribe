{
    "collab_server" : "",
    "contents" : "#include <RcppArmadillo.h>\n\n#include <kde/kde.hpp>  // ANN declarations\nusing namespace Rcpp;\nusing namespace arma;\n\n// [[Rcpp::interfaces(r, cpp)]]\n// [[Rcpp::export]]\nNumericMatrix kde_cpp(NumericMatrix data, int k = 1, int b = 1, int pdf = 1, int density_sample_type = 1)\n{\n  NumericMatrix density; \n  int N = data.rows(), d = data.cols();\n\n  // set up the size of the density matrix \n\tif(density_sample_type == 1) {\n\t\t density = NumericMatrix(N, 1);\n\t} else if(density_sample_type == 2) {\n\t\tif(d == 1) {\n\t\t  density = NumericMatrix(1001, 1);\n\t\t} else if(d == 2) {\n\t\t  density = NumericMatrix(201, 201);\n\t\t}\n\t}\n\n  NumericVector tmp; \n  \n\tKDE* kde = new KDE();\n\tvector<double> data_row;\n\n\tkde->set_kernel_type(k);\n\tkde->set_bandwidth_opt_type(b);\n\n\tfor(int i = 0; i < N; i ++){\n\t\ttmp = data(i, _); \n\t  data_row = as<vector <double> > (tmp);\n\t  // Rcout << \"tmp is \" << tmp << std::endl; \n\t  kde->add_data(data_row);\n\t}\n\n\tint vars_count = kde->get_vars_count(); \n\n\tif(vars_count == 1){\n    \n\t\tdouble min_x = kde->get_min(0);\n\t\tdouble max_x = kde->get_max(0);\n\n\t\tif(density_sample_type == 1) {\n\t\t  for(int i = 0; i < N; i ++) {\n\t\t\t\tdouble x = data(i, 0); \n\n\t\t\t\tif(pdf == 1){\n\t\t\t\t\tdensity(i, 0) = kde->pdf(x);\n\t\t\t\t}else if (pdf == 2){\n\t\t\t\t\tdensity(i, 0) = kde->cdf(x);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if(density_sample_type == 2){\n\t\t\tdouble x_increment = (max_x-min_x)/1000.0;\n\t    \n\t    int i = 0;\n\t\t\tfor(double x = min_x; x <= max_x; x += x_increment){\n\t\t\t\tif(pdf == 1){\n\t\t\t\t\tdensity(i, 0) = kde->pdf(x);\n\t\t\t\t}else{\n\t\t\t\t\tdensity(i, 0) = kde->cdf(x);\n\t\t\t\t}\n\t\t\t\ti ++; \n\t\t\t}\n\t\t}\n\n\t}else if(vars_count == 2){\n\n\t\tdouble min_x = kde->get_min(0);\n\t\tdouble max_x = kde->get_max(0);\n\t\tdouble min_y = kde->get_min(1);\n\t\tdouble max_y = kde->get_max(1);\n\n\t\tif(density_sample_type == 1) {\n\t\t  \n\t\t  for(int i = 0; i < N; i++){\n\t\t    double x = data(i, 0);\n\t\t    double y = data(i, 1); \n\t\t    // Rcout << \"x is \" << x << \" y is \" << y << std::endl; \n\t\t    \n\t\t    if(pdf == 1){\n\t\t      density(i, 0) = kde->pdf(x, y);\n\t\t    } else if(pdf == 2){\n\t\t      density(i, 0) = kde->cdf(x, y);\n\t\t    }\n\t\t  }\n\t\t} else if(density_sample_type == 2){\n\t\t  int nd = 200;\n\t\t  double x_increment = (max_x-min_x)/nd;\n\t\t  double y_increment = (max_y-min_y)/nd;\n\t\t  double x = min_x;\n\t\t  double y = min_y;\n\t\t  \n\t\t  for(int i = 0; i < nd; i++, x += x_increment){\n\t\t    y = min_y;\n\t\t    \n\t\t    for(int j = 0; j < nd; j++, y += y_increment){\n\t\t      if(pdf == 1){\n\t\t        density(i, j) = kde->pdf(x, y);\n\t\t      }else{\n\t\t        density(i, j) = kde->cdf(x, y);\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t}\n\tdelete kde;\n\n\treturn(density);\n}\n\n//' @title\n//' kde\n//' @description\n//' This subroutine calculates the 2d density for a two dimensional matrix using kernel density estimator. \n//' \n//' @param data A two dimensional matrix, data, where the first row correspondds to the sample and column corresponds to the dimensions.\n//' @param k Kernel type. 1 = Gaussian (default); 2 = Box; 3 = Epanechnikov\n//' @param b Bandwidth optimisation (Gaussian only). 1 = Default; 2 = AMISE optimal, secant method; 3 = AMISE optimal, bisection method\n//' @param pdf Calculate PDF or CDF. 1 = PDF (default); 2 = CDF.\n//' @param density_sample_type Where do you want to calculate the kde density. 1 = Original data points (default); 2 = on a pre-defined grid.  \n//' \n//' @details\n//' \\code{kde} takes a 2D matrix and uses kernel density estimator to calculate the density \n//' at location of the original data points (default) or a grid of points. For a one dimension matrix, \n//' the grid is calculated on 1001 evenly spaced points while for a two dimensional matrix, it will be \n//' calculated on 201 evenly spaced points on each dimension (201 x 201 points in total).  \n//' @return a NumericMatrix where the element is the density estimate (name: density_estimate), \n//' the second one is the weight calculated based on density_estimate. This function is based on from Tim Nugent\n//' (https://github.com/timnugent/kernel-density).  \n//' @export\n// [[Rcpp::export]]\nNumericMatrix kde(SEXP data, SEXP k, SEXP b, SEXP pdf, SEXP density_sample_type) \n{ \n  NumericMatrix data_cpp(data);\n   \n  int k_cpp = as<int>(k); \n  int b_cpp = as<int>(b); \n  int pdf_cpp = as<int>(pdf); \n  int density_sample_type_cpp = as<int>(density_sample_type); \n\n  NumericMatrix kde_res = kde_cpp(data_cpp, k_cpp, b_cpp, pdf_cpp, density_sample_type_cpp);\n  return kde_res;\n}\n\n/*** R\nlibrary(MASS)\nlibrary(Scribe)\nlung <- load_lung()\nx <- exprs(lung)[, 1]\ny <- exprs(lung)[, 2]\nx <- log(x + 1)\ny <- log(y + 1)\ndata_xy <- matrix(c(x, y), ncol = 2, byrow = T)\nres <- kde2d(x, y)\ncontour(res, xlab = \"previous duration\",\n        ylab = \"duration\", levels  =  c(0.05, 0.1, 0.2, 0.4) )\nkde_cpp_res <- kde_cpp(data_xy)\n\ndata_xy <- matrix(c(x5[, 1], z5[, 1]), ncol = 2, byrow = F)\nkde_cpp_res <- kde_cpp(as.matrix(data_xy[, ]), density_sample_type = 2) # this is very slow \nkde_res <- kde2d(data_xy[, 1], data_xy[, 2], 200)\n\ntest_data <- read.csv(\"/Users/xqiu/Dropbox (Personal)/Projects/Causal_network/causal_network/Cpp/Real_deal/Scribe/kernel-density/data/multivariate.csv\", sep = ',', header = F)\nkde_res <- kde2d(test_data[, 1], test_data[, 2], n = 200)\nkde_cpp_res <- kde_cpp(as.matrix(test_data), k = 1, b = 1, pdf = 1, density_sample_type = 2) # this is very slow \nkde_cpp_res <- kde_cpp(as.matrix(test_data), k = 1, b = 1, pdf = 1, density_sample_type = 1) # this is very slow \nt((1 / kde_cpp_res) / mean(1 / kde_cpp_res))[1:10]\n\nkde(test_data, eval.points = test_data)\nks_res <- kde(test_data, eval.points = test_data)\n1 / ks_res$estimate / (mean(1 / ks_res$estimate))\n\nkde_sci_learn <- read.csv('/Users/xqiu/Dropbox (Personal)/Projects/Causal_network/causal_network/Python_code/kde_sci_learn.csv', header = F)\n\nqplot(ks_res$estimate, kde_sci_learn) + geom_abline()\nqplot(kde_cpp_res, kde_sci_learn) + geom_abline()\nqplot(1 / ks_res$estimate / (mean(1 / ks_res$estimate)), 1 / kde_sci_learn$V1 / (mean(1 / kde_sci_learn$V1)))\n\n*/\n\n// // [[Rcpp::interfaces(r, cpp)]]\n// // [[Rcpp::export]]\n// List kde2d_mass(NumericVector x, NumericVector y, NumericVector h, IntegerVector n = 25, NumericVector lims)\n// {\n// \tint nx = x.length(); \n// \tif(y.length() != nx) \n// \t{\n// \t\tstop(\"data vectors must be the same length\");\n// \t}\n\t\n// \tfor(int test_na = 0; test_na < nx; test_na ++)\n// \t{\n// \t\tif(arma::is_finite(x[test_na]) || arma::is_finite(y[test_na])) \n// \t\t{\n// \t\t\tstop(\"Missing or infinite values in the data are not allowed\");\n// \t\t\treturn -1; \n// \t\t}\n// \t}\n\n// \tfor(int test_na = 0; test_na < lims.length(); test_na ++)\n// \t{\n// \t\tif(arma::is_finite(lims[test_na])) \n// \t\t{\n// \t\t\tstop(\"only finite values are allowed in 'lims'\"); \n// \t\t}\n// \t}\n\t\n// \tNumericVector n = rep(n, 2); // length.out 2 \n// \tIntegerVector gx = seq_len(lims[0], lims[1], n[0]);\n// \tIntegerVector gy = seq_len(lims[2], lims[3], n[1]);\n\n// \tfor(int test_na = 0; test_na < h.length(); test_na ++)\n// \t{\n// \t\tif(h[test_na] <= 0) \n// \t\t{\n// \t\t\tstop(\"Bandwidth must be strictly positive\"); \n// \t\t\treturn -1; \n// \t\t}\n\n// \t\tif(arma:is_finite(h[test_na]))\n// \t\t{\n// \t\t\th[0] = bandwidth_nrd(x);\n// \t\t\th[1] = bandwidth_nrd(y);\t\t\n// \t\t\tbreak; \n// \t\t}\n// \t}\n\n// \th = h / 4; \n\n// \tvec gx_arma = as<vec>(gx);\n// \tvec gx_arma = as<vec>(gy);\n// \tvec ax = (gx_arma - x.t()) / h[0];\n// \tvec ax = (gx_arma - x.t()) / h[1];\n\n// \tmat z_a = matrix(dnorm(ax), , nx); \n// \tmat z_b = matrix(dnorm(ay), , nx);\n\n//     mat z = z_a * trans(zb)/(nx * h[0] * h[1]); \n    \n//     // use inteperlation to predict the density at each original data point\n\n//     return List::create(Named(\"x\") = gx, Named(\"y\") = gy, Named(\"z\") = z); \n\n// }\n\n// /*** R  \n\t\n// If I understand what you want to do, it could be achieved by fitting a smoothing model to the grid density estimate and then using that to predict the density at each point you are interested in. For example:\n\n// # Simulate some data and put in data frame DF\n// n <- 100\n// x <- rnorm(n)\n// y <- 3 + 2* x * rexp(n) + rnorm(n)\n// # add some outliers\n// y[sample(1:n,20)] <- rnorm(20,20,20)\n// DF <- data.frame(x,y)\n\n// # Calculate 2d density over a grid\n// library(MASS)\n// dens <- kde2d(x,y)\n\n// # create a new data frame of that 2d density grid\n// # (needs checking that I haven't stuffed up the order here of z?)\n// gr <- data.frame(with(dens, expand.grid(x,y)), as.vector(dens$z))\n// names(gr) <- c(\"xgr\", \"ygr\", \"zgr\")\n\n// # Fit a model\n// mod <- loess(zgr~xgr*ygr, data=gr)\n\n// # Apply the model to the original data to estimate density at that point\n// DF$pointdens <- predict(mod, newdata=data.frame(xgr=x, ygr=y))\n\n// # Draw plot\n// library(ggplot2)\n// ggplot(DF, aes(x=x,y=y, color=pointdens)) + geom_point()\n// */\n\n\n\n\n\n\n",
    "created" : 1507445865514.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1087569024",
    "id" : "A52F694D",
    "lastKnownWriteTime" : 1507750556,
    "last_content_update" : 1507750556757,
    "path" : "~/Dropbox (Personal)/Projects/Causal_network/causal_network/Cpp/Real_deal/Scribe/Scribe/src/density.cpp",
    "project_path" : "src/density.cpp",
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}