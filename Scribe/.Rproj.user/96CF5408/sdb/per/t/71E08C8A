{
    "collab_server" : "",
    "contents" : "# ver 0.1; code review and documentation at Oct 2, 2017\n\n# think about better ways to deal with complex tree structure ()\n\n#' Create a pseudo-time-seires\n#'\n#' This function takes a cds (branched or not) and then convert to a pseudotime series.  \n#' @param cds A cds which has been ordered with Monocle 2\n#' @param branch_points Vector for the branch points. If it is null, there is no branching in the data \n#' @return a list storing the pseudo-time-series data and a vector storing the run id for each cell (row) in the data \n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' lung_data_list <- buildPseudoTimeSeries(lung, branch_points = 1)\n#' }\n#' @export\nbuildPseudoTimeSeries <- function(cds, branch_points = NULL) {\n  if(is.null(pData(cds)$Pseudotime))\n    stop('Please order your cell dataset with Monocle 2 before running createPTS')\n  \n  if(!is.integer(branch_points) | any(branch_points > length(cds@auxOrderingData[[cds@dim_reduce_type]]$branch_points)))\n    stop(\"Branch point should be positive integer and should not be larger than the possible number of branch points. Check branch points with plot_cell_trajectory function in Monocle\")\n    \n  if(is.null(branch_points) == FALSE) { # enable multiple branch points\n    data_tmp <- c()\n    run_vec_tmp <- c()\n    pseudotime <- c()\n    run_ind <- 0\n    \n    for(i in branch_points) {\n      tmp <- buildBranchCellDataSet(cds, progenitor_method = 'duplicate', branch_point = i)\n      sorted_tmp <- tmp[, order(pData(tmp)$Pseudotime, decreasing = T)]\n      level_vec <- unique(pData(sorted_tmp)$Branch)\n      \n      data_tmp <- rbind(data_tmp, t(exprs(sorted_tmp)))\n      Branch <- as.character(pData(sorted_tmp)$Branch)\n      Branch[Branch == level_vec[2]] <- run_ind # make sure the first run id is 0 after reversion\n      Branch[Branch == level_vec[1]] <- run_ind + 1\n      \n      run_vec_tmp <- c(run_vec_tmp, Branch)\n      pseudotime <- c(pseudotime, pData(tmp)$Pseudotime)\n      run_ind <- run_ind + 2\n    }\n    \n    # run 0, 1, ...\n    run_vec_tmp <- as.numeric(run_vec_tmp) \n    run_vec <- rev(run_vec_tmp)\n    data <- data_tmp[rev(1:ncol(data_tmp)), ]\n    \n    for(i in unique(run_vec_tmp)) {\n        cells_in_current_run <- which(run_vec_tmp == i)\n        order_cells_in_current_run_by_pseudotime <- order(pseudotime[cells_in_current_run])\n        \n        data[cells_in_current_run, ] <- data_tmp[cells_in_current_run[order_cells_in_current_run_by_pseudotime], ]\n    }\n  }\n  else { # no branching in the data \n    data <- t(exprs(cds))\n    data <- data[order(pData(cds)$Pseudotime), ] # order by pseudotime \n    run_vec <- rep(0, ncol(cds))\n  }\n  \n  return(list(data = data, run_vec = run_vec))\n}\n\n#' Calculate turning point for a linear or branched trajectory \n#'\n#' This function estimates the inflection point or the gene-wise branch point for each gene in a cell trajectory, without or with branch points respectively\n#' \n#' @param cds_subset A cds_subset object after trajectory reconstruction\n#' @param type A character determines whether or not we will return the order for the turning point or an actual value. By default, it is \"order\".  \n#' @param branch_point If the cds_subset involves a branching process, we pass this argument to determine which branch point we should use for calculating the \"turning point\"\n#' @param cores Numer of cores to run this function \n#' @return A updated cds_subset with a newly added column (turning_point) in pData indicates the inflection or branch time point.\n#' @importFrom inflection bede\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' lung_update <- estimate_turning_point(lung, type = 'value')\n#' }\n#' @export\n#' \n#' to do: write a function to integrate BGP with Monocle \nestimate_turning_point <- function(cds_subset, type = c('order', 'value'), branch_point = 1, cores = 1) {\n  cds_exprs <- pData(cds_subset)\n  cds_exprs$turning_point <- 0\n\n  # branch trajectory \n  if(length(cds_subset@auxOrderingData$DDRTree$branch_points) > 0) {\n    b_cds_subset <- buildBranchCellDataSet(cds_subset)\n    \n    ILRs <- calILRs(cds_subset, branch_point = branch_point, return_all = T, cores = cores) #you can return all important results from the data\n    branchtimepoint <- detectBifurcationPoint(ILRs$str_logfc_df, return_cross_point = T)\n  \n    if(type == 'value')  {\n      fData(cds_subset)[, 'turning_point'] <- branchtimepoint\n    } else if(type == 'order') {\n      # calculate the cell order index corresponding to the branch point (used in RDI calcultion)\n      iplasts <- unlist(lapply(branchtimepoint, function(x) {\n          branches <- unique(as.character(pData(b_cds_subset)$Branch))\n\n          # take the average of the minimal pseudotimes from the first branch and the second branch \n          a <- which.min(abs(sort(pData(b_cds_subset)[pData(b_cds_subset)$Branch == branches[1], \"Pseudotime\"]) - abs(x)))\n          b <- which.min(abs(sort(pData(b_cds_subset)[pData(b_cds_subset)$Branch == branches[2], \"Pseudotime\"]) - abs(x)))\n          \n          round(mean(c(a, b), na.rm = T))\n        }\n      )) # get the order of the cell corresponding the inflection point)\n      fData(cds_subset)[, 'turning_point'] <- iplasts\n    }\n  } else{ # linear trajectory \n    rng <- range(pData(cds_subset)$Pseudotime)\n    new_data <- data.frame(Pseudotime = seq(rng[1], rng[2], length.out = 100))\n    cds_exprs <- genSmoothCurves(cds_subset, cores = cores, trend_formula = \"~sm.ns(Pseudotime, df = 3)\",\n                    relative_expr = TRUE, new_data = new_data)\n    for(i in 1:nrow(cds_exprs)) {\n      data <- cds_exprs[i, ]; \n      inflection_point <- bede(1:length(data), data, 0)\n      if(!is.finite(inflection_point$iplast))\n        inflection_point <- bede(1:length(data), data, 1)\n    \n      # message('turning_point is ', inflection_point$iplast)\n      iplast  <- inflection_point$iplast\n      \n      if(type == 'value')  { \n        fData(cds_subset)[i, 'turning_point'] <- iplast \n      } else if(type == 'order') {\n      # get the order of the cell corresponding the inflection point \n       fData(cds_subset)[i, 'turning_point'] <- which.min(abs(sort(pData(cds_subset)$Pseudotime) - new_data$Pseudotime[iplast])) \n      }\n    }\n  }\n  \n  return(cds_subset)\n}\n\n#' Calculate uMI values\n#'\n#' This function estimates the uniformed mutual information value for all gene-pair combination from the genes_data (or that specified in the super_graph) \n#' \n#' @param cds_subset A cds_subset which has been ordered with Monocle 2\n#' @param super_graph A graph including all possible interactions used for performing the causality inference. When it is NULL, \n#' all possible pairs of interactions for the genes_data are used, otherwise only the interactions specified in the graph are used.\n#' Note that the super_graph only accept integer matrix for now (each integer corresponds to a particular gene in the genes_data).  \n#' @param log\n#' @param pseudo_cnt\n#' @param k Number for nearest neighbors used in entropy calculation.\n#' @param methodWhich 2D density estimator you would like to use. 1 is kde estimator and 2 is knn based estimator. Default to be 1. \n#' @param k_density The number of k nearest neighbors you would like to use when calculating the density (only applicable when method == 2 or using knn based density estimation).\n#' @param bw Bindwidth used for the kernel density estimator. Currently it is not used. The bindwidth in the kde function is automatically estimated. \n#' @return a numeric matrix storing a uMI result for all gene-pair combination from the genes_data (or that specified in the super_graph). \n#'\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' AT1_lung <- lung[, pData(lung)$State %in% c(2, 3)]\n#' rdi_res <- calculate_umi(AT1_lung, delays = 10, method = 1)\n#' }\n#' @export\n#' \n#' Third column is the conditional RDI value.\n#' \ncalculate_umi <- function(cds_subset, super_graph = NULL, log = TRUE, pseudo_cnt = 1, k = 5L, method = 1L, k_density = 5L, bw = 0.0) {\n  \n  if(length(unique(pData(cds_subset)$State)) > 1)\n    warning('calculate_rdi only deals with linear trajectory but Your cds seems like a branched trajectory!')\n  \n  if(log) {\n    genes_data <- log(t(exprs(cds_subset)) + pseudo_cnt) # Rows are samples while columns are features\n  }\n  else {\n    genes_data <- t(exprs(cds_subset)) # Rows are samples while columns are features\n  }\n  if(!all(is.finite(genes_data))) {\n    stop('your data includes non finite values!')\n    # finite_genes <- apply(genes_data, 2, function(x) all(is.finite(x)))\n    # genes_data <- genes_data[, finite_genes] # remove non-infinite gene \n  }\n  \n  n_genes <- ncol(genes_data); \n  n_samples <- nrow(genes_data); \n  # set.seed(2017)\n  # noise = matrix(rnorm(mean = 0, sd = 1e-10, n_genes * n_samples), nrow = n_samples)\n  \n  if(is.null(super_graph)) \n  {\n    tmp <- expand.grid(1:n_genes, 1:n_genes, stringsAsFactors = F)\n    super_graph <- tmp[tmp[, 1] != tmp[, 2], ] - 1 # convert to c++ index\n  }\n  else\n  {\n    if(class(super_graph[1, 1]) != \"character\"){\n      if(max(super_graph) >  n_genes - 1 | min(super_graph) < 0)\n      {\n        stop(\"super_graph should only include integer less than the number of cells (or only include gene names from genes_data)\")\n      }\n    }\n    else {\n      if(!(all(unlist(super_graph) %in% colnames(genes_data))))\n      {\n        stop(\"super_graph should only include integer less than the number of cells (or only include gene names from genes_data)\")\n      }\n      super_graph[, 1] <- match(super_graph[, 1], colnames(genes_data))\n      super_graph[, 2] <- match(super_graph[, 2], colnames(genes_data))\n    }\n  }\n  \n  uMI <- calculate_umi_cpp_wrap(as.matrix(genes_data), as.matrix(super_graph), k = k, method = method, k_density = k_density, bw = bw) # + noise\n  \n  # assign the name for each dimnames\n  dimnames(uMI) <- list(colnames(genes_data), colnames(genes_data)) \n  \n  return(uMI); \n}\n\n#' Calculate RDI values\n#'\n#' This function estimates the RDI value for all gene-pair combination from the genes_data (or that specified in the super_graph) \n#' in the pseudotime/time series data.\n#' \n#' @param cds_subset A cds_subset which has been ordered with Monocle 2\n#' @param delays A vector of time delays used during information transfer estimation between genes \n#' @param super_graph A graph including all possible interactions used for performing the causality inference. When it is NULL, \n#' all possible pairs of interactions for the genes_data are used, otherwise only the interactions specified in the graph are used.\n#' Note that the super_graph only accept integer matrix for now (each integer corresponds to a particular gene in the genes_data).  \n#' @param turning_points pseudo-time/time series for the gene expression data\n#' @param method a list returned from calculate_rdi function. \n#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n#' @param log\n#' @param pseudo_cnt\n#' @return a list storing a matrix for RDI results, maximal rdi values and the delays corresponding to the maximal rdi values. \n#'\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' AT1_lung <- lung[, pData(lung)$State %in% c(2, 3)]\n#' rdi_res <- calculate_rdi(AT1_lung, delays = 10, method = 1)\n#' }\n#' @export\n#' \n#' Third column is the conditional RDI value.\n#' \ncalculate_rdi <- function(cds_subset, delays, super_graph = NULL, turning_points = 0, method = 1, uniformalize = FALSE, log = TRUE, pseudo_cnt = 1) {\n\n  if(length(unique(pData(cds_subset)$State)) > 1)\n    warning('calculate_rdi only deals with linear trajectory but Your cds seems like a branched trajectory!')\n  \n  if(log) {\n    genes_data <- log(t(exprs(cds_subset)[, order(pData(cds_subset)$Pseudotime)]) + pseudo_cnt) # Rows are samples while columns are features\n  }\n  else {\n    genes_data <- t(exprs(cds_subset)[, order(pData(cds_subset)$Pseudotime)]) # Rows are samples while columns are features\n  }\n  if(!all(is.finite(genes_data))) {\n    stop('your data includes non finite values!')\n    # finite_genes <- apply(genes_data, 2, function(x) all(is.finite(x)))\n    # genes_data <- genes_data[, finite_genes] # remove non-infinite gene \n  }\n  \n  n_genes <- ncol(genes_data); \n  n_samples <- nrow(genes_data); \n  # set.seed(2017)\n  # noise = matrix(rnorm(mean = 0, sd = 1e-10, n_genes * n_samples), nrow = n_samples)\n  \n  if(is.null(super_graph)) \n  {\n    tmp <- expand.grid(1:n_genes, 1:n_genes, stringsAsFactors = F)\n    super_graph <- tmp[tmp[, 1] != tmp[, 2], ] - 1 # convert to c++ index\n  }\n  else\n  {\n    if(class(super_graph[1, 1]) != \"character\"){\n      if(max(super_graph) >  n_genes - 1 | min(super_graph) < 0)\n      {\n        stop(\"super_graph should only include integer less than the number of cells (or only include gene names from genes_data)\")\n      }\n    }\n    else {\n      if(!(all(unlist(super_graph) %in% colnames(genes_data))))\n      {\n        stop(\"super_graph should only include integer less than the number of cells (or only include gene names from genes_data)\")\n      }\n      super_graph[, 1] <- match(super_graph[, 1], colnames(genes_data))\n      super_graph[, 2] <- match(super_graph[, 2], colnames(genes_data))\n    }\n  }\n\n  RDI_list <- calculate_rdi_cpp_wrap(as.matrix(genes_data), delays, as.matrix(super_graph), turning_points, method, uniformalize) # + noise\n  \n  # assign the name for each dimnames\n  dimnames(RDI_list$RDI) <- list(colnames(genes_data), rep(colnames(genes_data), length(delays))) \n  dimnames(RDI_list$max_rdi_value) <- list(colnames(genes_data), colnames(genes_data))\n  dimnames(RDI_list$max_rdi_delays) <- list(colnames(genes_data), colnames(genes_data)) \n\n  return(RDI_list); \n}\n\n# think about passing a pseudotime ordered cds instead of a matrix \n#' Calculate conditionally RDI value\n#'\n#' This function estimates the conditional RDI value for all gene-pair combination from the genes_data (or that specified in the super_graph) \n#' in the pseudotime/time series data, conditioned on the top top_incoming_k incoming nodes. \n#' The result from the calculate_rdi function will be used to identify the proper delay for the gene-pair under test corresponds to that \n#' with highest RDI as well as the proper delays for the k incoming nodes which corresponds to that with highest RDI values.\n#' \n#' @param cds_subset A cds_subset which has been ordered with Monocle 2\n#' @param super_graph A graph including all possible interactions used for performing the causality inference. When it is NULL, \n#' all possible pairs of interactions for the genes_data are used, otherwise only the interactions specified in the graph are used.\n#' Note that the super_graph only accept integer matrix for now (each integer corresponds to a particular gene in the genes_data).  \n#' @param rdi_list a list returned from calculate_rdi function. \n#' @param top_incoming_k The number of genes to be conditioned on when calculating the conditional RDI values \n#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n#' @return a dataframe storing conditional RDI results. First two columns are the id names for the genes.\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' rdi_res <- calculate_rdi(exprs(lung)[, order(pData(lung)$Pseudotime)], delays = 5)\n#' lung_res_cRDI <- calculate_conditioned_rdi(lung, rdi_list = rdi_res)\n#' }\n#' @export\n#' \n#' Third column is the conditional RDI value.\n#' \ncalculate_conditioned_rdi <- function(cds_subset, super_graph = NULL, rdi_list, top_incoming_k = 1, uniformalize = FALSE, log = TRUE, pseudo_cnt = 1) {\n  if(length(unique(pData(cds_subset)$State)) > 1)\n    warning('calculate_rdi only deals with linear trajectory but Your cds_subset seems like a branched trajectory!')\n\n  if(log) {\n    genes_data <- log(t(exprs(cds_subset)[, order(pData(cds_subset)$Pseudotime)]) + 1) # Rows are samples while columns are features\n  } else {\n    genes_data <- t(exprs(cds_subset)[, order(pData(cds_subset)$Pseudotime)]) # Rows are samples while columns are features\n  }\n  if(!all(is.finite(genes_data))) {\n    stop('your data includes non finite values!')\n    # finite_genes <- apply(genes_data, 2, function(x) all(is.finite(x)))\n    # genes_data <- genes_data[, finite_genes] # remove non-infinite gene \n  }\n  \n  n_genes <- ncol(genes_data); \n  n_samples <- nrow(genes_data); \n  # set.seed(2017)\n  # noise = matrix(rnorm(mean = 0, sd = 1e-10, n_genes * n_samples), nrow = n_samples)\n  \n  if(is.null(super_graph)) \n  {\n    tmp <- expand.grid(1:n_genes, 1:n_genes, stringsAsFactors = F)\n    super_graph <- tmp[tmp[, 1] != tmp[, 2], ] - 1 # convert to c++ index\n  }\n  else\n  {\n    if(class(super_graph[1, 1]) != \"character\"){\n      if(max(super_graph) > nrow(genes_data) | min(super_graph) < 0)\n        stop(\"super_graph should only include gene names from genes_data\")\n    }\n    else {\n      if((! all(unique(super_graph) %in% colnames(genes_data))))\n        stop(\"super_graph should only include gene names from genes_data\")\n      \n      super_graph[, 1] <- match(super_graph[, 1], colnames(genes_data))\n      super_graph[, 2] <- match(super_graph[, 2], colnames(genes_data))\n    }\n  }\n  max_rdi_value <- rdi_list$max_rdi_value\n  max_rdi_delays <- rdi_list$max_rdi_delays\n  cRDI_mat <- calculate_conditioned_rdi_cpp_wrap(genes_data, as.matrix(super_graph), # + noise\n                                            max_rdi_value, max_rdi_delays, top_incoming_k, uniformalize)\n\n  dimnames(cRDI_mat) <- list(colnames(genes_data), colnames(genes_data))\n  \n  return(cRDI_mat); \n}\n\n####################################################################################################################################################################################\n# update this to multiple run \n####################################################################################################################################################################################\n\n#' @title\n#' calculate_rdi_multiple_run\n#' @description\n#' This subroutine estimates the RDI value for all gene-pair combination from the genes_data (or that specified in the super_graph) \n#' in the pseudotime/time series data. If multiple directly related experiments are conducted, we can pass the information of each \n#' experiment by the run_vec argument and this function will concatenate those experiments based on run_vec. \n#' \n#' @param cds_subset A cds_subset which has been ordered with Monocle 2\n#' @param run_vec A vector describes which run (lineage) does the current cell come from. It has the some length as the row length of genes_data. \n#' @param delays Time lags used to estimate the RDI values (be ready to update this as a matrix or a vector with the same length as the run_vec once we have a way to directly calculate the proper time lag need to be used)\n#' @param super_graph A graph including all possible interactions used for performing the causality inference. When it is NULL, \n#' all possible pairs of interactions for the genes_data are used, otherwise only the interactions specified in the graph are used.\n#' Note that the super_graph only accept integer matrix for now (each integer corresponds to a particular gene in the genes_data).  \n#' @param method either 1, 2 represents either using (RDI: restricted direction information) or LMI (lagged mutual information) \n#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n#'\n#' @details\n#' \\code{calculate_rdi_multiple_run} takes a time / Pseudo-time series expression data as well as the time lags and then calculate the restricted direct information between each pair of genes under different delays. \n#' @return a list with four components: matrix for RDI (dimension is number of genes X length of delays times number of genes), vector of delays, max_rdi_value and max_rdi_delays \n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' lung_dup <- buildBranchCellDataSet(lung)\n#' run_vec <- pData(lung_dup)$Branch\n#' Branch_uniq <- unique(run_vec)\n#' run_vec[run_vec == Branch_uniq[1]] <- 0\n#' run_vec[run_vec == Branch_uniq[2]] <- 1\n#' lung_res <- calculate_rdi_multiple_run(lung, run_vec = run_vec)\n#' }\n#' @export\n#' \ncalculate_rdi_multiple_run <- function(cds_subset, run_vec = NULL, delays, super_graph = NULL, method = 1, uniformalize = FALSE, log = TRUE, pseudo_cnt = 1) {\n\n  if(log) {\n    genes_data <- log(t(exprs(cds_subset)[, order(pData(cds_subset)$Pseudotime)]) + 1) # Rows are samples while columns are features\n  }\n  \n  if(!all(is.finite(genes_data))) {\n    stop('your data includes non finite values!')\n    # finite_genes <- apply(genes_data, 2, function(x) all(is.finite(x)))\n    # genes_data <- genes_data[, finite_genes] # remove non-infinite gene \n  }\n  \n  if(is.null(run_vec)) {\n    run_vec <- rep(0, nrow(genes_data)) \n  } else {\n    run_vec <- run_vec[order(pData(cds_subset)$Pseudotime)]\n  }\n\n  if(min(run_vec) != 0 | any(diff(unique(run_vec)) != 1) | !is.vector(run_vec))\n    stop(\"The run_vec starts from 0 to the total number of runs\")\n  \n  n_genes <- ncol(genes_data); \n  n_samples <- nrow(genes_data); \n  # set.seed(2017)\n  # noise = matrix(rnorm(mean = 0, sd = 1e-10, n_genes * n_samples), nrow = n_samples)\n  \n  if(is.null(super_graph)) \n  {\n    tmp <- expand.grid(1:n_genes, 1:n_genes, stringsAsFactors = F)\n    super_graph <- tmp[tmp[, 1] != tmp[, 2], ] - 1 # convert to c++ index\n  }\n  else\n  {\n    if(class(super_graph[1, 1]) != \"character\"){\n      if(max(super_graph) >  n_samples - 1 | min(super_graph) < 0)\n      {\n        stop(\"super_graph should only include integer less than the number of cells (or only include gene names from genes_data)\")\n      }\n    }\n    else {\n      if(!(all(unlist(super_graph) %in% colnames(genes_data))))\n      {\n        stop(\"super_graph should only include integer less than the number of cells (or only include gene names from genes_data)\")\n      }\n      super_graph[, 1] <- match(super_graph[, 1], colnames(genes_data))\n      super_graph[, 2] <- match(super_graph[, 2], colnames(genes_data))\n    }\n  }\n  \n  RDI_list <- calculate_rdi_multiple_run_cpp_wrap(as.matrix(genes_data), delays, run_vec, as.matrix(super_graph), turning_points = 0, method, uniformalize) \n  \n  # assign the name for each dimnames\n  dimnames(RDI_list$RDI) <- list(colnames(genes_data), rep(colnames(genes_data), length(delays))) \n  dimnames(RDI_list$max_rdi_value) <- list(colnames(genes_data), colnames(genes_data))\n  dimnames(RDI_list$max_rdi_delays) <- list(colnames(genes_data), colnames(genes_data)) \n  \n  return(RDI_list); \n}\n\n\n#' Calculate conditionally RDI value for multiple runs (replicates) of experiments \n#'\n#' This function estimates the RDI value for all gene-pair combination from the genes_data (or that specified in the super_graph) \n#' in the pseudotime/time series data, conditioned on the top top_incoming_k incoming nodes. If multiple directly related experiments \n#' are conducted, we can pass the information of each experiment by the run_vec argument and this function will concatenate those experiments\n#' based on run_vec. \n#' \n#' @param cds_subset A cds_subset which has been ordered with Monocle 2\n#' @param run_vec A vector describes which run (lineage) does the current cell come from. It has the some length as the row length of genes_data. \n#' @param super_graph A graph including all possible interactions used for performing the causality inference. When it is NULL, \n#' all possible pairs of interactions for the genes_data are used, otherwise only the interactions specified in the graph are used.\n#' Note that the super_graph only accept integer matrix for now (each integer corresponds to a particular gene in the genes_data).  \n#' @param rdi_list a list returned from calculate_rdi function. \n#' @param top_incoming_k The number of genes to be conditioned on when calculating the conditional RDI values \n#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n#' @return a dataframe storing conditional RDI results. First two columns are the id names for the genes.\n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' lung_dup <- buildBranchCellDataSet(lung)\n#' run_vec <- pData(lung_dup)$Branch\n#' Branch_uniq <- unique(run_vec)\n#' run_vec[run_vec == Branch_uniq[1]] <- 0\n#' run_vec[run_vec == Branch_uniq[2]] <- 1\n#' lung_res <- calculate_rdi_multiple_run(lung, run_vec = run_vec)\n#' lung_res_cRDI <- calculate_rdi_multiple_run(lung, run_vec = run_vec, rdi_list = lung_res)\n#' }\n#' @export\n#' Third column is the conditional RDI value.\n#' \ncalculate_conditioned_rdi_multiple_run <- function(cds_subset, run_vec = NULL, super_graph = NULL, rdi_list, top_incoming_k = 1, uniformalize = FALSE, log = TRUE, pseudo_cnt = 1) {\n\n  genes_data <- log(t(exprs(cds_subset)[, order(pData(cds_subset)$Pseudotime)]) + 1) # Rows are samples while columns are features\n\n  if(!all(is.finite(genes_data))) {\n    stop('your data includes non finite values!')\n    # finite_genes <- apply(genes_data, 2, function(x) all(is.finite(x)))\n    # genes_data <- genes_data[, finite_genes] # remove non-infinite gene \n  }\n  \n  if(is.null(run_vec)) {\n    run_vec <- rep(0, nrow(genes_data)) \n  } else {\n    run_vec <- run_vec[order(pData(cds_subset)$Pseudotime)]\n  }\n\n  if(min(run_vec) != 0 | any(diff(unique(run_vec)) != 1) | !is.vector(run_vec))\n    stop(\"The run_vec starts from 0 to the total number of runs\")\n  \n  n_genes <- ncol(genes_data); \n  n_samples <- nrow(genes_data); \n  # set.seed(2017)\n  # noise = matrix(rnorm(mean = 0, sd = 1e-10, n_genes * n_samples), nrow = n_samples)\n  \n  if(is.null(super_graph)) \n  {\n    tmp <- expand.grid(1:n_genes, 1:n_genes, stringsAsFactors = F)\n    super_graph <- tmp[tmp[, 1] != tmp[, 2], ] - 1 # convert to c++ index\n  }\n  else\n  {\n    if(class(super_graph[1, 1]) != \"character\"){\n      if(max(super_graph) > nrow(genes_data) | min(super_graph) < 0)\n        stop(\"super_graph should only include gene names from genes_data\")\n    }\n    else {\n      if((! all(unique(super_graph) %in% colnames(genes_data))))\n        stop(\"super_graph should only include gene names from genes_data\")\n      \n      super_graph[, 1] <- match(super_graph[, 1], colnames(genes_data))\n      super_graph[, 2] <- match(super_graph[, 2], colnames(genes_data))\n    }\n  }\n  max_rdi_value <- rdi_list$max_rdi_value\n  max_rdi_delays <- rdi_list$max_rdi_delays\n  cRDI_mat <- calculate_conditioned_rdi_multiple_run_wrap(genes_data, as.matrix(super_graph), \n                                                 max_rdi_value, max_rdi_delays, run_vec, top_incoming_k, uniformalize) # + noise\n  \n  dimnames(cRDI_mat) <- list(colnames(genes_data), colnames(genes_data))\n  \n  return(cRDI_mat); \n}\n\n#' Calculate temporal RDI or conditional RDI (cRDI) values. \n#' \n#' This function is developed to calculate the temporal RDI or cRDI which can reveal the time point where the regulator will affect the target gene.  \n#' \n#' @param cds_subset A cds_subset which has been ordered with Monocle 2. Currently it only deals with a linear trajectory. \n#' @param super_graph A matrix for the valid gene-pairs we will consider for inferring the temporal RDI or cRDI. \n#' @param window_size The window size we will use for calculating the temporal RDI. \n#' @param delay The time delay used in calculating the RDI or cRDI values.\n#' @param smoothing A logic argument to determine whether or not we will first apply loess smoothing before we calculate the temporal RDI. Default to be TRUE. \n#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n#' @param verbose A logical argument to determine whether or not we will print the detailed running information. \n#' @return A list of two arrays where the first one is the temporal RDI value and second one is the conditional RDI values. In each array, the first \n#' dimension corresponds to the sliding window, the second and third dimensions correspond to the genes.  \n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' plot_cell_trajectory(lung)\n#' plot_cell_trajectory(lung, color_by = 'Time')\n#' lung_AT1_lineage <- lung[, pData(lung)$State %in% c(1, 3)]\n#' temp_causality_list <- calculate_temporal_causality(lung_AT1_lineage)\n#' }\n#' @export\n#' \ncalculate_temporal_causality <- function(cds_subset, super_graph = NULL, window_size = 40, delay = 1, smoothing = TRUE, uniformalize = FALSE, log = TRUE, pseudo_cnt = 1, verbose = FALSE) {\n  data <- log(t(exprs(cds_subset[, order(pData(cds_subset)$Pseudotime)])) + 1)\n  \n  if(smoothing) {\n    for(i in 1:ncol(data)) {\n      df <- data.frame(Pseudotime = 1:nrow(data), Expression = data[, i])\n      test <- loess(Expression ~ Pseudotime, df)\n      data[, i] <-  predict(test)\n    }\n  }\n  \n  win_range <- nrow(data) - window_size - 1\n  gene_num <- ncol(data)\n  \n  window_gene_gene_result <- array(dim = c(win_range + 1, gene_num, gene_num)) \n  crdi_window_gene_gene_result <- window_gene_gene_result \n  \n  run_vec <- rep(1, nrow(data))\n  \n  if(is.null(super_graph)) {\n    tmp <- expand.grid(1:ncol(data), 1:ncol(data), stringsAsFactors = F)\n    super_graph <- tmp[tmp[, 1] != tmp[, 2], ] - 1 # convert to C++ index\n  }\n\n  for(i in 1:(win_range + 1)) {\n    if(verbose)\n     message('current window index is ', i)\n    \n    rdi_list <- calculate_rdi_multiple_run_cpp(expr_data = data[i:(i + window_size), ], delay = delay, run_vec = run_vec[i:(i + window_size)] - 1, \n                                               super_graph = as.matrix(super_graph), turning_points = 0, method = 1, uniformalize) #* 100 + noise\n    con_rdi_res_test <- calculate_conditioned_rdi_multiple_run_wrap(data[i:(i + window_size), ], as.matrix(super_graph), as.matrix(rdi_list$max_rdi_value), \n                                                                    as.matrix(rdi_list$max_rdi_delays), run_vec[i:(i + window_size)] - 1, 1, uniformalize)\n    \n    window_gene_gene_result[i, , ] <- rdi_list$max_rdi_value\n    crdi_window_gene_gene_result[i, , ] <- con_rdi_res_test\n    \n  }\n  \n  return(list(rdi_res = window_gene_gene_result, crdi_res = crdi_window_gene_gene_result))\n}\n\n#' Calculate temporal RDI or conditional RDI (cRDI) values. \n#' \n#' This function is developed to calculate the temporal RDI or cRDI which can reveal the time point where the regulator will affect the target gene.  \n#' \n#' @param cds A cds which contains the genes from the TFs and informative_genes vectors in the gene_short_name column of the cds's pData. \n#' @param TFs A vector for the gene short name of the TFs, default to be NULL (All genes in the cds will be used). \n#' @param informative_genes A vector for the gene short name of the informative genes, default to be NULL (All genes in the cds will be used). \n#' @return A character matrix where the first column corresponds to the regulators and the second column corresponds to the targets.  \n#' @examples\n#' \\dontrun{\n#' lung <- load_lung() \n#' super_graph <- create_super_graph(lung)\n#' }\n#' @export\ncreate_super_graph <- function(cds, TFs = NULL, informative_genes = NULL) {\n  if(is.null(TFs) & is.null(informative_genes)) {\n    tmp <- expand.grid(row.names(cds), row.names(cds), stringsAsFactors = F)\n    super_graph <- tmp[tmp[, 1] != tmp[, 2], ]\n  } else {\n    # convert the genes into character vectors \n    TFs <- as.character(TFs)\n    informative_genes <- as.character(informative_genes)\n    \n    if(!all(c(TFs, informative_genes) %in% fData(cds)$gene_short_name)) {\n      stop('Not all your TFs and informative_genes are included in the gene_short_name column of the fData.')\n    } else if (length(intersect(TFs, informative_genes)) < 1) {\n      stop('There should be at least one TFs gene is included in the vector informative_gene')\n      } else {\n      cds <- cds[row.names(subset(fData(cds), gene_short_name %in% c(TFs, informative_genes))), ]\n    }\n    \n    # obtain the gene ensemble IDs: \n    TFs <- row.names(subset(fData(cds), gene_short_name %in% TFs))\n    informative_genes <- row.names(subset(fData(cds), gene_short_name %in% informative_genes))\n    \n    TF_vec_names <- intersect(TFs, informative_genes)\n    target_vec_names <- setdiff(informative_genes, TFs)\n    \n    TF_pair <- expand.grid(TF_vec_names, TF_vec_names, stringsAsFactors = F) # between TFs \n    TF_target_pair <- expand.grid(TF_vec_names, target_vec_names, stringsAsFactors = F) # from TFs to the targets \n    \n    super_graph <- rbind(TF_pair, TF_target_pair)\n  }\n  \n  return(super_graph)\n}\n\n# this following function used to re-order the trajectory using principal curve \nreduceDimension <- function(cds,\n                            max_components=2,\n                            reduction_method=c(\"DDRTree\", \"ICA\", 'tSNE', \"SimplePPT\", 'L1-graph', 'SGL-tree', \"Principal.curve\"),\n                            norm_method = c(\"log\", \"vstExprs\", \"none\"),\n                            residualModelFormulaStr=NULL,\n                            pseudo_expr=NULL,\n                            relative_expr=TRUE,\n                            auto_param_selection = TRUE,\n                            verbose=FALSE,\n                            scaling = TRUE,\n                            ...){\n  extra_arguments <- list(...)\n  set.seed(2016) #ensure results from RNG sensitive algorithms are the same on all calls\n  \n  FM <- monocle:::normalize_expr_data(cds, norm_method, pseudo_expr)\n  \n  #FM <- FM[unlist(sparseApply(FM, 1, sd, convert_to_dense=TRUE)) > 0, ]\n  xm <- Matrix::rowMeans(FM)\n  xsd <- sqrt(Matrix::rowMeans((FM - xm)^2))\n  FM <- FM[xsd > 0,]\n  \n  if (is.null(residualModelFormulaStr) == FALSE) {\n    if (verbose)\n      message(\"Removing batch effects\")\n    X.model_mat <- sparse.model.matrix(as.formula(residualModelFormulaStr),\n                                       data = pData(cds), drop.unused.levels = TRUE)\n    \n    fit <- limma::lmFit(FM, X.model_mat, ...)\n    beta <- fit$coefficients[, -1, drop = FALSE]\n    beta[is.na(beta)] <- 0\n    FM <- as.matrix(FM) - beta %*% t(X.model_mat[, -1])\n  }else{\n    X.model_mat <- NULL\n  }\n  \n  if(scaling){\n    FM <- as.matrix(Matrix::t(scale(Matrix::t(FM))))\n    FM <- FM[!is.na(row.names(FM)), ]\n  } else FM <- as.matrix(FM)\n  \n  if (nrow(FM) == 0) {\n    stop(\"Error: all rows have standard deviation zero\")\n  }\n  \n  FM <- FM[apply(FM, 1, function(x) all(is.finite(x))), ] #ensure all the expression values are finite values\n  if (is.function(reduction_method)) {\n    reducedDim <- reduction_method(FM, ...)\n    colnames(reducedDim) <- colnames(FM)\n    monocle:::reducedDimW(cds) <- as.matrix(reducedDim)\n    monocle:::reducedDimA(cds) <- as.matrix(reducedDim)\n    monocle:::reducedDimS(cds) <- as.matrix(reducedDim)\n    monocle:::reducedDimK(cds) <- as.matrix(reducedDim)\n    dp <- as.matrix(dist(reducedDim))\n    cellPairwiseDistances(cds) <- dp\n    gp <- graph.adjacency(dp, mode = \"undirected\", weighted = TRUE)\n    dp_mst <- minimum.spanning.tree(gp)\n    minSpanningTree(cds) <- dp_mst\n    cds@dim_reduce_type <- \"function_passed\"\n  }\n  else{\n    reduction_method <- match.arg(reduction_method)\n    if (reduction_method == \"tSNE\") {\n      #first perform PCA\n      if (verbose)\n        message(\"Remove noise by PCA ...\")\n      \n      # # Calculate the variance across genes without converting to a dense\n      # # matrix:\n      # FM_t <- Matrix::t(FM)\n      # cell_means <- Matrix::rowMeans(FM_t)\n      # cell_vars <- Matrix::rowMeans((FM_t - cell_means)^2)\n      # Filter out genes that are constant across all cells:\n      #genes_to_keep <- expression_vars > 0\n      #FM <- FM[genes_to_keep,]\n      #expression_means <- expression_means[genes_to_keep]\n      #expression_vars <- expression_vars[genes_to_keep]\n      # Here✬s how to take the top PCA loading genes, but using\n      # sparseMatrix operations the whole time, using irlba.\n      \n      \n      if(\"num_dim\" %in% names(extra_arguments)){ #when you pass pca_dim to the function, the number of dimension used for tSNE dimension reduction is used\n        num_dim <- extra_arguments$num_dim #variance_explained\n      }\n      else{\n        num_dim <- 50\n      }\n      \n      irlba_res <- prcomp_irlba(t(FM), n = min(num_dim, min(dim(FM)) - 1),\n                                center = TRUE, scale. = TRUE)\n      irlba_pca_res <- irlba_res$x\n      \n      # irlba_res <- irlba(FM,\n      #                    nv=min(num_dim, min(dim(FM)) - 1),\n      #                        nu=0,\n      #                        center=cell_means,\n      #                        scale=sqrt(cell_vars),\n      #                        right_only=TRUE)\n      # irlba_pca_res <- irlba_res$v\n      # row.names(irlba_pca_res) <- genes_to_keep\n      \n      # pca_res <- prcomp(t(FM), center = T, scale = T)\n      # std_dev <- pca_res$sdev\n      # pr_var <- std_dev^2\n      # prop_varex <- pr_var/sum(pr_var)\n      # prop_varex <- irlba_res$sdev^2 / sum(irlba_res$sdev^2)\n      \n      topDim_pca <- irlba_pca_res#[, 1:num_dim]\n      \n      # #perform the model formula transformation right before tSNE:\n      # if (is.null(residualModelFormulaStr) == FALSE) {\n      #   if (verbose)\n      #     message(\"Removing batch effects\")\n      #   X.model_mat <- sparse.model.matrix(as.formula(residualModelFormulaStr),\n      #                                      data = pData(cds), drop.unused.levels = TRUE)\n      \n      #   fit <- limma::lmFit(topDim_pca, X.model_mat, ...)\n      #   beta <- fit$coefficients[, -1, drop = FALSE]\n      #   beta[is.na(beta)] <- 0\n      #   topDim_pca <- as.matrix(FM) - beta %*% t(X.model_mat[, -1])\n      # }else{\n      #   X.model_mat <- NULL\n      # }\n      \n      #then run tSNE\n      if (verbose)\n        message(\"Reduce dimension by tSNE ...\")\n      \n      tsne_res <- Rtsne::Rtsne(as.matrix(topDim_pca), dims = max_components, pca = F,...)\n      \n      tsne_data <- tsne_res$Y[, 1:max_components]\n      row.names(tsne_data) <- colnames(tsne_data)\n      \n      reducedDimA(cds) <- t(tsne_data) #this may move to the auxClusteringData environment\n      \n      #set the important information from densityClust to certain part of the cds object:\n      cds@auxClusteringData[[\"tSNE\"]]$pca_components_used <- num_dim\n      cds@auxClusteringData[[\"tSNE\"]]$reduced_dimension <- t(tsne_data)\n      #cds@auxClusteringData[[\"tSNE\"]]$variance_explained <- prop_varex\n      \n      cds@dim_reduce_type <- \"tSNE\"\n    }\n    \n    else if (reduction_method == \"ICA\") {\n      # FM <- as.matrix(Matrix::t(scale(Matrix::t(FM))))\n      # FM <- FM[!is.na(row.names(FM)), ]\n      \n      if (verbose)\n        message(\"Reducing to independent components\")\n      init_ICA <- ica_helper(Matrix::t(FM), max_components,\n                             use_irlba = TRUE, ...)\n      x_pca <- Matrix::t(Matrix::t(FM) %*% init_ICA$K)\n      W <- Matrix::t(init_ICA$W)\n      weights <- W\n      A <- Matrix::t(solve(weights) %*% Matrix::t(init_ICA$K))\n      colnames(A) <- colnames(weights)\n      rownames(A) <- rownames(FM)\n      S <- weights %*% x_pca\n      rownames(S) <- colnames(weights)\n      colnames(S) <- colnames(FM)\n      monocle:::reducedDimW(cds) <- as.matrix(W)\n      monocle:::reducedDimA(cds) <- as.matrix(A)\n      monocle:::reducedDimS(cds) <- as.matrix(S)\n      monocle:::reducedDimK(cds) <- as.matrix(init_ICA$K)\n      adjusted_S <- Matrix::t(reducedDimS(cds))\n      dp <- as.matrix(dist(adjusted_S))\n      cellPairwiseDistances(cds) <- dp\n      gp <- graph.adjacency(dp, mode = \"undirected\", weighted = TRUE)\n      dp_mst <- minimum.spanning.tree(gp)\n      minSpanningTree(cds) <- dp_mst\n      cds@dim_reduce_type <- \"ICA\"\n    }\n    else if (reduction_method == \"DDRTree\") {\n      # FM <- as.matrix(Matrix::t(scale(Matrix::t(FM))))\n      # FM <- FM[!is.na(row.names(FM)), ]\n      \n      if (verbose)\n        message(\"Learning principal graph with DDRTree\")\n      \n      # TODO: DDRTree should really work with sparse matrices.\n      if(auto_param_selection & ncol(cds) >= 100){\n        if(\"ncenter\" %in% names(extra_arguments)) #avoid overwrite the ncenter parameter\n          ncenter <- extra_arguments$ncenter\n        else\n          ncenter <- cal_ncenter(ncol(FM))\n        #add other parameters...\n        ddr_args <- c(list(X=FM, dimensions=max_components, ncenter=ncenter, verbose = verbose),\n                      extra_arguments[names(extra_arguments) %in% c(\"initial_method\", \"maxIter\", \"sigma\", \"lambda\", \"param.gamma\", \"tol\")])\n        #browser()\n        ddrtree_res <- do.call(DDRTree, ddr_args)\n      } else{\n        ddrtree_res <- DDRTree(FM, max_components, verbose = verbose, ...)\n      }\n      if(ncol(ddrtree_res$Y) == ncol(cds))\n        colnames(ddrtree_res$Y) <- colnames(FM) #paste(\"Y_\", 1:ncol(ddrtree_res$Y), sep = \"\")\n      else\n        colnames(ddrtree_res$Y) <- paste(\"Y_\", 1:ncol(ddrtree_res$Y), sep = \"\")\n      \n      colnames(ddrtree_res$Z) <- colnames(FM)\n      monocle:::reducedDimW(cds) <- ddrtree_res$W\n      monocle:::reducedDimS(cds) <- ddrtree_res$Z\n      monocle:::reducedDimK(cds) <- ddrtree_res$Y\n      cds@auxOrderingData[[\"DDRTree\"]]$objective_vals <- ddrtree_res$objective_vals\n      \n      adjusted_K <- Matrix::t(reducedDimK(cds))\n      dp <- as.matrix(dist(adjusted_K))\n      cellPairwiseDistances(cds) <- dp\n      gp <- graph.adjacency(dp, mode = \"undirected\", weighted = TRUE)\n      dp_mst <- minimum.spanning.tree(gp)\n      minSpanningTree(cds) <- dp_mst\n      cds@dim_reduce_type <- \"DDRTree\"\n      cds <- monocle:::findNearestPointOnMST(cds)\n    }\n    else if(reduction_method == \"Principal.curve\") {\n      dm <- destiny::DiffusionMap(t(FM))\n      \n      if (verbose)\n        message(\"Learning principal graph with Principal.curve\")\n      \n      diam_pc_tmp <- princurve::principal.curve(dm@eigenvectors[, 1:max_components]) \n      diam_pc <- as.data.frame(diam_pc_tmp$s)\n      \n      # FM <- as.matrix(Matrix::t(scale(Matrix::t(FM))))\n      # FM <- FM[!is.na(row.names(FM)), ]\n      \n      # colnames(ddrtree_res$Y) <- colnames(FM) #paste(\"Y_\", 1:ncol(ddrtree_res$Y), sep = \"\")\n      \n      monocle:::reducedDimW(cds) <- dm@eigenvectors[, 1:2]\n      diam_pc <- t(diam_pc)\n      colnames(diam_pc) <- colnames(cds)\n      \n      monocle:::reducedDimS(cds) <- diam_pc\n      monocle:::reducedDimK(cds) <- diam_pc\n      cds@auxOrderingData[[\"DDRTree\"]]$pc_res <- diam_pc\n      \n      adjusted_K <- Matrix::t(reducedDimK(cds))\n      dp <- as.matrix(dist(adjusted_K))\n      cellPairwiseDistances(cds) <- dp\n      gp <- graph.adjacency(dp, mode = \"undirected\", weighted = TRUE)\n      dp_mst <- minimum.spanning.tree(gp)\n      minSpanningTree(cds) <- dp_mst\n      cds@dim_reduce_type <- \"DDRTree\"\n      cds <- monocle:::findNearestPointOnMST(cds)\n    }   \n    else if(reduction_method == \"SimplePPT\") {\n      if(\"initial_method\" %in% names(extra_arguments)){ #need to check whether or not the output match what we want\n        tryCatch({\n          reduced_dim_res <- extra_arguments$initial_method(FM) #variance_explained\n          reduced_dim_res\n        }, error = function(e) {\n          error('Your initial method throws numerical errors!')\n        })\n      }\n      else{\n        if(verbose)\n          message('running PCA (no further scaling or center) ...')\n        \n        dm <- destiny::DiffusionMap(t(FM))\n        reduced_dim_res <- dm@eigenvectors[, 1:max_components] \n      }\n      if(dim(reduced_dim_res)[1] != ncol(FM) & dim(reduced_dim_res)[2] < max_components )\n        error(\"Your initial method don't generate result match the required dimension nrow(FM) * > max_components\")\n      \n      if(verbose)\n        message('running SimplePPT ...')\n      \n      simplePPT_args <- c(list(X=t(reduced_dim_res[, 1:max_components]), verbose = verbose),\n                          extra_arguments[names(extra_arguments) %in% c(\"lambda\", \"bandwidth\", \"maxIter\")])\n      #browser()\n      simplePPT_res <- do.call(simplePPT::principal_tree, simplePPT_args)\n      \n      colnames(simplePPT_res$MU) <- colnames(FM) #paste(\"Y_\", 1:ncol(ddrtree_res$Y), sep = \"\")\n      DCs <- t(reduced_dim_res[, 1:max_components])\n      colnames(DCs) <- colnames(FM) #paste(\"Y_\", 1:ncol(ddrtree_res$Y), sep = \"\")\n      \n      monocle:::reducedDimW(cds) <- DCs\n      monocle:::reducedDimS(cds) <- simplePPT_res$MU\n      monocle:::reducedDimK(cds) <- simplePPT_res$MU\n      cds@auxOrderingData[[\"DDRTree\"]]$objective_vals <- tail(simplePPT_res$history$objs, 1)\n      \n      adjusted_K <- Matrix::t(reducedDimK(cds))\n      dp <- as.matrix(dist(adjusted_K))\n      cellPairwiseDistances(cds) <- dp\n      gp <- graph.adjacency(dp, mode = \"undirected\", weighted = TRUE)\n      dp_mst <- minimum.spanning.tree(gp)\n      minSpanningTree(cds) <- dp_mst\n      cds@dim_reduce_type <- \"DDRTree\"\n      cds <- monocle:::findNearestPointOnMST(cds)\n    }\n    else if(reduction_method == \"L1-graph\") {\n      if(\"initial_method\" %in% names(extra_arguments)){ #need to check whether or not the output match what we want\n        tryCatch({\n          reduced_dim_res <- extra_arguments$initial_method(FM) #variance_explained\n          reduced_dim_res\n        }, error = function(e) {\n          error('Your initial method throws numerical errors!')\n        })\n      }\n      else{\n        if(verbose)\n          message('running PCA (no further scaling or center) ...')\n        dm <- destiny::DiffusionMap(t(FM))\n        reduced_dim_res <- dm@eigenvectors[, 1:max_components] \n      }\n      if(dim(reduced_dim_res)[1] != ncol(FM) & dim(reduced_dim_res)[2] < max_components )\n        error(\"Your initial method don't generate result match the required dimension nrow(FM) * > max_components\")\n      \n      if(verbose)\n        message('running L1-graph ...')\n      \n      X <- t(reduced_dim_res[, 1:max_components])\n      # D <- nrow(X); N <- ncol(X)\n      # Z <- X\n      \n      if('C0' %in% names(extra_arguments)){\n        C0 <- extra_arguments$C0\n      }\n      else\n        C0 <- X\n      Nz <- ncol(C0)\n      \n      # print(extra_arguments)\n      if('nn' %in% names(extra_arguments))\n        G <- get_knn(C0, K = extra_arguments$nn)\n      else\n        G <- get_knn(C0, K = 5)\n      \n      l1graph_args <- c(list(X = t(reduced_dim_res[, 1:max_components]), C0 = C0, G = G$G, gstruct = 'l1-graph', verbose = verbose),\n                        extra_arguments[names(extra_arguments) %in% c('maxiter', 'eps', 'lambda', 'gamma', 'sigma', 'nn')])\n      \n      l1_graph_res <- do.call(principal_graph, l1graph_args)\n      \n      colnames(l1_graph_res$C) <- colnames(FM)[1:ncol(l1_graph_res$C)] #paste(\"Y_\", 1:ncol(ddrtree_res$Y), sep = \"\")\n      DCs <- t(reduced_dim_res[, 1:max_components])\n      colnames(DCs) <- colnames(FM) #paste(\"Y_\", 1:ncol(ddrtree_res$Y), sep = \"\")\n      \n      colnames(l1_graph_res$W) <- colnames(FM)[1:ncol(l1_graph_res$C)] #paste(\"Y_\", 1:ncol(ddrtree_res$Y), sep = \"\")\n      rownames(l1_graph_res$W) <- colnames(FM)[1:ncol(l1_graph_res$C)] #paste(\"Y_\", 1:ncol(ddrtree_res$Y), sep = \"\")\n      \n      \n      # row.names(l1_graph_res$X) <- colnames(cds)\n      monocle:::reducedDimW(cds) <- l1_graph_res$W\n      monocle:::reducedDimS(cds) <- DCs\n      monocle:::reducedDimK(cds) <- l1_graph_res$C\n      cds@auxOrderingData[[\"DDRTree\"]]$objective_vals <- tail(l1_graph_res$objs, 1)\n      cds@auxOrderingData[[\"DDRTree\"]]$W <- l1_graph_res$W\n      cds@auxOrderingData[[\"DDRTree\"]]$P <- l1_graph_res$P\n      \n      adjusted_K <- Matrix::t(reducedDimK(cds))\n      dp <- as.matrix(dist(adjusted_K))\n      cellPairwiseDistances(cds) <- dp\n      \n      W <- l1_graph_res$W\n      dimnames(l1_graph_res$W) <- list(paste('cell_', 1:nrow(W), sep = ''), paste('cell_', 1:nrow(W), sep = ''))\n      W[W < 1e-5] <- 0\n      gp <- graph.adjacency(W, mode = \"undirected\", weighted = TRUE)\n      # dp_mst <- minimum.spanning.tree(gp)\n      minSpanningTree(cds) <- gp\n      cds@dim_reduce_type <- \"DDRTree\"\n      cds <- monocle:::findNearestPointOnMST(cds)\n    }\n    else if(reduction_method == \"SGL-tree\") {\n      if(\"initial_method\" %in% names(extra_arguments)){ #need to check whether or not the output match what we want\n        tryCatch({\n          reduced_dim_res <- extra_arguments$initial_method(FM) #variance_explained\n          reduced_dim_res\n        }, error = function(e) {\n          error('Your initial method throws numerical errors!')\n        })\n      }\n      else{\n        if(verbose)\n          message('running PCA (no further scaling or center) ...')\n        dm <- destiny::DiffusionMap(t(FM))\n        reduced_dim_res <- dm@eigenvectors[, 1:max_components] \n      }\n      if(dim(reduced_dim_res)[1] != ncol(FM) & dim(reduced_dim_res)[2] < max_components )\n        error(\"Your initial method don't generate result match the required dimension nrow(FM) * > max_components\")\n      \n      if(verbose)\n        message('running SGL-tree ...')\n      \n      X <- t(reduced_dim_res[, 1:max_components])\n      D <- nrow(X); N <- ncol(X)\n      Z <- X\n      C0 <- Z\n      Nz <- ncol(C0)\n      \n      if('K' %in% names(extra_arguments))\n        G <- get_knn(C0, K = extra_arguments$K)\n      else\n        G <- get_knn(C0, K = 5)\n      \n      l1graph_args <- c(list(X = t(reduced_dim_res[, 1:max_components]), C0 = C0, G = G$G, gstruct = 'span-tree', verbose = verbose),\n                        extra_arguments[names(extra_arguments) %in% c('maxiter', 'eps', 'lambda', 'gamma', 'sigma', 'nn')])\n      \n      l1_graph_res <- do.call(principal_graph, l1graph_args)\n      \n      colnames(l1_graph_res$C) <- colnames(FM) #paste(\"Y_\", 1:ncol(ddrtree_res$Y), sep = \"\")\n      DCs <- t(reduced_dim_res[, 1:max_components])\n      colnames(DCs) <- colnames(FM) #paste(\"Y_\", 1:ncol(ddrtree_res$Y), sep = \"\")\n      \n      monocle:::reducedDimW(cds) <- DCs\n      monocle:::reducedDimS(cds) <- DCs #1_graph_res$X\n      monocle:::reducedDimK(cds) <- l1_graph_res$C\n      cds@auxOrderingData[[\"DDRTree\"]]$objective_vals <- tail(l1_graph_res$objs, 1)\n      cds@auxOrderingData[[\"DDRTree\"]]$W <- l1_graph_res$W\n      cds@auxOrderingData[[\"DDRTree\"]]$P <- l1_graph_res$P\n      \n      adjusted_K <- Matrix::t(reducedDimK(cds))\n      dp <- as.matrix(dist(adjusted_K))\n      cellPairwiseDistances(cds) <- dp\n      gp <- graph.adjacency(dp, mode = \"undirected\", weighted = TRUE)\n      dp_mst <- minimum.spanning.tree(gp)\n      minSpanningTree(cds) <- dp_mst\n      cds@dim_reduce_type <- \"DDRTree\"\n      cds <- monocle:::findNearestPointOnMST(cds)\n    }\n    else if(reduction_method == \"spl\"){\n      message('This option is not ready yet')\n    }\n    else {\n      stop(\"Error: unrecognized dimensionality reduction method\")\n    }\n  }\n  cds\n}\n\n",
    "created" : 1507157527476.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3550632765",
    "id" : "71E08C8A",
    "lastKnownWriteTime" : 1508379680,
    "last_content_update" : 1508379680284,
    "path" : "~/Dropbox (Personal)/Projects/Causal_network/causal_network/Cpp/Real_deal/Scribe/Scribe/R/function.R",
    "project_path" : "R/function.R",
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}