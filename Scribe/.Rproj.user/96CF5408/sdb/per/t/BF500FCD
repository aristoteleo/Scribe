{
    "collab_server" : "",
    "contents" : "# Generated by using Rcpp::compileAttributes() -> do not edit by hand\n# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393\n\nclr <- function(x) {\n    .Call('_Scribe_clr', PACKAGE = 'Scribe', x)\n}\n\nkde_cpp <- function(data, k = 1L, b = 1L, pdf = 1L, density_sample_type = 1L) {\n    .Call('_Scribe_kde_cpp', PACKAGE = 'Scribe', data, k, b, pdf, density_sample_type)\n}\n\n#' @title\n#' kde\n#' @description\n#' This subroutine calculates the 2d density for a two dimensional matrix using kernel density estimator. \n#' \n#' @param data A two dimensional matrix, data, where the first row correspondds to the sample and column corresponds to the dimensions.\n#' @param k Kernel type. 1 = Gaussian (default); 2 = Box; 3 = Epanechnikov\n#' @param b Bandwidth optimisation (Gaussian only). 1 = Default; 2 = AMISE optimal, secant method; 3 = AMISE optimal, bisection method\n#' @param pdf Calculate PDF or CDF. 1 = PDF (default); 2 = CDF.\n#' @param density_sample_type Where do you want to calculate the kde density. 1 = Original data points (default); 2 = on a pre-defined grid.  \n#' \n#' @details\n#' \\code{kde} takes a 2D matrix and uses kernel density estimator to calculate the density \n#' at location of the original data points (default) or a grid of points. For a one dimension matrix, \n#' the grid is calculated on 1001 evenly spaced points while for a two dimensional matrix, it will be \n#' calculated on 201 evenly spaced points on each dimension (201 x 201 points in total).  \n#' @return a NumericMatrix where the element is the density estimate (name: density_estimate), \n#' the second one is the weight calculated based on density_estimate. This function is based on from Tim Nugent\n#' (https://github.com/timnugent/kernel-density).  \n#' @export\nkde <- function(data, k, b, pdf, density_sample_type) {\n    .Call('_Scribe_kde', PACKAGE = 'Scribe', data, k, b, pdf, density_sample_type)\n}\n\n#'  This subroutine calculates the volume of a d-dimensional unit ball for Euclidean norm\nNULL\n\n#' This function estimates the entropy of a continuous random variable\nNULL\n\n#' This function estimates the CONDITIONAL mutual information of X and Y given Z\n#' Multiply a number by two\n#'\nNULL\n\n#' @title\n#' knn_density\n#' @description\n#' This subroutine calculates the 1d density of x at positions y \n#' \n#' @param x 1d vector of the data \n#' @param y 1d vector of querying points, positions used to estimate the density \n#' @param k number of nearest neighbors used to estimate the 1d density, default to be 5 \n#' \n#' @details\n#' \\code{knn_density} takes a vector of original data points x and a vector of querying points y\n#' to calculate the density at each point y using the k-nearest neighbors. \n#' @return a List where the element is the density estimate (name: density_estimate), \n#' the second one is the weight calculated based on density_estimate.  \n#' @export\nknn_density <- function(x, y, k) {\n    .Call('_Scribe_knn_density', PACKAGE = 'Scribe', x, y, k)\n}\n\n#' @title\n#' knn_density_2d\n#' @description\n#' This subroutine calculates the density for a 2d space. \n#' \n#' @param x A vector for the values of the data on the first dimension \n#' @param y A vector for the values of the data on the second dimension \n#' @param nGrids A vector of two for the grid numbers on the first and second dimension \n#' @param k number of nearest neighbors used to calculate the 2d density \n#' \n#' @details\n#' \\code{knn_density_2d} \n#' @return a numeric value for the d-dimensional unit ball for Euclidean norm\n#' @export a matrix of density estimate, calculated on the center of each grid from the data x and y. \nknn_density_2d <- function(x, y, nGrids, k) {\n    .Call('_Scribe_knn_density_2d', PACKAGE = 'Scribe', x, y, nGrids, k)\n}\n\ndigamma_0 <- function(x) {\n    .Call('_Scribe_digamma_0', PACKAGE = 'Scribe', x)\n}\n\n#' @title\n#' vd\n#' @description\n#' This subroutine calculates the volume of a d-dimensional unit ball for Euclidean norm\n#' \n#' @param d number of dimension\n#' \n#' @details\n#' \\code{vd} takes a integer of dimensions and then calculate the volume of a d-dimensional unit ball for Euclidean norm\n#' using the formula: 0.5 * d * log(pi) - log(gamma(0.5 * d + 1))\n#' It's implimented in C++, providing a (small) increase in speed over the R equivalent.\n#' @return a numeric value for the d-dimensional unit ball for Euclidean norm\n#' @export\nvd <- function(d) {\n    .Call('_Scribe_vd', PACKAGE = 'Scribe', d)\n}\n\n#' @title\n#' entropy\n#' @description\n#' This subroutine estimates the entropy of a continuous random variable\n#' \n#' @param x data matrix used for calculating the entropy\n#' \n#' @param k number for nearest neighbors used in entropy calculation\n#'\n#' @details\n#' \\code{entropy} takes a continuous random variable and then estimates\n#' entropy using the KSG estimator. \n#' It relies on the ANN package to query the kNN with KDTree algorithm.  \n#' @return a numeric value of entropy estimate\n#' @export\nentropy <- function(x, k) {\n    .Call('_Scribe_entropy', PACKAGE = 'Scribe', x, k)\n}\n\n#' @title\n#' mi\n#' @description\n#' This function estimates the mutual information of two random variables, x, y, based on their observed values\n#' \n#' @param x one random variable from the time-series data\n#' \n#' @param y another random variable from the time-series data\n#'\n#' @param k number for nearest neighbors used in entropy calculation\n#'\n#' @param normalize A logic flag to determine whether or not you want to normalize the MI value by the density of x. \n#'\n#' @details\n#' \\code{mi} takes two random variables x and y to estimate the mutual information between them \n#' using the KSG estimator\n#' It relies on the ANN package to query the kNN with KDTree algorithm. \n#' @return a estimated mutual information value between two variables (x, y)\n#' @export\nmi <- function(x, y, k, normalize) {\n    .Call('_Scribe_mi', PACKAGE = 'Scribe', x, y, k, normalize)\n}\n\n#' @title\n#' cmi\n#' @description\n#' This subroutine calculates the volume of a d-dimensional unit ball for Euclidean norm\n#' \n#' @param x one random variable from the time-series data\n#' \n#' @param y another random variable from the time-series data\n#'\n#' @param z condition random variable for variables (x, y) from the time-series data\n#'\n#' @param k number for nearest neighbors used in entropy calculation\n#'\n#' @param normalize A logic flag to determine whether or not you want to normalize the MI value by the density of x. \n#'\n#' @details\n#' \\code{cmi} takes two random variable x and y and estimated their mutual information conditioned on the third random variable z\n#' using the KSG estimator. \n#' It relies on the ANN package to query the kNN with KDTree algorithm. \n#' @return a estimated conditional mutual information value between two variables (x, y), conditioning on a third variable z. \n#' @export\ncmi <- function(x, y, z, k, normalize) {\n    .Call('_Scribe_cmi', PACKAGE = 'Scribe', x, y, z, k, normalize)\n}\n\nucmi_cpp <- function(x, y, z, k, method, k_density, bw) {\n    .Call('_Scribe_ucmi_cpp', PACKAGE = 'Scribe', x, y, z, k, method, k_density, bw)\n}\n\n#' @title\n#' ucmi\n#' @description\n#' This subroutine calculates the uniformed conditional mutual information where \n#' the distribution for x and z is replaced by a uniform distribution.  \n#' \n#' @param x one random variable from the time-series data\n#' @param y another random variable from the time-series data\n#' @param z condition random variable for variables (x, y) from the time-series data\n#' @param k number for nearest neighbors used in entropy calculation\n#' @param method Which 2D density estimator you would like to use. 1 is kde estimator and 2 is knn based estimator. \n#' @param k_density The number of k nearest neighbors you would like to use when calculating the density \n#' (only applicable when method == 2 or using knn based density estimation). \n#' @param bw Bindwidth used for the kernel density estimator. Currently it is not used. The bindwidth in the kde function is automatically estimated. \n#' \n#' @details\n#' \\code{ucmi} takes two random variable x and y and estimated their mutual information conditioned on the third random variable z\n#' using the KSG estimator while x, y is replaced by a uniform distribution. It relies on a C++ implmentation of kde estimator \n#' (https://github.com/timnugent/kernel-density) and the ANN package to query the kNN with KDTree algorithm. \n#' @return  a estimated conditional mutual information value between two variables (x, y), conditioning on a third variable z where \n#' the distribution for the x, z is replaced by a uniform distribution. \n#'  \n#' @export\nucmi <- function(x, y, z, k, method, k_density, bw) {\n    .Call('_Scribe_ucmi', PACKAGE = 'Scribe', x, y, z, k, method, k_density, bw)\n}\n\numi_cpp <- function(x, y, k, method, k_density, bw) {\n    .Call('_Scribe_umi_cpp', PACKAGE = 'Scribe', x, y, k, method, k_density, bw)\n}\n\n#' @title\n#' umi\n#' @description\n#' This subroutine calculates the uniformed  mutual information where \n#' the distribution for x is replaced by a uniform distribution.  \n#' \n#' @param x one random variable from the time-series data\n#' @param y another random variable from the time-series data\n#' @param k number for nearest neighbors used in entropy calculation\n#' @param method Which 2D density estimator you would like to use. 1 is kde estimator and 2 is knn based estimator. \n#' @param k_density The number of k nearest neighbors you would like to use when calculating the density \n#' (only applicable when method == 2 or using knn based density estimation). \n#' @param bw Bindwidth used for the kernel density estimator. Currently it is not used. The bindwidth in the kde function is automatically estimated. \n#' \n#' @details\n#' \\code{umi} takes two random variable x and y and estimated their mutual using the KSG estimator while x is replaced by a uniform distribution. \n#' It relies on a C++ implmentation of kde estimator (https://github.com/timnugent/kernel-density) and the ANN package to query the kNN with KDTree algorithm. \n#' @return  A estimated uniform mutual information value between two variables (x, y) where the distribution for the x is replaced by a uniform distribution. \n#'  \n#' @export\numi <- function(x, y, k, method, k_density, bw) {\n    .Call('_Scribe_umi', PACKAGE = 'Scribe', x, y, k, method, k_density, bw)\n}\n\n#' @title\n#' di_single_run\n#' @description\n#' This function estimates the DIRECTED mutual information from X to Y when you have a SINGLE run of the process\n#' \n#' @param x one random variable from the time-series data\n#' \n#' @param y another random variable from the time-series data\n#'\n#' @param n Parameter n determines the the number of previous time samples upon which the mi is conditioned (delay in the formula I(x-->y)=I(x_{t-d};y_t|y_{t-1}) default: d=1)\n#'\n#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n#' @details\n#' \\code{di_single_run} takes two random variables x and y as well as a delay n to estimate the direct information between variable x and y. \n#' @return a matrix for the condition mutual information estimators between all pairwise variables (x, y) in the data matrix x, y\n#' @export\ndi_single_run <- function(x, y, n, uniformalize) {\n    .Call('_Scribe_di_single_run', PACKAGE = 'Scribe', x, y, n, uniformalize)\n}\n\n#' @title\n#' di_single_run_conditioned\n#' @description\n#' This function estimates the CONDITIONED DIRECTED mutual information from X to Y, conditioning on a third variable, z, when you have a SINGLE run of the processes\n#' \n#' @param x one random variable from the time-series data\n#' \n#' @param y another random variable from the time-series data\n#'\n#' @param z z is a dataframe (or matrix) containing the data of other processes upon the past of which the mi is conditioned\n#' \n#' @param n Parameter n determines the the number of previous time samples upon which the mi is conditioned\n#' \n#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n#' @details\n#' \\code{di_single_run_conditioned} takes two random variables x, y and z as well as the parameter n to calculate the direct information conditioned on variable z. \n#' @return a numeric value for the condition mutual information estimator variables (x, y), conditioning on a third variable, z. \n#' @export\ndi_single_run_conditioned <- function(x, y, z, n, uniformalize) {\n    .Call('_Scribe_di_single_run_conditioned', PACKAGE = 'Scribe', x, y, z, n, uniformalize)\n}\n\n#' @title\n#' rdi_many_runs\n#' @description\n#' This function estimates the DIRECTED mutual information from X to Y when you have multiple run of the processes.\n#' \n#' @param x a random variable with multiple run of the same process.\n#' \n#' @param y another random variable with multiple run of another process.\n#'\n#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n#' @details\n#' \\code{rdi_many_runs} takes two random variables (with the same multiple realization of the two processes) and estimate \n#' the direct information between them at each time point. It then sums up those information estimators. This function can\n#' only be used when you have hundreds runs of the same time-series experiment. \n#' @return a numeric value storing the DI from two multiple run variables\n#' @export\nrdi_many_runs <- function(x, y, uniformalize) {\n    .Call('_Scribe_rdi_many_runs', PACKAGE = 'Scribe', x, y, uniformalize)\n}\n\n#' @title\n#' rdi_single_run\n#' @description\n#' This function estimates the RESTRICTED DIRECTED mutual information from X to Y when you have a SINGLE run of the processes\n#' \n#' @param x one random variable from the time-series data\n#' \n#' @param y another random variable from the time-series data\n#' \n#' @param d delay in the formula I(x-->y)=I(x_{t-d};y_t|y_{t-1}) default: d=1\n#'\n#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n#' @details\n#' \\code{rdi_single_run} takes two random variables x and y as well as a time delay d to estimate the restricted direct infomation between them.\n#' @return a numeric value for the restricted direct information between x and y with a time delay d = 1. \n#' @export\nrdi_single_run <- function(x, y, d, uniformalize) {\n    .Call('_Scribe_rdi_single_run', PACKAGE = 'Scribe', x, y, d, uniformalize)\n}\n\n#' @title\n#' lmi_single_run\n#' @description\n#' This subroutine calculates the lagged mutual information \n#' \n#' @param x one random variable from the time-series data\n#' \n#' @param y another random variable from the time-series data\n#'\n#' @param delay Time lags used to estimate the RDI values  \n#'\n#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n#' @details\n#' \\code{lmi_single_run} takes two random variable x and y and estimated their mutual information with a time lag d. \n#' using the KSG estimator. \n#' It relies on the ANN package to query the kNN with KDTree algorithm. \n#' @return a numeric value for the mutual information estimator between two variables (x, y) with a time lag d.\n#' @export\nlmi_single_run <- function(x, y, delay, umi) {\n    .Call('_Scribe_lmi_single_run', PACKAGE = 'Scribe', x, y, delay, umi)\n}\n\nlmi_multiple_run_cpp <- function(x, y, d = 1L, run_vec = 0L, uniformalize = FALSE) {\n    .Call('_Scribe_lmi_multiple_run_cpp', PACKAGE = 'Scribe', x, y, d, run_vec, uniformalize)\n}\n\n#' @title\n#' lmi_multiple_run\n#' @description\n#' This subroutine calculates the lagged mutual information with multiple realization of the same processes. \n#' \n#' @param x one random variable from the time-series data\n#' \n#' @param y another random variable from the time-series data\n#'\n#' @param d Time lags used to estimate the RDI values  \n#'\n#' @param run_vec A integer vector encodes the information of the run id (run id start from 0) \n#'\n#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n#' @details\n#' \\code{lmi_multiple_run} takes two random variables x and y, each has multiple realization of the same process and estimated their mutual information with a time lag d. \n#' using the KSG estimator. \n#' It relies on the ANN package to query the kNN with KDTree algorithm. \n#' @return a numeric value for the estimated mutual information between two variables (x, y) with a time lag d. \n#' @export\nlmi_multiple_run <- function(x, y, d, run_vec, umi) {\n    .Call('_Scribe_lmi_multiple_run', PACKAGE = 'Scribe', x, y, d, run_vec, umi)\n}\n\n#' @title\n#' rdi_single_run_conditioned\n#' @description\n#' This function estimates the CONDITIONED DIRECTED mutual information from X to Y CONDITIONED ON Z when you have a SINGLE run of the processes\n#' \n#' @param x one random variable from the time-series data\n#' \n#' @param y another random variable from the time-series data\n#' \n#' @param z z is a dataframe or matrix consisting of the data for different variables which will be conditioned on. \n#' \n#' @param z_delays z_delay is also a dataframe or matrix consisting of the delays to be applied to different variables\n#' \n#' @param d delay in the formula I(x-->y)=I(x_{t-d};y_t|y_{t-1}) default: d=1\n#'\n#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n#' @details\n#' \\code{rdi_single_run_conditioned} takes two random variables x and y as well as the parameter d to calculate the restricted direct information conditioned on variable z. \n#' @return a numeric value for the estimated condition mutual information between variable x and y conditioning on a third variable z \n#' @export\nrdi_single_run_conditioned <- function(x, y, z, z_delays, d, uniformalize) {\n    .Call('_Scribe_rdi_single_run_conditioned', PACKAGE = 'Scribe', x, y, z, z_delays, d, uniformalize)\n}\n\nextract_max_rdi_value_delay <- function(rdi_result, delays) {\n    .Call('_Scribe_extract_max_rdi_value_delay', PACKAGE = 'Scribe', rdi_result, delays)\n}\n\ncalculate_rdi_cpp <- function(expr_data, delays, super_graph, turning_points, method, uniformalize = FALSE) {\n    .Call('_Scribe_calculate_rdi_cpp', PACKAGE = 'Scribe', expr_data, delays, super_graph, turning_points, method, uniformalize)\n}\n\n#' @title\n#' calculate_rdi_cpp_wrap\n#' @description\n#' This function estimates the DIRECTED mutual information for all gene pairs in the expr_data matrix when you have a SINGLE run of the processes\n#' \n#' @param expr_data a matrix for all variables in a time-series where each row is a time point and each column is a variable (for example, a gene). \n#' The rows are ordered according to time, from earliest to latest. \n#' \n#' @param delays An integer vector storing the time delays between pairs of variables you would like to try. \n#' \n#' @param super_graph An integer matrix where each row is the variable IDs or gene pairs you would like to estimate restricted direct information (RDI) from. \n#'  \n#' @param turning_points Either 0 or a numeric vector describing the inflection point (linear trajectory) or branch point (bifurcation point) for each gene. \n#' If the turning_point for each gene is provided, the time delay will be estimated based on the turning point. \n#'\n#' @param method An integer of either 1 or 2 to determine which information metric will be used to quantify the causality. \n#' If method is 1, then lagged mutual information will be used; if method is 2, then the restricted direct information will be used. \n#'\n#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n#' @details\n#' \\code{calculate_rdi_cpp_wrap} takes an expression matrix (expr_data) and possible gene pairs (encoded in super_graph) to estimate the restricted \n#' direct information based on the time delay which can be estimated from the turning_point vector. \n#' @return a numeric matrix of conditional RDI values for all possible pairs of genes from expr_data. If the gene pairs is not encoded in the super_graph, it will remain as 0 in the matrix.  \n#' @export\ncalculate_rdi_cpp_wrap <- function(expr_data, delays, super_graph, turning_points, method, uniformalize) {\n    .Call('_Scribe_calculate_rdi_cpp_wrap', PACKAGE = 'Scribe', expr_data, delays, super_graph, turning_points, method, uniformalize)\n}\n\nextract_top_incoming_nodes_delays <- function(max_rdi_value, max_rdi_delays, k = 1L) {\n    .Call('_Scribe_extract_top_incoming_nodes_delays', PACKAGE = 'Scribe', max_rdi_value, max_rdi_delays, k)\n}\n\n#' @title\n#' calculate_conditioned_rdi_cpp_wrap\n#' @description\n#' This function estimates the conditional DIRECTED mutual information for all gene pairs in the expr_data matrix when you have a SINGLE run of the processes.\n#' \n#' @param expr_data a matrix for all variables in a time-series where each row is a time point and each column is a variable (for example, a gene). \n#' The rows are ordered according to time, from earliest to latest. \n#' \n#' @param super_graph An integer matrix where each row is the variable IDs or gene pairs you would like to estimate restricted direct information (RDI) from. \n#'  \n#' @param max_rdi_value A numeric matrix where each element corresponding to the maximal (identified from a series of time lags when calculating the rdi values) rdi value between two variables.  \n#' \n#' @param max_rdi_delays An integer matrix where each element corresponding to the time delay corresponding to the maximal (identified from a series of time lags when calculating the rdi values) rdi value between two variables.  \n#'\n#' @param k An integer for the number of incoming nodes to be conditioned on \n#'\n#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n#' @details\n#' \\code{calculate_conditioned_rdi_cpp_wrap} takes an expression matrix (expr_data) and possible gene pairs (encoded in super_graph), as well as the matrices of maximal rdi value or the delays corresponding to those values to \n#' estimate the conditional restricted direct information, conditioning on top k incoming nodes. \n#' @return a numeric matrix of conditional RDI values for all possible pairs of genes from expr_data. If the gene pairs is not encoded in the super_graph, it will remain as 0 in the matrix.  \n#' @export\ncalculate_conditioned_rdi_cpp_wrap <- function(expr_data, super_graph, max_rdi_value, max_rdi_delays, k, uniformalize) {\n    .Call('_Scribe_calculate_conditioned_rdi_cpp_wrap', PACKAGE = 'Scribe', expr_data, super_graph, max_rdi_value, max_rdi_delays, k, uniformalize)\n}\n\n#' @title\n#' smooth_gene\n#' @description\n#' This subroutine takes a time-series data and returns a moving average for the data. \n#' \n#' @param expr_data a matrix for all variables in a time-series where each row is a time point and each column is a variable (for example, a gene). \n#' The rows are ordered according to time, from earliest to latest. \n#' \n#' @param window_size Integer value for the smoothing window used for calculating the moving average.  \n#'\n#' @details\n#' \\code{entropy} takes a integer of dimensions and then calculate the olume of a d-dimensional unit ball for Euclidean norm\n#' using the formula: 0.5 * d * log(pi) - log(gamma(0.5 * d + 1))\n#' It's implimented in C++, providing a (small) increase in speed over the R equivalent.\n#' @return a updated matrix with gene expression smoothed with window size equal to window_size\n#' @export\nsmooth_gene <- function(expr_data, window_size = 40L) {\n    .Call('_Scribe_smooth_gene', PACKAGE = 'Scribe', expr_data, window_size)\n}\n\nrdi_multiple_run_cpp <- function(x, y, d = 1L, run_vec = 0L, uniformalize = FALSE) {\n    .Call('_Scribe_rdi_multiple_run_cpp', PACKAGE = 'Scribe', x, y, d, run_vec, uniformalize)\n}\n\ncalculate_rdi_multiple_run_cpp <- function(expr_data, delays, run_vec, super_graph, turning_points = 0L, method = 1L, uniformalize = FALSE) {\n    .Call('_Scribe_calculate_rdi_multiple_run_cpp', PACKAGE = 'Scribe', expr_data, delays, run_vec, super_graph, turning_points, method, uniformalize)\n}\n\n#' @title\n#' calculate_rdi_multiple_run_cpp_wrap\n#' @description\n#' This function estimates the DIRECTED mutual information for all gene pairs in the expr_data matrix when you have a SINGLE run of the processes\n#' \n#' @param expr_data a matrix for all variables in a time-series where each row is a time point and each column is a variable (for example, a gene). \n#' The rows are ordered according to time, from earliest to latest. \n#' \n#' @param delays An integer vector storing the time delays between pairs of variables you would like to try. \n#' \n#' @param super_graph An integer matrix where each row is the variable IDs or gene pairs you would like to estimate restricted direct information (RDI) from. \n#'  \n#' @param turning_points Either 0 or a numeric vector describing the inflection point (linear trajectory) or branch point (bifurcation point) for each gene. \n#' If the turning_point for each gene is provided, the time delay will be estimated based on the turning point. \n#'\n#' @param method An integer of either 1 or 2 to determine which information metric will be used to quantify the causality. \n#' If method is 1, then lagged mutual information will be used; if method is 2, then the restricted direct information will be used. \n#'\n#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n#' @details\n#' \\code{calculate_rdi_multiple_run_cpp_wrap}, similar to calculate_rdi_cpp_wrap, takes an expression matrix (expr_data) and possible gene pairs (encoded in super_graph) to estimate the restricted \n#' direct information based on the time delay which can be estimated from the turning_point vector. It, however, differs to calculate_rdi_cpp_wrap, in that it can concatenate different experiments (runs) into a single run of the data for causality estimation. \n#' @return a numeric matrix of conditional RDI values for all possible pairs of genes from expr_data. If the gene pairs is not encoded in the super_graph, it will remain as 0 in the matrix.  \n#' @export\ncalculate_rdi_multiple_run_cpp_wrap <- function(expr_data, delays, run_vec, super_graph, turning_points, method, uniformalize) {\n    .Call('_Scribe_calculate_rdi_multiple_run_cpp_wrap', PACKAGE = 'Scribe', expr_data, delays, run_vec, super_graph, turning_points, method, uniformalize)\n}\n\nrdi_multiple_runs_conditioned_cpp <- function(x, y, z, z_delays, d = 1L, run_vec = 0L, uniformalize = FALSE) {\n    .Call('_Scribe_rdi_multiple_runs_conditioned_cpp', PACKAGE = 'Scribe', x, y, z, z_delays, d, run_vec, uniformalize)\n}\n\n#' @title\n#' This function simulates the CONDITIONED DIRECTED mutual information from X to Y CONDITIONED ON Z when you have a SINGLE run of the processes\n#' @description\n#' This subroutine calculates the volume of a d-dimensional unit ball for Euclidean norm\n#' \n#' @param x one random variable from the time-series data\n#' \n#' @param y another random variable from the time-series data\n#' \n#' @param z z is a dataframe or matrix consisting of the data for different variables\n#' \n#' @param z_delays z_delay is also a dataframe or matrix consisting of the delays to be applied to different variables\n#' \n#' @param d delay in the formula I(x-->y)=I(x_{t-d};y_t|y_{t-1}) default: d=1\n#'\n#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n#' @details\n#' \\code{rdi_single_run_conditioned} takes two random variables x and y as well as the parameter n to calculate the restricted direct information conditioned on variable z. \n#' @return a matrix for the condition mutual information estimators between all pairwise variables (x, y) in the data matrix x, y\n#' @export\nrdi_multiple_runs_conditioned <- function(x, y, z, z_delays, d, run_vec, uniformalize) {\n    .Call('_Scribe_rdi_multiple_runs_conditioned', PACKAGE = 'Scribe', x, y, z, z_delays, d, run_vec, uniformalize)\n}\n\ncalculate_conditioned_rdi_multiple_run_cpp <- function(expr_data, super_graph, max_rdi_value, max_rdi_delays, run_vec = 0L, k = 1L, uniformalize = FALSE) {\n    .Call('_Scribe_calculate_conditioned_rdi_multiple_run_cpp', PACKAGE = 'Scribe', expr_data, super_graph, max_rdi_value, max_rdi_delays, run_vec, k, uniformalize)\n}\n\n#' @title\n#' calculate_conditioned_rdi_multiple_run_wrap\n#' @description\n#' This function estimates the conditional DIRECTED mutual information for all gene pairs in the expr_data matrix when you have a SINGLE run of the processes.\n#' \n#' @param expr_data a matrix for all variables in a time-series where each row is a time point and each column is a variable (for example, a gene). \n#' The rows are ordered according to time, from earliest to latest. \n#' \n#' @param super_graph An integer matrix where each row is the variable IDs or gene pairs you would like to estimate restricted direct information (RDI) from. \n#'  \n#' @param max_rdi_value A numeric matrix where each element corresponding to the maximal (identified from a series of time lags when calculating the rdi values) rdi value between two variables.  \n#' \n#' @param max_rdi_delays An integer matrix where each element corresponding to the time delay corresponding to the maximal (identified from a series of time lags when calculating the rdi values) rdi value between two variables.  \n#'\n#' @param run_vec An integer vector keeping the run id for each sample. \n#'\n#' @param k An integer for the number of incoming nodes to be conditioned on.\n#'\n#' @param uniformalize Whether or not you want to use ucmi to calculate rdi. Default to be false. \n#' @details\n#' \\code{calculate_conditioned_rdi_multiple_run_wrap}, similar to calculate_conditioned_rdi_cpp_wrap, takes an expression matrix (expr_data) and possible gene pairs (encoded in super_graph), as well as the matrices of maximal rdi value or the delays corresponding to those values to \n#' estimate the conditional restricted direct information, conditioning on top k incoming nodes. It, however, differs to calculate_conditioned_rdi_cpp_wrap, in that it can concatenate different experiments (runs) into a single run of the data for causality estimation. \n#' @return a numeric matrix of conditional RDI values for all possible pairs of genes from expr_data. If the gene pairs is not encoded in the super_graph, it will remain as 0 in the matrix.  \n#' @export\ncalculate_conditioned_rdi_multiple_run_wrap <- function(expr_data, super_graph, max_rdi_value, max_rdi_delays, run_vec, k, uniformalize) {\n    .Call('_Scribe_calculate_conditioned_rdi_multiple_run_wrap', PACKAGE = 'Scribe', expr_data, super_graph, max_rdi_value, max_rdi_delays, run_vec, k, uniformalize)\n}\n\ncalculate_umi_cpp <- function(expr_data, super_graph, k, method, k_density, bw) {\n    .Call('_Scribe_calculate_umi_cpp', PACKAGE = 'Scribe', expr_data, super_graph, k, method, k_density, bw)\n}\n\ncalculate_umi_cpp_wrap <- function(expr_data, super_graph, k, method, k_density, bw) {\n    .Call('_Scribe_calculate_umi_cpp_wrap', PACKAGE = 'Scribe', expr_data, super_graph, k, method, k_density, bw)\n}\n\n# Register entry points for exported C++ functions\nmethods::setLoadAction(function(ns) {\n    .Call('_Scribe_RcppExport_registerCCallable', PACKAGE = 'Scribe')\n})\n",
    "created" : 1507446184502.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2387754048",
    "id" : "BF500FCD",
    "lastKnownWriteTime" : 1507862697,
    "last_content_update" : 1507862697,
    "path" : "~/Dropbox (Personal)/Projects/Causal_network/causal_network/Cpp/Real_deal/Scribe/Scribe/R/RcppExports.R",
    "project_path" : "R/RcppExports.R",
    "properties" : {
    },
    "relative_order" : 11,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}